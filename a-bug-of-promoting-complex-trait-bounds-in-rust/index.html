<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><title>A Flaw of Promoting Complex Trait Bounds in Rust</title><meta itemprop="title" content="A Flaw of Promoting Complex Trait Bounds in Rust - hsfzxjy 的博客"><meta itemprop="og:title" content="A Flaw of Promoting Complex Trait Bounds in Rust - hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="description" content="Days ago, for some reason, I was trying to implement a fu..."><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div lang="en" class="post post-page"><h1 lang="en" class="post__title">A Flaw of Promoting Complex Trait Bounds in Rust</h1><div class="post__meta font__ui">2022-03-30 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div class="post__content font__body"><p>Days ago, for some reason, I was trying to implement a function that can polymorphize over its return type. The solution is simple, but my brain was jammed at that time, trapped in some complicated typing tricks for hours.</p><p class="nomargin">During the struggling, I coincidently ran into something that is temporarily a flaw in the current Rust compiler implementation. In some cases, the compiler is not smart enough to promote known trait bounds, and we have to replicate them again and again. Although the problem is afterwards proved to be a useless “X-Y Problem”, I would still like to share the story.</p><h2 id="the-problem-2">The Problem</h2><p>Let’s say we are going to write a function that digests a given <code>&amp;[u8]</code> slice and computes a hash value. The function would adopt either of two different algorithms, and a <code>u64</code> or <code>u128</code> integer is returned as the hash result.</p><p class="nomargin">Trivially, this can be achieved by splitting into two functions <code>get_hash_u64()</code> and <code>get_hash_u128()</code>. But I prefer to have a single and unified interface, so concretely, I am expecting a function to polymorphize over its return type, with the following signature</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_hash</span>&lt;T&gt;(b: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> T</span><br><span class="line">    <span class="hljs-keyword">where</span> <span class="hljs-comment">/* some bounds on T */</span></span><br><span class="line">{ todo!() }</span><br></pre></div></div><p class="nomargin">Two things I should fill in for the above snippet</p><ol><li>The <code>where</code>-clause. Some trait bounds might be satisfied for typevar <code>T</code>, and I expect them to be as concise as possible in order for less verbosity in callers.</li><li>The body. The function should behave differently regarding different typevar <code>T</code>.</li></ol><p class="nomargin">In order to emulate the effect of choosing different hashing algorithm, we expect a different numeric value be returnedwhen different typevar <code>T</code> supplied. Also, since the argument <code>b: &amp;[u8]</code> is irrelavant to our problem, I will omit it in the following text for brevity. So overall, I would like the two assertions to be held</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-built_in">assert_eq!</span>(get_hash::&lt;<span class="hljs-type">u64</span>&gt;(), <span class="hljs-number">42u64</span>);</span><br><span class="line"><span class="hljs-built_in">assert_eq!</span>(get_hash::&lt;<span class="hljs-type">u128</span>&gt;(), <span class="hljs-number">4242u128</span>);</span><br></pre></div></div><h2 id="the-simple-answer">The Simple Answer</h2><p>Before stepping far, I will place a simple and straight-forward solution at the front, in case of anybody taking the same wrong path.</p><p class="nomargin">Specifically, we can define a trait, say <code>HashVal</code>, as the upper bound of all possbile return types for <code>get_hash</code>.</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">HashVal</span>: <span class="hljs-built_in">Sized</span> {</span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">digest</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>;</span><br><span class="line">}</span><br></pre></div></div><p class="par">For each possible type such as <code>u64</code> or <code>u128</code>, we place corresponding hashing algorithm in <code>HashVal::digest</code></p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">HashVal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">u64</span> {</span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">digest</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> { <span class="hljs-number">42u64</span> }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">HashVal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">u128</span> {</span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">digest</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> { <span class="hljs-number">4242u128</span> }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_hash</span>&lt;T: HashVal&gt;() <span class="hljs-punctuation">-&gt;</span> T {</span><br><span class="line">    T::<span class="hljs-title function_ invoke__">digest</span>()</span><br><span class="line">}</span><br></pre></div></div><p class="par"><code>get_hash&lt;T&gt;()</code> is now polymorphized over return type <code>T</code>. User might select a 64-bit hashing algorithm via a calling like <code>get_hash::&lt;u64&gt;()</code>.</p><p>This solution is neat and, most importantly, the prerequisite <code>T: HashVal</code> is concise and self-explained, which saves a lot of verbosity in callers’ <code>where</code>-clause. However, this didn’t come to my mind at that time. I alternatively choose a more complicated solution.</p><h2 id="the-complicated-answer">The Complicated Answer</h2><p>In this version, I start by a dummy struct <code>Hasher</code> and a trait <code>HashDispatcher&lt;T&gt;</code>.</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Hasher</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">HashDispatcher</span>&lt;T&gt; {</span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">digest</span>() <span class="hljs-punctuation">-&gt;</span> T;</span><br><span class="line">}</span><br></pre></div></div><p class="par">The struct <code>Hasher</code> implements <code>HashDispatcher&lt;T&gt;</code> for different type <code>T</code> with corresponding algorithm filled in <code>digest()</code> method</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">HashDispatcher</span>&lt;<span class="hljs-type">u64</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Hasher</span> {</span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">digest</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u64</span> { <span class="hljs-number">42u64</span> };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">HashDispatcher</span>&lt;<span class="hljs-type">u128</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Hasher</span> {</span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">digest</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u128</span> { <span class="hljs-number">4242u128</span> };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_hash</span>&lt;T&gt;() <span class="hljs-punctuation">-&gt;</span> T <span class="hljs-keyword">where</span> Hasher: HashDispatcher&lt;T&gt; {</span><br><span class="line">    Hasher::<span class="hljs-title function_ invoke__">digest</span>()</span><br><span class="line">}</span><br></pre></div></div><p class="par">Function <code>get_hash&lt;T&gt;()</code> delegates the calling to <code>Hasher::digest()</code>, which requires a verbose trait bound <code>Hasher: HashDispatcher&lt;T&gt;</code>. In order to reduce the boilerplate, I was seeking to write another trait, named also <code>HashVal</code>, such that <em>for all <code>T</code> being a <code>HashVal</code>, the trait bound <code>Hasher: HashDispatcher&lt;T&gt;</code> holds</em>, or formally $$\text{T: HashVal} \Rightarrow \text{Hasher: HashDispatcher&amp;lt;T&amp;gt;}$$. If achieved, the signature of <code>get_hash</code> can be largely deduced into</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_hash</span>&lt;T: HashVal&gt;() <span class="hljs-punctuation">-&gt;</span> T;</span><br></pre></div></div><h2 id="the-incorrect-attempt-for-hashval">The Incorrect Attempt for HashVal</h2><p class="noindent">The first attempt I made was to place the bound in the <code>where</code>-clause of a generic <code>impl</code></p><div class="gk-code hljs" data-gk-id="BLOCK8"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">HashVal</span> {};</span><br><span class="line"><span class="hljs-keyword">impl</span>&lt;T&gt; HashVal <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span> <span class="hljs-keyword">where</span> Hasher: HashDispatcher&lt;T&gt; {}</span><br></pre></div></div><p class="par">I mistakenly thought this would fulfill my purpose. The statement instead should read as <em>“for every <code>T</code> that satisfies Hasher: HashDispatcher<t>, T is a HashVal”</t></em>, which delivers a different implication that <em>converses</em> to what I expect. Thank u/schungx for pointing out in the <a target="_blank" rel="noopener" href="https://www.reddit.com/r/rust/comments/tq4ga9/comment/i2nsa5q/?utm_source=share&utm_medium=web2x&context=3">reddit thread</a>. As a counter-example, one is able to impl other types as <code>HashVal</code>, while without ensuring them to satisfy my bound</p><div class="gk-code hljs" data-gk-id="BLOCK9"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">HashVal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">String</span> {}</span><br></pre></div></div><h2 id="the-correct-yet-flawed-attempt">The Correct yet Flawed Attempt</h2><p>u/SkiFire13 <a target="_blank" rel="noopener" href="https://www.reddit.com/r/rust/comments/tq4ga9/comment/i2eyene/?utm_source=share&utm_medium=web2x&context=3">mentioned</a> that the trait bound should be placed at the definition of <code>HashVal</code> to meet my requirement like this</p><div class="gk-code hljs" data-gk-id="BLOCK10"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">HashVal</span> <span class="hljs-keyword">where</span> Hasher: HashDispatcher&lt;<span class="hljs-keyword">Self</span>&gt; {}</span><br></pre></div></div><p class="par">I have no memory of seeing a <code>where</code> clause in the trait definition before. The syntax is not introduced by “The Book”, but rather mentioned in <a target="_blank" rel="noopener" href="https://rust-lang.github.io/rfcs/0135-where.html">the RFC of where clause</a>.</p><p><code>where</code>-clause for trait is not a new concept. In fact, the “supertrait” bound can be regarded as a specialized version of <code>where</code>-style bound</p><div class="gk-code hljs" data-gk-id="BLOCK11"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Foo</span>: Bar {}  <span class="hljs-comment">// is equivalent to</span></span><br><span class="line"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span>: Bar {}</span><br></pre></div></div><p class="par">More generally, the <code>where</code>-clause is used to elaborate the constraints that the typevars (or the special <code>Self</code>) should satisify. If <code>SomeT: Trait</code> holds, type <code>SomeT</code> should meet all the requirements in <code>Trait</code>‘s <code>where</code>-clause.</p><p class="par">As for our case, the <code>where</code>-clause grants an upper bound for <code>HashVal</code> – any type <code>T</code> implements <code>HashVal</code> should satisfy <code>Hasher: HashDispatcher&lt;T&gt;</code> beforehand, which is precisely our requirement.</p><p>With this declaration, however, we still cannot deduce the trait bound of <code>get_hash</code> to <code>T: HashVal</code>, due to the flaw of current compiler. A long discussion <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/20671">“where clauses are only elaborated for supertraits, and not other things”</a> can be found on Github back in 2015.</p><p class="nomargin">In short words, except from some simple constraints like supertraits, the constraints in <code>where</code>-clause will <em>only be respected within the trait definition (to ensure some type-checks in the trait can pass), but not be promoted in other places.</em></p><div class="gk-code hljs" data-gk-id="BLOCK12"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">HashVal</span>: <span class="hljs-built_in">Sized</span> <span class="hljs-keyword">where</span> Hasher: HashDispatcher&lt;<span class="hljs-keyword">Self</span>&gt; {</span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {</span><br><span class="line">        <span class="hljs-comment">// OK. the &quot;where&quot; bound permits the casting</span></span><br><span class="line">        &lt;Hasher <span class="hljs-keyword">as</span> HashDispatcher&lt;<span class="hljs-keyword">Self</span>&gt;&gt;::<span class="hljs-title function_ invoke__">digest</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Sized</span>&gt; HashVal <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span> <span class="hljs-keyword">where</span> Hasher: HashDispatcher&lt;T&gt; {}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// this fails, the bound is not promoted</span></span><br><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_hash</span>&lt;T: HashVal&gt;() <span class="hljs-punctuation">-&gt;</span> T {</span><br><span class="line">    Hasher::<span class="hljs-title function_ invoke__">digest</span>()</span><br><span class="line">}</span><br></pre></div></div><p>The flaw is quite annoying. We still have to replicate the verbose trait bounds here and there. Hopefully it can be fixed in the future.</p><br><blockquote><p class="cc"><b>Author:</b> hsfzxjy.<br><b>Link:</b> <span class="cc-link"></span>.<br><b>License:</b> <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>.<br>All rights reserved by the author.<br>Commercial use of this post in any form is <b>NOT</b> permitted.<br>Non-commercial use of this post should be attributed with this block of text.</p></blockquote><script>!function(){var n=document.querySelector("span.cc-link");n&&(n.innerHTML='<a href="'+location.href+'">'+location.href+"</a>")}()</script></div><div class="post__tags"><a href="/tags/Rust/">Rust</a><a href="/tags/Compiler/">Compiler</a><a href="/tags/Type-Theory/">Type Theory</a></div><div class="post-nav"><a href="/side-project/" class="pre">«Side Project（副业）</a><a href="/initialize-pool-worker-with-individual-values/" class="next">Initialize Process Pool Worker with Individual Value»</a></div><div id="disqus_thread"><div id="no-comment"><h2>OOPS!</h2><span>A comment box should be right here...</span><span>But it was gone due to network issues :-(</span><span>If you want to leave comments, make sure you have access to&nbsp;<a target="_blank" rel="noopener" href="https://disqus.com">disqus.com</a>.</span></div><script>var disqus_shortname="hsfzxjy",disqus_identifier="a-bug-of-promoting-complex-trait-bounds-in-rust/",disqus_title="A Flaw of Promoting Complex Trait Bounds in Rust",disqus_url="https://i.hsfzxjy.site/a-bug-of-promoting-complex-trait-bounds-in-rust/";!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.defer=!0,t.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(t),t.onerror=function(){document.getElementById("no-comment").classList.add("show")}}()</script><script id="dsq-count-scr" src="//hsfzxjy.disqus.com/count.js" async defer></script></div></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"><div id="toc" lang="en" class="font__body"><div class="toc-toggler"></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#the-problem-2"><span class="toc-number">1.</span> <span class="toc-text">The Problem</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-simple-answer"><span class="toc-number">2.</span> <span class="toc-text">The Simple Answer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-complicated-answer"><span class="toc-number">3.</span> <span class="toc-text">The Complicated Answer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-incorrect-attempt-for-hashval"><span class="toc-number">4.</span> <span class="toc-text">The Incorrect Attempt for HashVal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-correct-yet-flawed-attempt"><span class="toc-number">5.</span> <span class="toc-text">The Correct yet Flawed Attempt</span></a></li></ol></div></div></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>