<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script>(()=>{let r="/cnfonts.js",n=document,e=n.createElement("link");e.rel="stylesheet",e.href="/fontchan/jBKCaHQX.css",e.blocking="render",e.onerror=()=>{var e=n.createElement("script");e.src=r,e.onload=()=>$fontchan.injectCss(),n.head.appendChild(e)},n.head.appendChild(e),"serviceWorker"in navigator&&navigator.serviceWorker.register(r,{scope:"/"}).then(e=>e.update())})()</script><title>Tech | hsfzxjy 的博客</title><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div class="post-list"><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/obtain-a-random-unused-tcp-port-with-bash/">Obtain a Random Available TCP Port with Bash</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2021-03-10 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="61a4ff0a6add35a07b153395dfabd8317c95bb7c5e826892656333207dec9bad" class="post__content font__body"><p>On Linux, we might sometimes want to choose an unused TCP port randomly. This occurs from time to time on a server, when the administrator wants to expose an HTTP port for a user. Or, you just need an available port for IPC. Let’s make it happen with pure bash scripting.</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">unused_port</span></span>() {</span><br><span class="line">    N=<span class="hljs-variable">${1:-1}</span></span><br><span class="line">    <span class="hljs-built_in">comm</span> -23 \</span><br><span class="line">        &lt;(<span class="hljs-built_in">seq</span> <span class="hljs-string">&quot;1025&quot;</span> <span class="hljs-string">&quot;65535&quot;</span> | <span class="hljs-built_in">sort</span>) \</span><br><span class="line">        &lt;(ss -Htan |</span><br><span class="line">            awk <span class="hljs-string">&#x27;{print $4}&#x27;</span> |</span><br><span class="line">            <span class="hljs-built_in">cut</span> -d<span class="hljs-string">&#x27;:&#x27;</span> -f2 |</span><br><span class="line">            <span class="hljs-built_in">sort</span> -u) |</span><br><span class="line">        <span class="hljs-built_in">shuf</span> |</span><br><span class="line">        <span class="hljs-built_in">head</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$N</span>&quot;</span></span><br><span class="line">}</span><br></pre></div></div><p class="par">We would take apart the function step by step in the following paragraphs.</p></div><div lang="zh" class="post__readmore font__ui"><a href="/obtain-a-random-unused-tcp-port-with-bash/">READ MORE</a></div></article><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/information-theory-kl-divergence/">Information Theory: KL Divergence</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2020-01-15 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="a8f0f56dc4367b07c7485d47d768bf9f9b8ec557b02ab7148e2a920e1b7dd921" class="post__content font__body"><p>Assume there are two hypotheses $H_1$ and $H_2$, r.v. $X$ ranged in alphabets $\{a_1,\ldots\,a_k\}$. Under hypothesis $H_i$, $X$ has pdf $p(X=a_j|H_i)=p_i(a_j)$. According to Law of Total Probability, we have:</p><p>$$ p(H_i|a_k) = \frac{p(H_i)p_i(a_k)}{p_1(a_k)p(H_1)+p_2(a_k)p(H_2)} $$</p><p class="par">The formula can be transformed into:</p><p>$$ \log \frac{p_2(a_k)}{p_1(a_k)} = \log \frac{p(H_2|a_k)}{p(H_1|a_k)} - \log \frac{p(H_2)}{p(H_1)} $$</p><p class="par">which implies that, $\log \frac{p_2(a_k)}{p_1(a_k)}$ equals the difference of log likelihood ratio before and after conditioning $X=a_k$. We define $\log \frac{p_2(a_k)}{p_1(a_k)}$ be the discrimination information for $H_2$ over $H_1$, when $X=a_k$. The expectation of discrimination information is KL divergence, denoted as:</p><p>$$D_{KL}(P_2||P_1) = \sum_k p_2(a_k) \log \frac{p_2(a_k)}{p_1(a_k)} $$</p><p class="par">which sometimes denoted as $I(p2,p1;X)$, or simply $I(p2,p1)$ if without ambiguity.</p><p>KL Divergence can be interpreted as a measure of expected information for $X$ gained after distribution shifted from $p_1$ to $p_2$, where $p_1$ and $p_2$ regarded as prior and post-prior distributions.</p></div><div lang="zh" class="post__readmore font__ui"><a href="/information-theory-kl-divergence/">READ MORE</a></div></article><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/information-theory-entropy-and-mutual-information/">Information Theory: Entropy and Mutual Information</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2020-01-04 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="19b7471d880baa6bfdae585f620e85b1a8d50a66b8a6cac9d3fa0279b8d73e93" class="post__content font__body"><p>Given a discrete r.v. $X$, where $X$ ranged in $\{a_1, \ldots, a_n\}$, $\mathbb{P}(X=a_k)=p_k$. Entropy $H(X)$ is defined as:</p><p>$$H(X)= - \sum_k p_k \log p_k$$</p><p class="par">When regarded as a function of $\{p_k\}$, entropy satisfies the following properties:</p><ol><li>$H(p_1,\ldots,p_n)$ is continuous, and non-negative;</li><li>$H(p_1,\ldots,p_n)$ is convex w.r.t. $(p_1,\ldots,p_n)$;</li><li>$H(p_1,\ldots,p_n)$ has a unique maxima $(\frac{1}{n},\ldots,\frac{1}{n})$;</li><li>$H(n):=H(\frac{1}{n},\ldots,\frac{1}{n})$ increases along with $n$;</li><li>$H(p_1,\ldots,p_n)=H(p_1+\ldots+p_k,p_{k+1},\ldots,p_n)+(p_1+\ldots+p_k)H(p_{k+1}&#39;,\ldots,p_n&#39;)$.</li></ol><p class="par">Property 5 is so-called addictivity. That is, if we observe $X$ in two steps, firstly obtaining a value from $\{\hat{a},a_{k+1},\ldots,a_n\}$ and then another value from $\{a_1,\ldots,a_k\}$ if $\hat{a}$ selected, the entropy of the whole system should be sum of these two subsystems.</p><p class="nomargin">Note that a function satisfying property 1, 4, 5 must have a form of $H(\vec{p})= - C \sum_k p_k \log p_k$, which reveals that entropy function is unique.</p><p>Entropy measures the <strong>uncertainty</strong> of a random value. Intuitively, entropy reaches its maximum $\log n$ when all alphabets occur with same probability, and likewise has a minimum of $0$ if $p_k=1$ for some $k$.</p><p>Entropy also represents the smallest average length to encode a message. Say we have a message consisting of alphabets $a_1,\ldots,a_n$, occurring with probability $p_1,\ldots,p_n$. Now we want to assign a code (an $N$-ary string) to each alphabet, with no two codes sharing a same prefix. The length of the codes are denoted as $l_1,\ldots,l_n$. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shannon%27s_source_coding_theorem">Shannon’s source coding theroem</a> states that the average code length $\sum_k p_k l_k$ could not be less than $H(p_1,\ldots,p_n)$ (taking $N$ as logarithm base).</p></div><div lang="zh" class="post__readmore font__ui"><a href="/information-theory-entropy-and-mutual-information/">READ MORE</a></div></article><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/proof-of-gumbel-max-trick/">Proof of the Gumbel Max Trick</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2019-08-01 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="f3c989e3e00908baa34ab3d83871aa38754e7e0d10ad926d25ee0b4866ac42b7" class="post__content font__body"><h2 id="statement">Statement</h2><p class="noindent">Assume that $\alpha_1, \alpha_2, \ldots, \alpha_n$ satisify $\sum_k\alpha_k=1$. Define</p><p>$$Z=\arg\max_k\{\log\alpha_k+G_k\}$$</p><p class="par">where $G_1,\ldots,G_n \text{ i.i.d.}\sim Gumbel(0,1)$, whose PDF and CDF are defined as</p><p>$$\begin{align} f(x)&amp;=e^{-(x+e^{-x})} \\ F(x)&amp;=e^{-e^{-x}}\end{align}$$</p><p class="par">. Then $\mathbb{P}(Z=k)=\alpha_k$.</p><h2 id="proof">Proof</h2><p class="par">Set $u_k=\log{\alpha_k}+G_k$. We prove by direct calculations.</p><p>$$\begin{align} \mathbb{P}(Z=k)&amp;=\mathbb{P}(u_k \geq u_j,\forall j \neq k) \\ &amp;=\int_{-\infty}^\infty \mathbb{P}(u_k \geq u_j, \forall j \neq k|u_k)\mathbb{P}(u_k) du_k \\ &amp;=\int_{-\infty}^\infty \prod_{j\neq k}\mathbb{P}(u_k \geq u_j|u_k)\mathbb{P}(u_k) du_k \\ &amp;=\int_{-\infty}^\infty \prod_{j\neq k}e^{-e^{-u_k+\log \alpha_j}} e^{-(u_k-\log\alpha_k+e^{-(u_k-\log\alpha_k)})} du_k \\ &amp;=\int_{-\infty}^\infty e^{-\sum_{j\neq k}\alpha_je^{-u_k}} \alpha_k e^{-(u_k+\alpha_k e^{-u_k})} du_k \\ &amp;=\alpha_k \int_{-\infty}^\infty e^{-u_k-(\alpha_k+\sum_{j\neq k}\alpha_j)e^{-u_k}} du_k \\ &amp;= \alpha_k \end{align}$$.</p><h2 id="application">Application</h2><p class="par">The trick is commonly used in DL to make sampling over a discrete distribution differentiable.</p><h2 id="references-4">References</h2><ul><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gumbel_distribution">Gumbel Distribution - Wikipedia</a></li><li><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1611.01144.pdf">Categorical Reparameterization with Gumbel-Softmax (ICLR 2017)</a></li></ul></div><div lang="zh" class="post__readmore font__ui"><a href="/proof-of-gumbel-max-trick/">READ MORE</a></div></article><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/option-as_ref/">Option::as_ref</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2019-06-26 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="f9352571bd44ad92341db0a6cb40fe9b6e884ec413bbd7f20bc715499ef50c29" class="post__content font__body"><p>Let’s consider the following function:</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">use</span> std::ptr::NonNull;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">transform</span>&lt;T&gt;(option: &amp;<span class="hljs-type">Option</span>&lt;NonNull&lt;T&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;T&gt; {</span><br><span class="line">    option.<span class="hljs-title function_ invoke__">map</span>(|x| <span class="hljs-keyword">unsafe</span> { x.<span class="hljs-title function_ invoke__">as_ref</span>() })</span><br><span class="line">}</span><br></pre></div></div><p class="par">The function <code>transform</code> takes an <code>Option&lt;NonNull&lt;T&gt;&gt;</code> as input, and converts the inner pointer to an immutable reference <code>&amp;T</code> if possible. The method <code>NonNull::as_ref()</code> is marked unsafe so we need an <code>unsafe</code> block. The snippet causes an compilation error:</p></div><div lang="zh" class="post__readmore font__ui"><a href="/option-as_ref/">READ MORE</a></div></article><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/rc-refcell-pattern/">Rc, RefCell and Interior Mutability</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2019-06-23 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="3b38f64e54c37b317bb96270bbf448480acef3ac50f96691698392094393e792" class="post__content font__body noindent"><p>Say we need a type <code>Cursor&lt;T&gt;</code> , which holds a mutable reference to <code>T</code>. A method <code>.dup()</code> duplicates the internal reference, wraps it in a new instance of <code>Cursor&lt;T&gt;</code> and returns. Such pattern exists commonly in database driver library. Users could hold multiple cursors simultaneously, with each owning a (mutable) reference to the same connection object.</p><p>One might implements with a primitive mutable reference:</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cursor</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; {</span><br><span class="line">    obj: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; Cursor&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; {</span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T) <span class="hljs-punctuation">-&gt;</span> Cursor&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; {</span><br><span class="line">        Cursor { obj: t }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dup</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Cursor&lt;T&gt; {</span><br><span class="line">        Cursor { obj: <span class="hljs-keyword">self</span>.obj }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cursor_a</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> i);</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">_cursor_b</span> = cursor_a.<span class="hljs-title function_ invoke__">dup</span>();</span><br><span class="line">}</span><br></pre></div></div><p>Perfect and neat, and luckily Rust compiler did not complain. Fresh Rustanceans would have to work hard for shutting up the compiler, especially when fighting with references.</p><p>The invocation of <code>::new()</code> and <code>.dup()</code> are on separate lines. Now what about to chain up the constructor and <code>.dup()</code>? This time the compiler fails:</p></div><div lang="zh" class="post__readmore font__ui"><a href="/rc-refcell-pattern/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-state-monad/">Haskell 笔记：State Monad</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-12-15 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="6a15b3f2b4161f3ce1966213e85acaa84d4061935fb9d207e07091f5ea846ab4" class="post__content font__body"><p>一个依赖于外部状态 <code>s</code> 的伪函数 <code>f&#39; :: a -&gt; b</code>，我们可以将其改写为 <code>f :: a -&gt; s -&gt; (b, s)</code> 使其良定。即，在输入输出中显式传递状态 <code>s</code>。现在，我们需要利用 Monad 将状态传递过程隐藏起来。</p><p>注意到，输出值 <code>(b, s)</code> 中的末状态 <code>s</code> 不仅依赖于输入状态，更依赖于之前更改过状态的一系列函数及其逻辑。因此我们不能简单地将 Monad 定义为 <code>(a, s)</code> 类似的形式，否则两个函数用 <code>&gt;=&gt;</code> 结合的结果将与函数逻辑无关，这与我们的期望不符。</p><p>考虑如下定义：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">State</span> s a = { <span class="hljs-title">runState</span> :: <span class="hljs-title">s</span> -&gt; (<span class="hljs-title">a</span>, <span class="hljs-title">s</span>) }</span></span><br></pre></div></div><p class="par">由于 <code>-&gt;</code> 的右结合性，<code>f :: a -&gt; s -&gt; (b, s)</code> 和 <code>f :: a -&gt; State s b</code> 等价。固定 <code>s</code>，则 <code>State s</code> 可以成为一个 Monad。一个类型为 <code>State s a</code> 的值通常也被称为一个 state processor。</p><p>现在尝试定义 <code>(&gt;&gt;=) :: State s a -&gt; (a -&gt; State s b) -&gt; State s b</code>。若 <code>p &gt;&gt;= f</code>，则 <code>p</code> 蕴含了在此之前所有的状态处理逻辑，我们希望将 <code>p</code> 和 <code>f</code> 的逻辑融合在一起，成为一个新的 state processor，并作为返回值。</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">p</span> &gt;&gt;= f = </span><br><span class="line">    (</span><br><span class="line">        <span class="hljs-type">State</span> $ \s -&gt; (b, s&#x27;&#x27;)</span><br><span class="line">        <span class="hljs-keyword">where</span></span><br><span class="line">            (a, s&#x27;) = (runState p) s</span><br><span class="line">            p2 = f a <span class="hljs-comment">-- :: State s b</span></span><br><span class="line">            (b, s&#x27;&#x27;) = (runState p2) s&#x27;</span><br><span class="line">    )</span><br></pre></div></div><p class="par"><code>return</code> 是平凡的：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">return</span> a = <span class="hljs-type">State</span> $ (\s -&gt; (a, s))</span><br></pre></div></div><p class="par"><code>fmap</code> 可以作如下定义：</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">fmap</span> :: (a -&gt; b) -&gt; (<span class="hljs-type">State</span> s a) -&gt; (<span class="hljs-type">State</span> s b)</span><br><span class="line"><span class="hljs-title">fmap</span> f = </span><br><span class="line">    (</span><br><span class="line">        \pIn -&gt; (</span><br><span class="line">            \s -&gt; (b, s&#x27;)</span><br><span class="line">            <span class="hljs-keyword">where</span></span><br><span class="line">                (a, s&#x27;) = (runState pIn) s</span><br><span class="line">                b = f a</span><br><span class="line">        )</span><br></pre></div></div><p class="par">如此一来，我们可以将一系列的依赖外部状态的函数串成一个依赖外部状态的函数，传以初始状态，便可得到结果。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-state-monad/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-monad/">Haskell 笔记：Monad 引论</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-12-14 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="537b2cbde5b61b680103cbca69a47210a35ca2daf3600ebcbeeaa92efb8dac9b" class="post__content font__body noindent"><h2 id="动机">动机</h2><p>pure functions 看似完美，但却不能模拟现实世界中的诸多任务。这是由于 pure functions 是良定的映射，对于特定的输入值会返回唯一的输出。这种模式在面对如下任务时会显得苍白无力：</p><ul><li>有可能失败的任务。如大多数的 IO。</li><li>依赖外部状态的任务。如（伪）随机数生成器。</li><li>非确定性任务，即对于确定的输入可能有多个输出。这种在 IP 中较为少见。</li><li>对外界会造成影响的任务。如大多数的写入过程。</li></ul><p class="par">这些问题可以用数学中的<strong>域扩充技巧</strong>来解决。</p><h2 id="域扩充">域扩充</h2><p>在数学中，当定义问题的范畴不足以容纳问题的解时，我们通常会对相关的范畴进行扩充。类似的技巧同样也可以应用在这里。</p><p>假设一个不良定的函数 <code>f: A -&gt; B</code>：</p><ul><li>如果 <code>f</code> 有可能失败，我们可以将 <code>B</code> 扩充为 <code>Err(B) ∪ &#123; reasons of failures &#125;</code>，其中 <code>reasons of failures</code> 可能是对异常的描述，也可以是空值一类的东西。则 <code>f&#39;: A -&gt; Err(B)</code> 是良定的映射，且与 <code>f</code> 行为一致。事实上，这就是 Maybe Monad 和 Either Monad。</li><li>如果 <code>f</code> 依赖于外部状态，我们定义 <code>Pref(B)</code> 为 <strong>从外部状态空间到 B 的映射的全体</strong>，则 <code>f&#39;: A -&gt; Pref(B)</code> 为良定的映射，且行为和 <code>f</code> 一致。换言之，对于特定的输入 <code>a</code>，<code>f&#39;(a)</code> 返回一个函数，其中蕴含了已知 <code>a</code> 时如何从各种不同状态得到结果的逻辑。事实上，这就是 State Monad。</li><li>如果 <code>f</code> 具有非确定性，我们将 <code>B</code> 扩充为 <code>Power(B)</code>，即 <code>B</code> 的幂集。则 <code>f&#39;: A -&gt; Power(B)</code> 为良定的映射，且行为与 <code>f</code> 一致。事实上，这就是 List Monad。</li><li>如果 <code>f</code> 依赖于真实世界，我们将 <code>B</code> 扩充为 <code>IO(B)</code>，其中的元素为一些值域为 <code>B</code> 的<strong>伪函数</strong>，可能对真实世界有影响。这些伪函数已经脱离了 pure functions 的范畴，但将它们看成元素是没有问题的。如此一来 <code>f&#39;: A -&gt; IO(B)</code> 为良定的映射，且行为与 <code>f</code> 一致。事实上，这就是 IO Monad。</li></ul><p>以上操作都有一个共同点，即对一个不良定函数的值域做了扩充，使之变成良定函数。如果用 Haskell 语言描述，它们都有相似的型：<code>f :: a -&gt; m b</code>，其中 <code>m</code> 为扩充规则。</p><p>一个问题随之而来：这样的新函数该怎么结合？为此我们要对相关逻辑进行抽象。这就是 Monad。</p><h2 id="monad">Monad</h2><p>这里我们尝试从实际需求出发，导出一个 Type Constructor 成为 Monad 的必要条件。</p><p>约定两个名称：</p><ul><li>称 <code>a -&gt; m b</code> 型函数为 monadic function</li><li>称 <code>a -&gt; b</code> 型函数为 non-monadic function</li></ul><p>首先需要解决的是 monadic functions 如何结合的问题。这个问题具有重要的现实意义。monadic function 常常代表某种计算任务，它们之间的结合相当于把若干计算任务串行化，而后者是非常常见的需求。</p><p>我们希望有一种运算符有如下的类型 <code>(b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)</code>，在此记为 <code>&gt;=&gt;</code> （因其形状，常被叫做 fish operator）。一个自然的想法是，Monad <code>m</code> 需要某种平凡的拆箱操作 <code>extract&#39; :: m a -&gt; a</code>。所谓“平凡”，即 <code>extract&#39;</code> 不应该丢失参数的任何信息。但这往往不能实现，因为 <code>m a</code> 通常会比 <code>a</code> 包含更多的信息，导致 <code>extract&#39;</code> 无法构成良定的映射。例如 <code>Maybe a</code> 中的值 <code>Nothing</code> 就无法在 <code>a</code> 中找到对应的值。</p><p>而事实上，我们不需要条件这么强的拆箱操作。在 <code>m</code> 已是 Functor 的情况下，拆箱操作可以弱化为 <code>join :: m (m a) -&gt; m a</code>。我们尝试用 <code>fmap</code>、 <code>join</code> 合成 <code>&gt;=&gt;</code>。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">f</span> :: b -&gt; m c</span><br><span class="line"><span class="hljs-title">g</span> :: a -&gt; m b</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">fmap</span> f :: m b -&gt; m (m c)</span><br><span class="line">(fmap f) . g :: a -&gt; m (m c)</span><br><span class="line"><span class="hljs-title">join</span> . (fmap f) . g :: a -&gt; m c</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">-- i.e.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">f</span> &gt;=&gt; g = join . (fmap f) . g</span><br></pre></div></div><p>Functor 的假设是容易成立的。当然我们可以定义多个不同的 <code>fmap</code>，如此产生的 Monad 会有不同的语义。<code>join</code> 的假设也是容易成立的，<code>m (m a)</code> 通常和 <code>m a</code> 包含相同多的信息。故此做法是实际可行的。</p><p>我们再考虑 monadic function 和 non-monadic function 结合的问题。期望有如此一个运算：<code>&gt;.&gt; :: (b -&gt; c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)</code>。注意，此处返回值是 <code>a -&gt; m c</code> 而不是 <code>a -&gt; c</code>，因为我们不希望 <code>a -&gt; m b</code> 产生的额外信息有所丢失。自然地，我们希望有一个平凡的装箱操作，<code>return :: a -&gt; m a</code>。如此一来便可结合 <code>&gt;=&gt;</code> 完成上面的运算：</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">f</span> :: b -&gt; c</span><br><span class="line"><span class="hljs-title">g</span> :: a -&gt; m b</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">return</span> . f :: b -&gt; m c</span><br><span class="line">(return . f) &gt;=&gt; g :: a -&gt; m c</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">-- i.e.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">f</span> &gt;.&gt; g :: (return . f) &gt;=&gt; g</span><br></pre></div></div><p class="par">non-monadic function 和 monadic function 另一个方向的结合是平凡的。</p><p>综上我们可以得到成为 Monad 的基本条件：</p><ul><li>是 Functor，存在 <code>fmap :: (a -&gt; b) -&gt; m a -&gt; m b</code></li><li>有一个平凡的拆箱操作 <code>join :: m (m a) -&gt; m a</code></li><li>有一个平凡的装箱操作 <code>return :: a -&gt; m a</code></li></ul><p>为了描述平凡，我们要求三个函数必须满足如下公理（下面的 <code>f</code> 为 non-monadic function）：</p><ol><li><code>return . f == (fmap f) . return</code> （<code>return</code> 的平凡性）</li><li><code>join . fmap (fmap f) == (fmap f) . join</code> （<code>join</code> 的平凡性）</li></ol><blockquote><p>事实上在 Category Theory 中，还有另外两条公理：</p><ul><li><code>join . (fmap join) == join . join</code></li><li><code>join . fmap return == join . return == id</code></li></ul><p>以上四条公理描述了 <code>Id</code>（恒等 Functor）、<code>m</code>、<code>m^2</code>、<code>m^3</code> 之间的泛性质，并使图交换。</p></blockquote><h2 id="monad-typeclass">Monad Typeclass</h2><p>以下为 Prelude 中的定义：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> m =&gt; m a <span class="hljs-keyword">where</span></span></span><br><span class="line"></span><br><span class="line">    return :: a -&gt; m a</span><br><span class="line">    (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></div></div><p>此处没有出现 <code>join</code>，也没有 fish operator，而是使用了一个更常用的算符 <code>&gt;&gt;=</code> （通常称为 bind operator）。这是因为在实际中我们不直接将函数结合，而是使用 non-pointfree 的写法。</p><p>此外，还有 <code>&gt;&gt; :: m a -&gt; m b -&gt; m b</code> 运算符。<code>return</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;</code> 三者是构成 do-notation 的基础。此处不再赘述。</p><h2 id="references-2">References</h2><ul><li><a target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/Haskell/Category_theory">Haskell/Category Theory</a></li><li><a target="_blank" rel="noopener" href="https://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/">Why Do Monads Matter?</a></li></ul></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-monad/">READ MORE</a></div></article><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-applicative/">Haskell 笔记：Applicative</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2018-11-18 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="68187ada12eaa74a8a6ad75da7354a801a0adc68068719dbb4c4fe2d96e11fab" class="post__content font__body noindent"><h2 id="motivation">Motivation</h2><p><code>Functor</code> solves the problem of mapping regular single-parameter functions into a sub-category, but that’s not easy for functions with more than one parameter.</p><p>Let’s consider a function with two parameters <code>f :: a -&gt; b -&gt; c</code>, which can also read as <code>a -&gt; (b -&gt; c)</code>. Applying <code>fmap</code> on <code>f</code> will yield <code>fmap f :: m a -&gt; m (b -&gt; c)</code>. That’s still distant from what we expect: <code>f&#39; :: m a -&gt; m b -&gt; m c</code>. To get <code>f&#39;</code>, we need a transform from <code>m (b -&gt; c)</code> to <code>m b -&gt; m c</code>. Here we denote it as <code>&lt;*&gt; :: m （b -&gt; c) -&gt; m b -&gt; m c</code>. We will later show that such transform is universal for functions with more parameters.</p><p>Now consider a function with three parameters <code>f :: a -&gt; b -&gt; c -&gt; d</code>. We are going to transform it into a wrapped-value version, with the help of <code>fmap</code> and <code>&lt;*&gt;</code>.</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">f</span> :: a -&gt; b -&gt; c -&gt; d</span><br><span class="line"></span><br><span class="line">(fmap f) :: m a -&gt; m (b -&gt; (c -&gt; d))</span><br><span class="line"></span><br><span class="line">\a_ b_ -&gt; (fmap f a_) &lt;*&gt; b_</span><br><span class="line">    :: m a -&gt; m b -&gt; m (c -&gt; d)</span><br><span class="line"></span><br><span class="line">\a_ b_ c_ -&gt; ((fmap f a_) &lt;*&gt; b_) &lt;*&gt; c_</span><br><span class="line">    :: m a -&gt; m b -&gt; m c -&gt; (m d)</span><br></pre></div></div><p class="par">Here <code>\a_ b_ c_ -&gt; ((fmap f a_) &lt;*&gt; b_) &lt;*&gt; c_</code> is in the desired type. For most of the time, applying parameters directly is actually what we want, instead of the function itself, so the code could simply be written as <code>((fmap f a) &lt;*&gt; b) &lt;*&gt; c</code>, where <code>a</code>, <code>b</code> and <code>c</code> are wrapped values. Parenthesis could be omitted if precedences are set properly, which leads to a neat and easy-to-read form:</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">f</span> `fmap` a &lt;*&gt; b &lt;*&gt; c</span><br></pre></div></div><p class="par">In haskell, <code>fmap</code> has an infix name <code>&lt;$&gt;</code>. So finally we get: <code>f &lt;$&gt; a &lt;*&gt; b &lt;*&gt; c</code>.</p><h2 id="applicative">Applicative</h2><p>Haskell pre-defines a type class <code>Applicative</code>, which captures the pattern of <code>&lt;*&gt;</code>. Any type that implements <code>Applicative</code> works well with <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code>.</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> f =&gt; <span class="hljs-type">Applicative</span> (<span class="hljs-title">f</span> :: * -&gt; *) <span class="hljs-keyword">where</span></span></span><br><span class="line">  pure :: a -&gt; f a</span><br><span class="line">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">  <span class="hljs-type">GHC</span>.<span class="hljs-type">Base</span>.liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</span><br><span class="line">  (*&gt;) :: f a -&gt; f b -&gt; f b</span><br><span class="line">  (&lt;*) :: f a -&gt; f b -&gt; f a</span><br></pre></div></div><p class="par">Note that an <code>Applicative</code> is also a <code>Functor</code>. Apart from <code>&lt;*&gt;</code>, there are some other helper functions or operators in <code>Applicative</code>.</p><p><code>pure</code> is equivalent to the default value constructor of <code>f</code>, e.g. <code>(:[])</code> for <code>List</code> or <code>Just</code> for <code>Maybe</code>. This may be handful when lifting an unwrapped value to a wrapped one.</p><p><code>liftA2</code> transforms a binary operator to the corresponding version. The function exists as binary operators would be frequently passed among high-order functions.</p><p><code>*&gt;</code> takes two wrapped parameters and simply returns the second one, which sequence up two wrapped values. This is quite useful for <code>Applicative</code> with action semantics, such as <code>IO</code>. In fact, it’s so useful that Haskell introduces a syntax sugar for it, known as the <code>do-notation</code>. Particularly:</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">do</span></span><br><span class="line">    putStrLn <span class="hljs-string">&quot;1&quot;</span></span><br><span class="line">    putStrLn <span class="hljs-string">&quot;2&quot;</span></span><br></pre></div></div><p class="par">is equivalent to</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">putStrLn</span> <span class="hljs-string">&quot;1&quot;</span> *&gt; putStrLn <span class="hljs-string">&quot;2&quot;</span></span><br></pre></div></div><p class="par"><code>&lt;*</code> is similar. Both will be reviewed while studying Monad.</p></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-applicative/">READ MORE</a></div></article><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-category-theory-and-functor/">Haskell 笔记：Category Theory and Functor</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2018-11-18 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="30e6fe9f86787a349f7447182720b783e5cf2d22dc85544c23b6a3fecb11939f" class="post__content font__body noindent"><h2 id="category-theory">Category Theory</h2><p>A category consists of three parts:</p><ul><li>A collection of objects.</li><li>A collection of morphisms, each of which map one object to another.</li><li>A composition operator of these morphisms, i.e. morphisms can be composed. If <code>f: A -&gt; B</code> and <code>g: B -&gt; C</code> are morphisms, <code>f.g</code> generates a new morphism <code>A -&gt; C</code>.</li></ul><p class="par">Note that a morphism has no specific semantics of mapping, but simply links two objects together. Morphisms are also called <strong>Arrows</strong>.</p><h3 id="examples">Examples</h3><h4 id="set-category-set">Set Category: Set</h4><p>All sets and standard functions form a category. Functions need not to be surjective, since morphisms have no mapping semantics.</p><h4 id="group-category-grp">Group Category: Grp</h4><p>All groups and homomorphisms between groups form a category. A group has specific algebaric structure, which morphisms should preserve.</p><h3 id="laws">Laws</h3><p>Three laws that a category should obey:</p><ul><li>Composition should be associative.</li><li>Composition operation should be enclosed in the category, i.e. if <code>f: A -&gt; B</code> and <code>g: B -&gt; C</code>, there must be a <code>h: A -&gt; C</code> satisfying <code>h = f . g</code>.</li><li>For each object <code>A</code>, there should exist an identity morphism <code>id(A): A -&gt; A</code> s.t. for every <code>f: A -&gt; B</code>, <code>f = id(A) . f = f . id(B)</code>.</li></ul><p class="par">Note that:</p><ul><li>There may exist serveral morphisms between <code>A</code> and <code>B</code>.</li><li>An identity has type <code>A -&gt; A</code>, but a morphism with such type needs not to be an identity.</li></ul><h3 id="functors-in-category-theory">Functors in Category Theory</h3><p>A functor maps a category to another category. It should contains two mappings for objects and for morphisms, with composition operation and category laws preserved.</p><p>There’s a trivial functor from Grp to Set, which maps groups to their underlying sets, and group morphisms to functions with same behavior but defined on sets instead of groups.</p><h2 id="paramateric-types-in-haskell">Paramateric Types in Haskell</h2><p>It’s common to create new types that hold values of other types. <code>List[a]</code> type constructor creates types that holds sequential values of same type; <code>Maybe[a]</code> creates types that hold operation states (failure, or success with returned values).</p><p>Usually we expect derived types to inherit functions from types being wrapped. For example, <code>List[Int]</code> should have element-wise addition as <code>Int</code> does, and <code>Maybe[Int]</code> should have similar operations with no burden of re-wrapping and unwrapping. <strong>Such ‘inheritance’ should be done automatically if possible, since it is only concerned with the structure of types instead of specific functions.</strong></p><h2 id="hask-category">Hask Category</h2><p>Haskell language itself forms a category, with <strong>all types</strong> being objects, and functions being morphisms. Such category is called Hask.</p><h2 id="hask-functors">Hask Functors</h2><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> m <span class="hljs-keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; m a -&gt; m b</span><br></pre></div></div><p class="par">A parameteric type implementing class <code>Functor</code> is a category functor, mapping Hask to one of its sub-category, where types <code>m a</code> are the object collection. The type constructor <code>m</code> maps objects, and specific <code>fmap</code> defined on <code>m</code> maps corresponding functions.</p><p>It’s worth noted that <code>(a -&gt; b) -&gt; m a -&gt; m b</code> can also read as <code>(a -&gt; b) -&gt; (m a -&gt; m b)</code>, as <code>-&gt;</code> is right-associative. This may provide a clearer view of <code>fmap</code>, which takes a regular function in Hask and returns the corresponding function in sub-category.</p><p>Examples:</p><p><code>fmap (+) :: List[Int] -&gt; List[Int]</code> generates element-wise addition in <code>List[Int]</code>.</p><p class="par"><code>fmap (+) :: Maybe Int -&gt; Maybe Int</code> generates such function:</p><p class="noindent"></p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">maybePlus</span> :: <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span></span><br><span class="line"><span class="hljs-title">maybePlus</span> _        <span class="hljs-type">Nothing</span>  = <span class="hljs-type">Nothing</span></span><br><span class="line"><span class="hljs-title">maybePlus</span> <span class="hljs-type">Nothing</span>  _        = <span class="hljs-type">Nothing</span></span><br><span class="line"><span class="hljs-title">maybePlut</span> (<span class="hljs-type">Just</span> x) (<span class="hljs-type">Just</span> y) = <span class="hljs-type">Maybe</span> (x + y)</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-category-theory-and-functor/">READ MORE</a></div></article></div><div lang="zh" class="page-navigator font__ui"><span class="page__button"><a href="/categories/Tech/page/4/" class="pre">PREV</a></span><span class="page__button"><a href="/categories/Tech/page/6/" class="next">NEXT</a></span></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>