<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><title>Tech | hsfzxjy 的博客</title><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div class="post-list"><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-data-type-newtype/">Haskell 笔记：data, type, newtype</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-11-16 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="5e5abb7e66ed613bc75b7c17b952c2b029070d903208bd622a481c19025d3b8b" class="post__content font__body noindent"><p>新类型有自己的 data constructor（literals 可以看成特殊的 data constructor），由这一点来区分是否创建了新类型。</p><ul><li><code>data</code> 创建了新类型，可以有多个 data constructor。</li><li><code>newtype</code> 创建了新类型，只能有一个 data constructor，同时新类型的内存布局与原来的类型相同。</li><li><code>type</code> 没有创建新类型，只是建立了 alias，没有新的 data constructor。</li></ul><h2 id="type">type</h2><p>常用于语义化类型，是业务逻辑层的概念。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ID</span> = <span class="hljs-type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">a</span> = <span class="hljs-number">1</span> :: <span class="hljs-type">ID</span></span><br><span class="line"><span class="hljs-title">b</span> = a + <span class="hljs-number">2</span> <span class="hljs-comment">-- legal</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">showID</span> :: <span class="hljs-type">ID</span> -&gt; <span class="hljs-type">IO</span> ()</span><br><span class="line"><span class="hljs-title">showID</span> x = print x <span class="hljs-comment">-- legal, since Int has already been an instance of class Show</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">-- illegal, since Int has already been instantiated</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Show</span> <span class="hljs-type">ID</span> <span class="hljs-keyword">where</span></span></span><br><span class="line">    <span class="hljs-comment">-- ...</span></span><br></pre></div></div><h2 id="newtype">newtype</h2><p>在编译期创建新类型，但差异在运行期被抹去。带有一个构造器。</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">ID&#x27;</span> = <span class="hljs-type">ID&#x27;</span> <span class="hljs-type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">a</span> = <span class="hljs-type">ID&#x27;</span> <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-title">b</span> = a + <span class="hljs-number">2</span> <span class="hljs-comment">-- illegal, since Int and ID&#x27; are totally different types</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">showID&#x27;</span> :: <span class="hljs-type">ID&#x27;</span> -&gt; <span class="hljs-type">IO</span> ()</span><br><span class="line"><span class="hljs-title">showID&#x27;</span> x = print x <span class="hljs-comment">-- illegal, since ID&#x27; is not an instance of Show</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">-- either</span></span><br><span class="line"><span class="hljs-title">showID&#x27;</span> (<span class="hljs-type">ID&#x27;</span> x) = print x</span><br><span class="line"><span class="hljs-comment">-- or</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Show</span> <span class="hljs-type">ID&#x27;</span> <span class="hljs-keyword">where</span></span></span><br><span class="line">    show (<span class="hljs-type">ID&#x27;</span> x) = show x</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-data-type-newtype/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-fold/">Haskell 笔记：folds</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-11-10 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="85c1cc954e75087d4f4e7b89dcf43cf688e894b9ea979c5e7a2df31bdac64398" class="post__content font__body noindent"><h2 id="preludefoldl">Prelude.foldl</h2><p><code>foldl</code> 为 left-associative folding。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl</span> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="hljs-title">foldl</span> f acc [] = acc</span><br><span class="line"><span class="hljs-title">foldl</span> f acc (x:xs) = foldl f (f acc x) xs</span><br></pre></div></div><p class="par"><code>foldl (+) 0 [1..3]</code> 等价于 <code>(((0 + 1) + 2) + 3)</code>。</p><ul><li>尾递归，因此有 strict 版本 <code>foldl&#39;</code></li><li>求值时必须先到达栈底，遍历完列表，因此无法处理无穷列表</li></ul><h2 id="datalistfoldl">Data.List.foldl’</h2><p><code>foldl&#39;</code> 为 <code>foldl</code> 的 TRO 版本。</p><h2 id="preludefoldr">Prelude.foldr</h2><p><code>foldr</code> 为 right-associative folding。</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldr</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="hljs-title">foldr</span> f acc [] = acc</span><br><span class="line"><span class="hljs-title">foldr</span> f acc (x:xs) = f x (foldr f acc xs)</span><br></pre></div></div><p class="par"><code>foldr (+) 0 [1..3]</code> 等价于 <code>(0 + (1 + (2 + 3)))</code></p><ul><li>没有尾递归，有爆栈的危险。</li><li>有向右展开的特点，而 Haskell 中许多数据结构都有向右递归的特点（如 Cons），因此可以很好地处理无穷递归的数据，从而更加通用。</li></ul><h2 id="preludefoldl1--preludefoldr1">Prelude.foldl1 &amp;&amp; Prelude.foldr1</h2><p>Helper functions。将 operator 限制为同一种类型，同时约去 accumulator。</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl1</span> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</span><br><span class="line"><span class="hljs-title">foldl1</span> f (x:xs) = foldl f x xs</span><br><span class="line"><span class="hljs-title">foldl1</span> _ [] = error</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">foldr1</span> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</span><br><span class="line"><span class="hljs-title">foldr1</span> f (x:xs) = foldr f x xs</span><br><span class="line"><span class="hljs-title">foldr1</span> _ [] = error</span><br></pre></div></div><p class="par">即，<code>foldr1</code> 将列表的第一个值作为 accumulator，将剩余部分作为 list，传给 <code>foldr</code>。<code>foldl</code> 同理。</p><h2 id="实践">实践</h2><h3 id="用-folds-实现-reverse">用 folds 实现 <code>reverse</code></h3><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">reversel</span>, reverser :: [a] -&gt; [a]</span><br><span class="line"><span class="hljs-title">reversel</span> list = foldl (\acc x -&gt; x : acc) [] list</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">reverser</span> list = foldr (\x acc -&gt; acc ++ [x]) [] list</span><br></pre></div></div><h3 id="用-foldr-实现-foldl">用 foldr 实现 foldl</h3><p>先归纳出 <code>foldr</code> 的泛性质。如果一个函数 <code>g</code> s.t.</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">g</span> [] = v</span><br><span class="line"><span class="hljs-title">g</span> (x:xs) = f x (g xs)</span><br></pre></div></div><p class="par">则 <code>g list === foldr f v list</code>.</p><p>再看 <code>foldl</code> 的定义：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl</span> f v [] = v</span><br><span class="line"><span class="hljs-title">foldl</span> f v (x:xs) = foldl f (f v x) xs</span><br><span class="line"></span><br><span class="line">===&gt;</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">foldl</span> f v list = g list v</span><br><span class="line">    <span class="hljs-keyword">where</span></span><br><span class="line">        g [] v = v</span><br><span class="line">        g (x:xs) v = g xs (f v x)</span><br><span class="line">        <span class="hljs-comment">-- 从左到右依次更新 v</span></span><br><span class="line"></span><br><span class="line">===&gt;</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">foldl</span> f v list = g list v</span><br><span class="line">    <span class="hljs-keyword">where</span></span><br><span class="line">        g [] = id</span><br><span class="line">        g (x:xs) = \v -&gt; g xs (f v x)</span><br></pre></div></div><p class="par">应有 <code>g (x:xs) === k x (g xs)</code>，我们计算 <code>k</code>：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">g</span> (x:xs)       === k x (g xs)</span><br><span class="line"><span class="hljs-title">g</span> (x:xs) v     === k x (g xs) v</span><br><span class="line"><span class="hljs-title">g</span> xs (f v x)   === k x (g xs) v</span><br><span class="line">(g xs) (f v x) === k x (g xs) v</span><br><span class="line"><span class="hljs-title">g&#x27;</span> (f v x)     === k x g&#x27; v</span><br><span class="line"><span class="hljs-title">k</span>              === \x g&#x27; v -&gt; g&#x27; (f v x)</span><br></pre></div></div><p class="par">所以</p><div class="gk-code hljs" data-gk-id="BLOCK8"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl</span> f v xs =</span><br><span class="line">    (foldr</span><br><span class="line">        (\x g&#x27; v -&gt; g&#x27; (f v x))</span><br><span class="line">        id</span><br><span class="line">        xs</span><br><span class="line">    ) v</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-fold/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/python-gil-and-threads/">从伪并行的 Python 多线程说起</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-03-10 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="992b305387932c90bb5758e418d5ca8ff16320adc853d7dd4d35440c20edf3b6" class="post__content font__body noindent"><h2 id="写在前面-7">写在前面</h2><ul><li>作者电脑 CPU 为 4 核，因此使用 4 个线程测试是合理的</li><li>本文使用的 <code>cpython</code> 版本为 <code>3.6.4</code></li><li>本文使用的 <code>pypy</code> 版本为 <code>5.9.0-beta0</code>，兼容 Python 3.5 语法</li><li>本文使用的 <code>jython</code> 版本为 <code>2.7.0</code>，兼容 Python 2.7 语法</li><li>若无特殊说明，作语言解时，<code>python</code> 指 Python 语言；作解释器解时，<code>python</code> 指 <code>cpython</code></li></ul></div><div lang="zh" class="post__readmore font__ui"><a href="/python-gil-and-threads/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/caveats-for-signal-handler-in-python/">一个 Reentrant Error 引发的对 Python 信号机制的探索和思考</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2017-08-17 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="a9c9a79948df76fb6d5f5dbd58139f2567b56e6819570413788f4863a8db5cf8" class="post__content font__body noindent"><h2 id="写在前面-5">写在前面</h2><p>前几天工作时遇到了一个匪夷所思的问题。经过几次尝试后问题得以解决，但问题产生的原因却仍令人费解。查找 SO 无果，我决定翻看 Python 的源码。断断续续地研究了几天，终于恍然大悟。撰此文以记。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/caveats-for-signal-handler-in-python/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/linux-file-permissions/">Linux 文件权限</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2017-07-03 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="24fc576ed77be4d8f7865ed343bebae2bbfce9cbf2aa63184447ca513fefc457" class="post__content font__body noindent"><h1 id="概念">概念</h1><p>Linux 中的每一个文件都有其 <strong>所属用户</strong> 及 <strong>所属用户组</strong>，根据这两个属性可将文件访问者分为三类：<strong>所属用户自己</strong>、<strong>所属用户组中的用户</strong> 和 <strong>其他用户</strong>，我们可以针对不同的访问者设置不同的用户权限。</p><p>“访问”可分为三类：<strong>读</strong>、<strong>写</strong> 与 <strong>执行</strong>。我们可以用 <code>ls -l</code> 命令查看一个文件的权限：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">touch</span> <span class="hljs-built_in">test</span></span><br><span class="line">$ <span class="hljs-built_in">ls</span> -l <span class="hljs-built_in">test</span></span><br><span class="line">-rw-rw-r-- 1 hsfzxjy hsfzxjy 0 Jul  3 23:44 <span class="hljs-built_in">test</span></span><br></pre></div></div><p class="par">首部的 <code>-rw-rw-r--</code> 即为文件的权限位。权限应该分为四部分来看：<code>-/rw-/rw-/r--</code>。第一部分标志文件的类型，如 普通文件（<code>-</code>）、目录（<code>d</code>）、UNIX 套接字（<code>s</code>）、符号链接（<code>l</code>）、块设备（<code>b</code>）等等。接下来的三个部分依次代表 <strong>所属用户</strong>、<strong>所属用户组</strong>、<strong>其他用户</strong> 的权限，每部分由三个标志位组成：<strong>读标志位</strong>、<strong>写标志位</strong>、<strong>执行标志位</strong>。</p><h1 id="目录的权限">目录的权限</h1><p>目录是一种特殊的文件，因此也拥有文件权限的概念，但权限的语义与普通文件稍有差异：</p><ul><li>读：读取目录下文件列表，相关命令如 <code>ls</code></li><li>写：创建、删除目录下的文件，相关命令如 <code>touch</code>（当文件不存在时）、<code>rm</code> 等</li><li>执行：进入目录，相关命令如 <code>cd</code></li></ul><h1 id="特殊权限">特殊权限</h1><p>出于某些特殊目的，Linux 中存在两个特殊的权限位：粘滞位（<code>t</code>）、Set Id（<code>s</code>）。这两个权限可以 <strong>叠加</strong> 在执行权限位上，其中 Set Id 可以置于 <strong>所属用户</strong> 和 <strong>所属用户组</strong> 的权限组上，而 粘滞位 只能置于 <strong>其他用户</strong> 权限组上。当特殊权限被设置时，执行权限位上即会显示 <code>s/t</code> （已有 <code>x</code> 权限）或 <code>S/T</code> （尚未有 <code>x</code> 权限）。</p><h2 id="粘滞位">粘滞位</h2><p>粘滞位的作用是 <strong>防止他人误删自己的文件</strong>。当某个目录的其他用户权限组有 <code>w</code> 权限时，系统中的其他用户即可随意删除目录中的文件。而一旦叠加上 <code>t</code> 权限，只有文件的所有者方能删除文件。一个经典的例子是 <code>/tmp</code>：</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">ls</span> -l /</span><br><span class="line">drwxrwxrwt  13 root root 12288 Jul  4 00:15 tmp/</span><br></pre></div></div><h2 id="set-id">Set Id</h2><p>Linux 中的进程也有自己所属用户与用户组。一般而言，进程的所属用户即为其发起者，但这会引起一些麻烦。一个例子是 <code>passwd</code> 命令，该命令需要修改属于 <code>root</code> 用户的系统文件以保存密码，倘若进程所属用户即为所属者，此功能则无法实现。</p><p>Set Id 权限的作用是：在文件被执行时，将其有效用户/用户组设置为文件的用户/用户组，而不是当前执行者。下面是一个演示：</p><p>设当前用户为 <code>hsfzxjy</code>，我们在 <code>/tmp</code> 下创建一个 <code>test</code> 文件，并删去其他用户的 <code>r</code> 权限：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">cd</span> /tmp</span><br><span class="line">$ <span class="hljs-built_in">echo</span> <span class="hljs-built_in">test</span> text &gt; <span class="hljs-built_in">test</span></span><br><span class="line">$ <span class="hljs-built_in">chmod</span> o-r <span class="hljs-built_in">test</span></span><br><span class="line">$ ll <span class="hljs-built_in">test</span></span><br><span class="line">-rw-rw---- 1 hsfzxjy hsfzxjy 0 Jul  4 00:28 <span class="hljs-built_in">test</span></span><br></pre></div></div><p class="par">由于 <code>test</code> 文件的所属用户是 <code>hsfzxjy</code>，其他用户没有权限读取其中的内容：</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line">$ sudo -u mysql <span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span></span><br><span class="line"><span class="hljs-built_in">cat</span>: <span class="hljs-built_in">test</span>: Permission denied</span><br></pre></div></div><p class="par">现在我们修改一下 <code>cat</code> 命令的权限，为了不影响系统文件，我们拷贝一份 <code>cat</code> 副本至当前目录：</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">cp</span> /bin/cat .</span><br><span class="line">$ <span class="hljs-built_in">chmod</span> u+s <span class="hljs-built_in">cat</span></span><br><span class="line">$ ll <span class="hljs-built_in">cat</span></span><br><span class="line">-rwsr-xr-x 1 hsfzxjy hsfzxjy 52080 Jul  4 00:34 <span class="hljs-built_in">cat</span>*</span><br></pre></div></div><p class="par">再以 <code>mysql</code> 的身份执行命令：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line">$ sudo -u mysql ./cat <span class="hljs-built_in">test</span></span><br><span class="line"><span class="hljs-built_in">test</span> text</span><br></pre></div></div><p class="par">可见 <code>./cat</code> 在执行时所属用户是 <code>hsfzxjy</code>。我们可以使用 <code>ps</code> 命令更清楚地看到这点：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line">$ sudo -u mysql <span class="hljs-built_in">cat</span></span><br><span class="line"><span class="hljs-comment"># 在另一个终端中</span></span><br><span class="line">$ ps -eo euser,ruser,<span class="hljs-built_in">comm</span> | grep <span class="hljs-built_in">cat</span></span><br><span class="line">mysql    mysql    <span class="hljs-built_in">cat</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -----------</span></span><br><span class="line"></span><br><span class="line">$ sudo -u mysql ./cat</span><br><span class="line"><span class="hljs-comment"># 在另一个终端中</span></span><br><span class="line">$ ps -eo euser,ruser,<span class="hljs-built_in">comm</span> | grep <span class="hljs-built_in">cat</span></span><br><span class="line">hsfzxjy  mysql    <span class="hljs-built_in">cat</span></span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/linux-file-permissions/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/HSFZMUN-4.0-configuration/">HSFZMUN 4.0 部署小记</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2017-02-25 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="6bc9dac75b60f8c50025ec857da1106ba093a8cb99336ac380bdce50416ed054" class="post__content font__body noindent"><blockquote><p>技术流水账一篇，记录踩过的坑</p></blockquote><h2 id="channels-异构-1">Channels 异构</h2><p>Django Channels 官方文档宣称 channels 的最佳配置是使用其自带的服务器组件 Daphne，但在开发中我发现 daphne 处理普通请求比在 WSGI 架构下慢了好几倍，更何况使用 daphne 派发静态文件是十分不切实际的。于是我将 <code>http.request</code> 和 <code>websocket.*</code> 两个 channel 解耦，前者使用 nginx 配合 uwsgi 处理，后者使用 nginx 反向代理至 daphne 处理。这样一来便可充分利用两种架构的优势。</p><p><strong>旧架构：</strong></p><p><img loading="lazy" src="/assets/django-channels-configuration/old-arch.png" alt=""></p><p><strong>新架构：</strong></p><p><img loading="lazy" src="/assets/django-channels-configuration/new-arch.png" alt=""></p></div><div lang="zh" class="post__readmore font__ui"><a href="/HSFZMUN-4.0-configuration/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/uncover-the-secret-of-fast-inverse-square-root-algorithm/">揭秘·变态的平方根倒数算法</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-08-03 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="4beeb2727e641d28d36b99057bf1a0a2e83ff8c06ee3e538b41e2388cba39143" class="post__content font__body noindent"><blockquote><p>神的时代已离去 神的故事却化为传说 流落凡间 供凡人传颂、膜拜</p></blockquote><h2 id="这是什么-1">这是什么</h2><p>在上世纪 90 年代，出现过一款不可思议的游戏——雷神之锤（Quake series）。除了优秀的情节设定和精美的画面，最让人称道的莫过于它的运行效率——要知道在那个计算机配置低下的时代，一段小动画都是一个奇迹，但 Quake 却能流畅地运行于各种配置的电脑上。</p><p>直至 2005 年，当 Quake Engine 开源时，Quake 系列的秘密才被揭开。在代码库中，人们发现了许多堪称神来之笔的算法。它们以极其变态的高效率，压榨着计算机的性能，进而才支撑起了 90 年代 3D 游戏的传奇。其中的某些算法，甚至比系统原生的实现还要快！</p><p>我们今天的主角——快速平方根倒数算法（Fast Inverse Square Root）就是其中一个。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/uncover-the-secret-of-fast-inverse-square-root-algorithm/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/recursively-calling-when-decorating-a-python-class/">神坑·Python 装饰类无限递归</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-07-30 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="e90efe4b28286f6a54ae00756688cef183df7bb91dd54f10e4ec212427095f24" class="post__content font__body noindent"><blockquote><p>《神坑》系列将会不定期更新一些可遇而不可求的坑 防止他人入坑，也防止自己再次入坑</p></blockquote><h2 id="简化版问题">简化版问题</h2><p>现有两个 <code>View</code> 类：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-comment"># Do something...</span></span><br><span class="line">        <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildView</span>(<span class="hljs-title class_ inherited__">View</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-comment"># Do something else ...</span></span><br><span class="line">        <span class="hljs-built_in">super</span>(ChildView, self).method()</span><br></pre></div></div><p>以及一个用于修饰该类的装饰器函数 <code>register</code>——用于装饰类的装饰器很常见（如 <code>django.contrib.admin</code> 的 <code>register</code>），通常可极大地减少定义相似类时的工作量：</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mixin</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">cls</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(</span><br><span class="line">        <span class="hljs-string">&#x27;DecoratedView&#x27;</span>,</span><br><span class="line">        (Mixin, cls),</span><br><span class="line">        {}</span><br><span class="line">    )</span><br></pre></div></div><p>这个装饰器为被装饰类附加上一个额外的父类 <code>Mixin</code>，以增添自定义的功能。</p><p>完整的代码如下：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mixin</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">cls</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(</span><br><span class="line">        cls.__name__,</span><br><span class="line">        (Mixin, cls),</span><br><span class="line">        {}</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-comment"># Do something...</span></span><br><span class="line">        <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@register</span></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildView</span>(<span class="hljs-title class_ inherited__">View</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-comment"># Do something else ...</span></span><br><span class="line">        <span class="hljs-built_in">super</span>(ChildView, self).method()</span><br></pre></div></div><p>看上去似乎没什么问题。然而一旦调用 <code>View().method()</code>，却会报出诡异的 无限递归 错误：</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-comment"># ...</span></span><br><span class="line">File <span class="hljs-string">&quot;test.py&quot;</span>, line <span class="hljs-number">23</span>, <span class="hljs-keyword">in</span> method</span><br><span class="line">  <span class="hljs-built_in">super</span>(ChildView, self).method()</span><br><span class="line">File <span class="hljs-string">&quot;test.py&quot;</span>, line <span class="hljs-number">23</span>, <span class="hljs-keyword">in</span> method</span><br><span class="line">  <span class="hljs-built_in">super</span>(ChildView, self).method()</span><br><span class="line">File <span class="hljs-string">&quot;test.py&quot;</span>, line <span class="hljs-number">23</span>, <span class="hljs-keyword">in</span> method</span><br><span class="line">  <span class="hljs-built_in">super</span>(ChildView, self).method()</span><br><span class="line">RuntimeError: maximum recursion depth exceeded <span class="hljs-keyword">while</span> calling a Python <span class="hljs-built_in">object</span></span><br></pre></div></div><p>【一脸懵逼】</p><h2 id="猜想--验证">猜想 &amp; 验证</h2><p>从 Traceback 中可以发现：是 <code>super(ChildView, self).method()</code> 在不停地调用自己——这着实让我吃了一惊，因为 <strong>按理说 <code>super</code> 应该沿着继承链查找父类</strong>，可为什么在这里 <code>super</code> 神秘地失效了呢？</p><p>为了验证 <code>super(...).method</code> 的指向，可以尝试将该语句改为 <code>print(super(ChildView, self).method)</code>，并观察结果：</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line">&lt;bound method ChildView.method of &lt;__main__.ChildView <span class="hljs-built_in">object</span> at <span class="hljs-number">0xb70fec6c</span>&gt;&gt;</span><br></pre></div></div><p>输出表明： <strong><code>method</code> 的指向确实有误</strong>，此处本应为 <code>View.method</code>。</p><p><code>super</code> 是 python 内置方法，肯定不会出错。那，会不会是 <code>super</code> 的参数有误呢？</p><p><code>super</code> 的签名为 <code>super(cls, instance)</code>，宏观效果为 <strong>遍历 <code>cls</code> 的继承链查找父类方法，并以 <code>instance</code> 作为 <code>self</code> 进行调用</strong>。如今查找结果有误，说明 <strong>继承链是错误的</strong>，因而极有可能是 <code>cls</code> 出错。</p><p>因此，有必要探测一下 <code>ChildView</code> 的指向。在 <code>method</code> 中加上一句： <code>print(ChildView)</code>：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line">&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.DecoratedView&#x27;</span>&gt;</span><br></pre></div></div><p>原来，作用域中的 <code>ChildView</code> 已经被改变了。</p><h2 id="真相">真相</h2><p>一切都源于装饰器语法糖。我们回忆一下装饰器的等价语法：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line"><span class="hljs-meta">@decorator</span></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span>:</span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br></pre></div></div><p>等价于</p><div class="gk-code hljs" data-gk-id="BLOCK8"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span>:</span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line">Class = decorator(Class)</span><br></pre></div></div><p>这说明：<strong>装饰器会更改该作用域内被装饰名称的指向</strong>。</p><p>这本来没什么，但和 <code>super</code> 一起使用时却会出问题。通常情况下我们会将本类的名称传给 <code>super</code>（在这里为 <code>ChildView</code>），而本类名称和装饰器语法存在于同一作用域中，从而在装饰时被一同修改了（在本例中指向了子类 <code>DecoratedView</code>），进而使 <code>super(...).method</code> 指向了 <code>DecoratedView</code> 的最近祖先也就是 <code>ChildView</code> 自身的 <code>method</code> 方法，导致递归调用。</p><h2 id="解决方案">解决方案</h2><p>找到了病因，就不难想到解决方法了。核心思路就是：<strong>不要更改被装饰名称的引用</strong>。</p><p>如果你只是想在内部使用装饰后的新类，可以在装饰器方法中使用 <code>DecoratedView</code>，而在装饰器返回时 <code>return cls</code>，以保持引用不变：</p><div class="gk-code hljs" data-gk-id="BLOCK9"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">cls</span>):</span><br><span class="line"></span><br><span class="line">    decorated = <span class="hljs-built_in">type</span>(</span><br><span class="line">        <span class="hljs-string">&#x27;DecoratedView&#x27;</span>,</span><br><span class="line">        (Mixin, cls),</span><br><span class="line">        {}</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># Do something with decorated</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> cls</span><br></pre></div></div><p>这种方法的缺点是：从外部无法使用 <code>ChildView.another_method</code> 调用 <code>Mixin</code> 上的方法。可如果真的有这样的需求，可以采用另一个解决方案：</p><div class="gk-code hljs" data-gk-id="BLOCK10"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">cls</span>):</span><br><span class="line"></span><br><span class="line">    cls.another_method = Mixin.another_method</span><br><span class="line">    <span class="hljs-keyword">return</span> cls</span><br></pre></div></div><p>即通过赋值的方式为 <code>cls</code> 添加 <code>Mixin</code> 上的新方法，缺点是较为繁琐。</p><p>两种方法各有利弊，要根据实际场景权衡使用。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/recursively-calling-when-decorating-a-python-class/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/python-encoding-and-decoding/">Python“黑魔法”之 Encoding &amp; Decoding</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-07-21 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="151c383b4228a9a284d0f025a8bd6040be3559a0a3f370fb64c61fe8f11d33ad" class="post__content font__body noindent"><h2 id="写在前面-3">写在前面</h2><blockquote><ul><li>本文为科普文</li><li>本文中的例子在 Ubuntu 14.04 / Python 2.7.11 下运行成功，Python 3+ 的接口有些许不同，需要读者自行转换</li></ul></blockquote><h2 id="引子-4">引子</h2><p>先看一段代码：</p><p><code>example.py</code>：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"># -*- conding=yi -*-</span><br><span class="line"></span><br><span class="line">从 math 导入 sin, pi</span><br><span class="line"></span><br><span class="line">打印 &#x27;sin(pi) =&#x27;, sin(pi)</span><br></pre></div></div><p>这是什么？！是 Python 吗？可以运行吗？——想必你会问。</p><p>我可以明确告诉你：这不是 Python，<strong>但它可以用 Python 解释器运行</strong>。当然，如果你愿意，可以叫它“Yython” （易语言 + Python）。</p><p><img loading="lazy" src="//sf.gg/img/bVzuHw" alt=""></p><p>怎么做到的？也许你已经注意到第一行的奇怪注释——没错，秘密全在这里。</p><p>这种黑魔法，还要从 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0263/">PEP 263</a> 说起。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/python-encoding-and-decoding/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/python-generator-coroutine/">Python“黑魔法”之 Generator Coroutines</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-04-02 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="827734dab0d26b6be6c4a7f510d58190898036968bd09ec6036ea7f282cc0950" class="post__content font__body"><h2 id="写在前面-1">写在前面</h2><blockquote><ul><li>本文默认读者对 Python 生成器 有一定的了解，不了解者请移步至<a target="_blank" rel="noopener" href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000">生成器 - 廖雪峰的官方网站</a>。</li><li>本文基于 Python 3.5.1，文中所有的例子都可在 <a target="_blank" rel="noopener" href="https://github.com/hsfzxjy/python-generator-coroutine-examples">Github</a> 上获得。</li></ul></blockquote><p>学过 Python 的都知道，Python 里有一个很厉害的概念叫做 生成器（Generators）。一个生成器就像是一个微小的线程，可以随处暂停，也可以随时恢复执行，还可以和代码块外部进行数据交换。恰当使用生成器，可以极大地简化代码逻辑。</p><p>也许，你可以熟练地使用生成器完成一些看似不可能的任务，如“无穷斐波那契数列”，并引以为豪，认为所谓的生成器也不过如此——那我可要告诉你：这些都太小儿科了，下面我所要介绍的绝对会让你大开眼界。</p><p><strong>生成器 可以实现 协程，你相信吗？</strong></p></div><div lang="zh" class="post__readmore font__ui"><a href="/python-generator-coroutine/">READ MORE</a></div></article></div><div lang="zh" class="page-navigator font__ui"><span class="page__button"><a href="/categories/Tech/page/5/" class="pre">PREV</a></span><span class="page__button"><a href="/categories/Tech/page/7/" class="next">NEXT</a></span></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>