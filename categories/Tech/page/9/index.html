<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><title>Tech | hsfzxjy 的博客</title><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div class="post-list"><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/uva12219-common-subexpression-elimination/">UVa12219 Common Subexpression Elimination</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2014-10-05 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="de3ff9b8e5b98f19753b61bb1e206e9089533772b9ea4f511b9025f865266391" class="post__content font__body"><blockquote><p class="noindent">链接：<a target="_blank" rel="noopener" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3371">Link</a> 状态：<strong>Runtime Error</strong></p></blockquote><h2 id="前言-2">前言</h2><p>这题做的可真够久的，整整三个小时。但即便如此，还是只过了一部分的点，另一部分报运行时错误——估计是哈希表设计的不太好。但这确实是一道好题，因此，在睡觉前决定记录一下。</p><h2 id="分析">分析</h2><p>很容易便想到：用一个三元组 $(x,y,z)$ 表示节点，表示内容为 x 的节点下跟着标号为 y 和 z 的左右子树。这样一来，一类相同的子树便可以唯一确定了，而不必每构造一棵子树就把整棵树遍历一遍。 对于三元组的储存，刚开始图方便，用了数组。查找也是用了 $O(n)$ 的线性查找。磕磕碰碰写了两个多小时然后兴冲冲地提交，结果 TLE 了…………没办法，只好又花了半个小时写了一个哈希表，然后就是上文说过的情况了：<strong>Runtime Error204</strong>。可能是哈希数组过大的原因，日后再微调一下，今天实在是没有脑子了。</p><h2 id="code-2">Code</h2><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">const</span></span><br><span class="line">  maxn = <span class="hljs-number">20000</span>;</span><br><span class="line"><span class="hljs-keyword">type</span></span><br><span class="line">  NodeRec = <span class="hljs-keyword">record</span></span><br><span class="line">    Value: <span class="hljs-keyword">string</span>;</span><br><span class="line">    l, r, <span class="hljs-keyword">index</span>: longint;</span><br><span class="line">  <span class="hljs-keyword">end</span>;</span><br><span class="line">  Node = <span class="hljs-keyword">record</span></span><br><span class="line">      left, right: longint;   <span class="hljs-comment">//Index of left and right child in the `tree` array, -1 for none.</span></span><br><span class="line">      Rec: NodeRec;</span><br><span class="line">      <span class="hljs-keyword">index</span>: longint;</span><br><span class="line">  <span class="hljs-keyword">end</span>;</span><br><span class="line">  <span class="hljs-comment">//以下为哈希表的定义</span></span><br><span class="line">  _PNode = ^_Node;</span><br><span class="line">  _Node = <span class="hljs-keyword">record</span></span><br><span class="line">    n: Node;</span><br><span class="line">    next: _PNode;</span><br><span class="line">  <span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line">  HashTable = <span class="hljs-keyword">object</span></span><br><span class="line">    arr: <span class="hljs-keyword">array</span> [<span class="hljs-number">0</span>..maxn] <span class="hljs-keyword">of</span> _PNode;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span><span class="hljs-params">(n: NodeRec)</span>:</span> longint;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">add</span><span class="hljs-params">(n: Node)</span>;</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">clear</span>;</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span><span class="hljs-params">(n: NodeRec)</span>:</span> longint;</span><br><span class="line">  <span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">HashTable</span>.<span class="hljs-title">clear</span>;</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">  i: longint;</span><br><span class="line">  p, q: _PNode;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> maxn <span class="hljs-keyword">do</span></span><br><span class="line">  <span class="hljs-keyword">begin</span></span><br><span class="line">    p := arr[i];</span><br><span class="line">    <span class="hljs-keyword">while</span> p&lt;&gt;<span class="hljs-keyword">nil</span> <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">      q := p^.next;</span><br><span class="line">      dispose(p);</span><br><span class="line">      p := q;</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">  <span class="hljs-keyword">end</span>;</span><br><span class="line">  fillchar(arr, sizeof(arr),<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cmp</span><span class="hljs-params">(r1, r2: NodeRec)</span>:</span> Boolean;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">  cmp := (r1.l = r2.l) <span class="hljs-keyword">and</span> (r1.r = r2.r) <span class="hljs-keyword">and</span> (r1.Value = r2.Value);</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HashTable</span>.<span class="hljs-title">hash</span><span class="hljs-params">(n: NodeRec)</span>:</span> longint;</span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">  i: longint;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">  hash := <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> length(n.Value) <span class="hljs-keyword">do</span></span><br><span class="line">    hash := (hash*<span class="hljs-number">5</span> + ord(n.Value[i]) - ord(<span class="hljs-string">&#x27;a&#x27;</span>)) <span class="hljs-keyword">mod</span> maxn;</span><br><span class="line">  hash := (hash + n.l * <span class="hljs-number">10</span> + n.r * <span class="hljs-number">5</span>) <span class="hljs-keyword">mod</span> maxn;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">HashTable</span>.<span class="hljs-title">add</span><span class="hljs-params">(n: Node)</span>;</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">  h: longint;</span><br><span class="line">  p, q: _PNode;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">  h := hash(n.rec);</span><br><span class="line">  new(q);</span><br><span class="line">  fillchar(q^, sizeof(_Node), <span class="hljs-number">0</span>);</span><br><span class="line">  q^.next := arr[h];</span><br><span class="line">  q^.n := n;</span><br><span class="line">  arr[h] := q;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HashTable</span>.<span class="hljs-title">find</span><span class="hljs-params">(n: NodeRec)</span>:</span> longint;</span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">  p: _PNode;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">  find := -<span class="hljs-number">1</span>;</span><br><span class="line">  p := arr[hash(n)];</span><br><span class="line">  <span class="hljs-keyword">while</span> (p&lt;&gt;<span class="hljs-keyword">nil</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> cmp(n, p^.n.rec) <span class="hljs-keyword">do</span> p := p^.next;</span><br><span class="line">  <span class="hljs-keyword">if</span> p &lt;&gt; <span class="hljs-keyword">nil</span> <span class="hljs-keyword">then</span></span><br><span class="line">    find := p^.n.<span class="hljs-keyword">index</span>;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-comment">//哈系表定义结束</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">  inputs: Ansistring;</span><br><span class="line">  _: longint;</span><br><span class="line">  tree: <span class="hljs-keyword">array</span> [<span class="hljs-number">1</span>..<span class="hljs-number">50001</span>] <span class="hljs-keyword">of</span> Node;</span><br><span class="line">  cur: longint;              <span class="hljs-comment">//The current pointer of the input string.</span></span><br><span class="line">  num: longint;              <span class="hljs-comment">//The current number of the `tree` array.</span></span><br><span class="line">  ls: longint;</span><br><span class="line">  t: longint;</span><br><span class="line">  tot: longint;</span><br><span class="line">  ht: HashTable;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">build</span>:</span> longint; <span class="hljs-comment">//建树</span></span><br><span class="line"><span class="hljs-keyword">label</span> lb;</span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">  rec: NodeRec;</span><br><span class="line">  i,j,l,r: longint;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">  l := <span class="hljs-number">0</span>;</span><br><span class="line">  r := <span class="hljs-number">0</span>;</span><br><span class="line">  fillchar(rec, sizeof(rec), <span class="hljs-number">0</span>);</span><br><span class="line">  inc(tot);</span><br><span class="line">  rec.<span class="hljs-keyword">index</span> := tot;</span><br><span class="line">  <span class="hljs-keyword">while</span> (cur&lt;=ls) <span class="hljs-keyword">and</span> (inputs[cur] <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;z&#x27;</span>]) <span class="hljs-keyword">do</span></span><br><span class="line">  <span class="hljs-keyword">begin</span></span><br><span class="line">    rec.Value := rec.Value+inputs[cur];</span><br><span class="line">    inc(cur);</span><br><span class="line">  <span class="hljs-keyword">end</span>;</span><br><span class="line">  <span class="hljs-keyword">if</span> cur&gt;ls <span class="hljs-keyword">then</span> <span class="hljs-keyword">goto</span> lb;    <span class="hljs-comment">//。。。这里被迫跳转控制流，由于实在不想多谢，就用了臭名昭著的label</span></span><br><span class="line">  <span class="hljs-keyword">if</span> inputs[cur] = <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">then</span></span><br><span class="line">  <span class="hljs-keyword">begin</span></span><br><span class="line">    inc(cur);</span><br><span class="line">    l := build();</span><br><span class="line">    rec.l := tree[l].rec.<span class="hljs-keyword">index</span>;</span><br><span class="line">    inc(cur);</span><br><span class="line">    r := build();</span><br><span class="line">    rec.r := tree[r].rec.<span class="hljs-keyword">index</span>;</span><br><span class="line">    inc(cur);</span><br><span class="line">  <span class="hljs-keyword">end</span>;</span><br><span class="line">  j := ht.find(rec);</span><br><span class="line">  <span class="hljs-keyword">if</span> j&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">then</span></span><br><span class="line">  <span class="hljs-keyword">begin</span></span><br><span class="line">    dec(tot);</span><br><span class="line">    <span class="hljs-keyword">exit</span>(j);</span><br><span class="line">  <span class="hljs-keyword">end</span></span><br><span class="line">  <span class="hljs-keyword">else</span></span><br><span class="line">  <span class="hljs-keyword">begin</span></span><br><span class="line">lb:</span><br><span class="line">    inc(num);</span><br><span class="line">    tree[num].left := l;</span><br><span class="line">    tree[num].right := r;</span><br><span class="line">    tree[num].rec := rec;</span><br><span class="line">    tree[num].<span class="hljs-keyword">index</span> := num;</span><br><span class="line">    ht.add(tree[num]);</span><br><span class="line">    <span class="hljs-keyword">exit</span>(num);</span><br><span class="line">  <span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">print</span><span class="hljs-params">(n: longint)</span>;</span></span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">  <span class="hljs-keyword">if</span> tree[n].rec.<span class="hljs-keyword">index</span> &gt; t <span class="hljs-keyword">then</span></span><br><span class="line">  <span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">write</span>(tree[n].rec.Value);</span><br><span class="line">    t := tree[n].rec.<span class="hljs-keyword">index</span>;</span><br><span class="line">  <span class="hljs-keyword">end</span></span><br><span class="line">  <span class="hljs-keyword">else</span></span><br><span class="line">  <span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">write</span>(tree[n].rec.<span class="hljs-keyword">index</span>);</span><br><span class="line">    <span class="hljs-keyword">exit</span>;</span><br><span class="line">  <span class="hljs-keyword">end</span>;</span><br><span class="line">  <span class="hljs-keyword">if</span> tree[n].right = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span></span><br><span class="line">    <span class="hljs-keyword">exit</span>;</span><br><span class="line">  <span class="hljs-keyword">write</span>(<span class="hljs-string">&#x27;(&#x27;</span>);</span><br><span class="line">  print(tree[n].left);</span><br><span class="line">  <span class="hljs-keyword">write</span>(<span class="hljs-string">&#x27;,&#x27;</span>);</span><br><span class="line">  print(tree[n].right);</span><br><span class="line">  <span class="hljs-keyword">write</span>(<span class="hljs-string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">  assign(input, <span class="hljs-string">&#x27;main.in&#x27;</span>); reset(input);</span><br><span class="line">  assign(output, <span class="hljs-string">&#x27;main.out&#x27;</span>); rewrite(output);</span><br><span class="line">  readln(_);</span><br><span class="line">  fillchar(ht.arr, sizeof(ht.arr),<span class="hljs-number">0</span>);</span><br><span class="line">  <span class="hljs-keyword">while</span> _&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">do</span></span><br><span class="line">  <span class="hljs-keyword">begin</span></span><br><span class="line">    dec(_);</span><br><span class="line">    readln(inputs);</span><br><span class="line">    fillchar(tree, sizeof(tree), <span class="hljs-number">0</span>);</span><br><span class="line">    ht.clear;</span><br><span class="line">    ls := length(inputs);</span><br><span class="line">    cur := <span class="hljs-number">1</span>;  num := <span class="hljs-number">0</span>; tot := <span class="hljs-number">0</span>;</span><br><span class="line">    build;</span><br><span class="line">    t := <span class="hljs-number">0</span>;</span><br><span class="line">    print(num);</span><br><span class="line">    writeln;</span><br><span class="line">  <span class="hljs-keyword">end</span>;</span><br><span class="line">  close(input); close(output);</span><br><span class="line"><span class="hljs-keyword">end</span>.</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/uva12219-common-subexpression-elimination/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/uva536-recovery/">UVa536 Recovery</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2014-10-05 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="d810681cda91d4f8b83c1d414995abe9a226f4b7488e599161f7440e86b9db53" class="post__content font__body"><blockquote><p class="noindent">链接：<a target="_blank" rel="noopener" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=7&page=show_problem&problem=477">Link</a> 耗时：0.012s</p></blockquote><h2 id="前言-1">前言</h2><p>真是疯玩了几天，脑袋都残了，一道弱智题做了近一个小时。</p><h2 id="code-1">Code</h2><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    pre, mid, s: <span class="hljs-keyword">string</span>;</span><br><span class="line">    tree: <span class="hljs-keyword">array</span> [<span class="hljs-number">1</span>..<span class="hljs-number">50</span>] <span class="hljs-keyword">of</span> <span class="hljs-keyword">record</span></span><br><span class="line">        l, r: integer;</span><br><span class="line">        ch: char;</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    cur: integer;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>:</span> integer;</span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    m: integer;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    readln(s);</span><br><span class="line">    m := length(s) &gt;&gt; <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;</span><br><span class="line">    pre := Copy(s, <span class="hljs-number">1</span>, m-<span class="hljs-number">1</span>);</span><br><span class="line">    mid := Copy(s, m+<span class="hljs-number">1</span>, length(s));</span><br><span class="line">    init := m-<span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">build</span><span class="hljs-params">(l1, l2, r2: integer)</span>:</span> integer;</span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    m,len: integer;</span><br><span class="line">    t: integer;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> l2 &gt; r2 <span class="hljs-keyword">then</span> <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//该子树不存在。**这个地方坑了我很久**</span></span><br><span class="line">    inc(cur);</span><br><span class="line">    t := cur;      <span class="hljs-comment">// 这里也坑了我，当下面构造完左右子树后，cur已经变了，所以要缓存起来</span></span><br><span class="line">    build := t;</span><br><span class="line">    tree[t].ch := pre[l1];</span><br><span class="line">    <span class="hljs-keyword">if</span> r2-l2 = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">//叶节点</span></span><br><span class="line">        <span class="hljs-keyword">exit</span>;</span><br><span class="line">    m := pos(pre[l1], mid); <span class="hljs-comment">//在中序遍历中找根节点</span></span><br><span class="line">    len := m - l2;</span><br><span class="line">    tree[t].l := build(l1+<span class="hljs-number">1</span>, l2, m-<span class="hljs-number">1</span>); <span class="hljs-comment">//构造左子树</span></span><br><span class="line">    tree[t].r := build(l1+len+<span class="hljs-number">1</span>, m+<span class="hljs-number">1</span>, r2); <span class="hljs-comment">//构造右子树</span></span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">print</span><span class="hljs-params">(x: integer)</span>;</span></span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> x = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">exit</span>;</span><br><span class="line">    print(tree[x].l);</span><br><span class="line">    print(tree[x].r);</span><br><span class="line">    <span class="hljs-keyword">write</span>(tree[x].ch);</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    assign(input, <span class="hljs-string">&#x27;main.in&#x27;</span>); reset(input);</span><br><span class="line">    assign(output, <span class="hljs-string">&#x27;main.out&#x27;</span>); rewrite(output);</span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> eof <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        fillchar(tree, sizeof(tree), <span class="hljs-number">0</span>);</span><br><span class="line">        cur := <span class="hljs-number">0</span>;</span><br><span class="line">        build(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, init);</span><br><span class="line">        print(<span class="hljs-number">1</span>);</span><br><span class="line">        writeln;</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    close(input);</span><br><span class="line">    close(output);</span><br><span class="line"><span class="hljs-keyword">end</span>.</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/uva536-recovery/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/uva11582-colossal-fibonacci-numbers/">UVa11582 Colossal Fibonacci Numbers! &amp;&amp; 大数操作</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2014-10-01 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="558ba872e084795752353e775605fbcdd375657ad3019ee92e4037d63d400200" class="post__content font__body"><blockquote><p class="noindent">链接：<a target="_blank" rel="noopener" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=27&problem=2629&mosmsg=Submission%20received%20with%20ID%2014290914">Link</a> 耗时：0.139s</p></blockquote><h2 id="前言">前言</h2><p>这道题的主要思路就是打表，看看 Fibonacci 数列模 n 几个一循环。但由于这题给的数太大了，从而在细节上耗了很久。在此记录一下：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    x: qword;</span><br><span class="line">    y: longint;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    x := <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">64</span>-<span class="hljs-number">1</span>;</span><br><span class="line">    y := <span class="hljs-number">100</span>;</span><br><span class="line">    x := x <span class="hljs-keyword">mod</span> y; <span class="hljs-comment">//报错201</span></span><br><span class="line">    x := x <span class="hljs-keyword">mod</span> qword(y); <span class="hljs-comment">//正确</span></span><br><span class="line"><span class="hljs-keyword">end</span>.</span><br></pre></div></div><h2 id="code">Code</h2><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    a,b: qword;</span><br><span class="line">    _, n, i, k, cnt: longint;</span><br><span class="line">    f: <span class="hljs-keyword">array</span> [<span class="hljs-number">1</span>..<span class="hljs-number">1000000</span>] <span class="hljs-keyword">of</span> longint;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">superMod</span><span class="hljs-params">(a, b: qword; m: longint)</span>:</span> longint;</span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    x: qword;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> b = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span></span><br><span class="line">        <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);</span><br><span class="line">    x := superMod(a, b <span class="hljs-keyword">shr</span> <span class="hljs-number">1</span>, m);</span><br><span class="line">    superMod := x * x <span class="hljs-keyword">mod</span> m;</span><br><span class="line">    <span class="hljs-keyword">if</span> odd(b) <span class="hljs-keyword">then</span></span><br><span class="line">        superMod := superMod * a <span class="hljs-keyword">mod</span> m;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    assign(input, <span class="hljs-string">&#x27;main.in&#x27;</span>); reset(input);</span><br><span class="line">    assign(output, <span class="hljs-string">&#x27;main.out&#x27;</span>); rewrite(output);</span><br><span class="line">    readln(_);</span><br><span class="line">    <span class="hljs-keyword">while</span> _ &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        dec(_);</span><br><span class="line">        readln(a, b, n);</span><br><span class="line">        <span class="hljs-keyword">if</span> a = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span></span><br><span class="line">        <span class="hljs-keyword">begin</span></span><br><span class="line">            writeln(<span class="hljs-number">0</span>);</span><br><span class="line">            <span class="hljs-keyword">continue</span>;</span><br><span class="line">        <span class="hljs-keyword">end</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> n = <span class="hljs-number">1</span> <span class="hljs-keyword">then</span></span><br><span class="line">        <span class="hljs-keyword">begin</span></span><br><span class="line">            writeln(<span class="hljs-number">0</span>);</span><br><span class="line">            <span class="hljs-keyword">continue</span>;</span><br><span class="line">        <span class="hljs-keyword">end</span>;</span><br><span class="line">        f[<span class="hljs-number">1</span>] := <span class="hljs-number">1</span>;</span><br><span class="line">        f[<span class="hljs-number">2</span>] := <span class="hljs-number">1</span>;</span><br><span class="line">        cnt := <span class="hljs-number">2</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> ((f[cnt-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> (f[cnt] = <span class="hljs-number">0</span>)) <span class="hljs-keyword">do</span></span><br><span class="line">        <span class="hljs-keyword">begin</span></span><br><span class="line">            inc(cnt);</span><br><span class="line">            f[cnt] := (f[cnt-<span class="hljs-number">1</span>] + f[cnt-<span class="hljs-number">2</span>]) <span class="hljs-keyword">mod</span> n;</span><br><span class="line">        <span class="hljs-keyword">end</span>;</span><br><span class="line">        <span class="hljs-comment">//while x &gt; int64(1 &lt;&lt;60) do</span></span><br><span class="line">        <span class="hljs-comment">//    x := x - int64((cnt &lt;&lt; 59));</span></span><br><span class="line">        a := a <span class="hljs-keyword">mod</span> qword(cnt);</span><br><span class="line">        k := superMod(a, b, cnt);</span><br><span class="line">        writeln(f[k]);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    close(output); close(input);</span><br><span class="line"><span class="hljs-keyword">end</span>.</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/uva11582-colossal-fibonacci-numbers/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/extended-gcd-algorithm/">扩展欧几里得算法</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2014-10-01 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="52dcf719e2703e3d48a098d0a4f146485493caacfcedfadbf20abac202929f6b" class="post__content font__body"><blockquote><p class="noindent">今天开始学习数论方面的算法。这部分在 NOIP 中并不常出现，即使出现了也不会像高联这么难（。。。）。</p></blockquote><h2 id="什么是扩展欧几里得算法">什么是扩展欧几里得算法</h2><p>所谓欧几里得算法，实际上就是辗转相除法——求两个数最大公约数的一种高效算法。而扩展欧几里得算法则是来源于于一类方程的解决：</p><p>$$ax+by=gcd(a,b)$$</p><p class="nomargin">这有点像是<strong>裴蜀定理</strong>的一般形式。和裴蜀定理类似，这类方程也有无数多个整数解。如何高效率地求得它的一组特解呢？</p><h2 id="代码">代码</h2><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">gcd_ex</span><span class="hljs-params">(a, b: longint; <span class="hljs-keyword">var</span> d: longint; <span class="hljs-keyword">var</span> x, y: longint)</span>;</span></span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> b = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        d := a;</span><br><span class="line">        x := <span class="hljs-number">1</span>;</span><br><span class="line">        y := <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">exit</span>;</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    <span class="hljs-comment">// hl:begin #1</span></span><br><span class="line">    gcd_ex(b, a <span class="hljs-keyword">mod</span> b, d, y, x);</span><br><span class="line">    <span class="hljs-comment">// hl:end</span></span><br><span class="line">    y := y-(a <span class="hljs-keyword">div</span> b) * x;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br></pre></div></div><h2 id="详解">详解</h2><p>乍一看，算法似乎和一般欧几里得算法很是相似：都是递归实现，参数传递过程中都体现了“辗转相除”的思想。那为什么这个算法是正确的呢？ 这里先解释一下参数：</p><ul><li>a：方程中的参数 a</li><li>b：方程中的参数 b</li><li>d：即 <code>gcd(a,b)</code>。由于和辗转相除法的相似性，在这里最大公约数也可以“顺便”算出。当然，去掉也无大碍</li><li>(x,y)：方程的一组特解 (x, y)</li></ul><p>下面解释标注了 <code class="_hl-label">1</code> 的那行代码。</p><p class="nomargin">假设方程 $ax+by=gcd(a,b)$ 有一组特解 $(x_0,y_0)$。则有$$ax_0+by_0=gcd(a,b)$$</p><p class="par">由最大公约数原理可知：$$gcd(a,b)=gcd(b, a\ mod\ b)$$</p><p class="par">从而有$$ax_0+by_0=gcd(b,a\ mod\ b)$$</p><p class="par">又方程 $bx+(a\ mod\ b)y=gcd(b,a\ mod\ b)$ 一定有整数解，设其为 $(x_1,y_1)$。则有</p><p>$$ax_0+by_0=gcd(b,a\ mod\ b)=bx_1+(a\ mod\ b)y_1$$即$$ax_0+by_0=bx_1+(a-(a\ div\ b)*b)y_1$$</p><p class="par">即 $$a(x_0-y_1)=b(x_1-(a\ div\ b)y_1-y_0)$$</p><p class="par">由恒等原理可知：$$x_0=y_1$$$$y_0=x_1-(a\ div\ b)y_1$$</p><p class="par">因此，当 $a,b\neq0$ 时，$x,y$ 的值可以递归求得。递归边界为：$b=0$ 时 $x=1,y=0$。</p><p>注意到上面的算法用到了一个技巧：在递归传参数的时候将 y, x 调换了。这样做的好处是节省了一个中间变量用来储存 $y_1$，否则在计算 $y_0$ 时 $y_1$ 也被覆盖了。从而使算法更加的精简。</p><h2 id="应用"><strong>应用</strong></h2><ul><li>计算几何中求整点的问题</li><li>求一元一次同余方程 $a\equiv b\pmod{m}$ 的一组特解。（即方程 $ax+my=b$ 的一组特解）</li></ul></div><div lang="zh" class="post__readmore font__ui"><a href="/extended-gcd-algorithm/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/uva10285-cake-slicing/">UVa10285 Cake Slicing</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2014-10-01 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="873d44f7cc26cdf098f419b3fcaa9430099cfb2628a5f17fa6d5ccd404460384" class="post__content font__body"><blockquote><p class="noindent">链接：<a target="_blank" rel="noopener" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=825&page=show_problem&problem=4504">Link</a> 耗时：1.825s</p></blockquote><p>这道题做的可真够久的：前前后后加起来将近有两个小时，因此当 AC 的那一刻，自己心中还是挺自豪的。</p><p>事实上，这是一道复杂一点的区间型动态规划，之所以说“复杂”，是因为它的状态转移是<strong>二维</strong>的：切蛋糕既可以横切，也可以纵切。由此我想到了分治算法：</p><blockquote><p class="noindent">假设一个矩形它所需要切的刀数是 f，则 f 可以由组成该矩形的小矩形的 f 值决定。</p></blockquote><p class="par">因此，这个问题具有最优子结构。由于每个状态为一个矩形，因此需要 4 个维度来记录状态（及左上、右下两个顶点）。下面是横切时的状态转移方程，纵切时同理可得：</p><p>$$ \begin{aligned} f(up, down, left, right) = &amp;\ min\{f(up, i, left, right) \\ &amp; + f(i, down, left, right) + right - left\},i = up + 1 .. down -1 \end{aligned} $$</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-meta">{$R-}</span></span><br><span class="line"><span class="hljs-keyword">const</span> INF = maxint <span class="hljs-keyword">div</span> <span class="hljs-number">5</span>; <span class="hljs-comment">//正无穷</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    f: <span class="hljs-keyword">array</span> [<span class="hljs-number">0</span>..<span class="hljs-number">20</span>, <span class="hljs-number">0</span>..<span class="hljs-number">20</span>, <span class="hljs-number">0</span>..<span class="hljs-number">20</span>, <span class="hljs-number">0</span>..<span class="hljs-number">20</span>] <span class="hljs-keyword">of</span> integer;</span><br><span class="line">    cherries: <span class="hljs-keyword">array</span> [<span class="hljs-number">1</span>..<span class="hljs-number">500</span>, <span class="hljs-number">1</span>..<span class="hljs-number">2</span>] <span class="hljs-keyword">of</span> integer;</span><br><span class="line">    map: <span class="hljs-keyword">array</span> [<span class="hljs-number">0</span>..<span class="hljs-number">20</span>, <span class="hljs-number">0</span>..<span class="hljs-number">20</span>] <span class="hljs-keyword">of</span> boolean;</span><br><span class="line">    n, m, i, k: integer;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">min</span><span class="hljs-params">(x, y: integer)</span>:</span> integer; <span class="hljs-keyword">inline</span>;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> x&lt;y <span class="hljs-keyword">then</span> <span class="hljs-keyword">exit</span>(x) <span class="hljs-keyword">else</span> <span class="hljs-keyword">exit</span>(y);</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cherryin</span><span class="hljs-params">(u, d, l, r: integer)</span>:</span> integer; <span class="hljs-keyword">inline</span>; <span class="hljs-comment">//判断矩形内有没有樱桃</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    i, j: integer;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    cherryin := <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> i := u+<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> d <span class="hljs-keyword">do</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j := l+<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> r <span class="hljs-keyword">do</span></span><br><span class="line">            <span class="hljs-keyword">if</span> map[i, j] <span class="hljs-keyword">then</span></span><br><span class="line">            <span class="hljs-keyword">begin</span></span><br><span class="line">                inc(cherryin);</span><br><span class="line">                <span class="hljs-keyword">if</span> cherryin = <span class="hljs-number">2</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">exit</span>;</span><br><span class="line">            <span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dp</span><span class="hljs-params">(u, d, l, r: integer)</span>:</span> integer;</span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    b: integer;</span><br><span class="line">    i: integer;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> f[u, d, l, r] &lt;&gt; -<span class="hljs-number">1</span> <span class="hljs-keyword">then</span></span><br><span class="line">        <span class="hljs-keyword">exit</span>(f[u,d , l, r]);</span><br><span class="line">    b := cherryin(u, d, l, r);</span><br><span class="line">    <span class="hljs-keyword">if</span> b = <span class="hljs-number">1</span> <span class="hljs-keyword">then</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        f[u, d, l, r] := <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> b = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        f[u, d, l, r] := INF;</span><br><span class="line">        <span class="hljs-keyword">exit</span>(INF);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    dp := INF;</span><br><span class="line">    <span class="hljs-keyword">for</span> i := u+<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> d-<span class="hljs-number">1</span> <span class="hljs-keyword">do</span></span><br><span class="line">        dp := min(dp, dp(u, i, l, r)+dp(i, d, l, r)+r-l);</span><br><span class="line">    <span class="hljs-keyword">for</span> i := l+<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> r-<span class="hljs-number">1</span> <span class="hljs-keyword">do</span></span><br><span class="line">        dp := min(dp, dp(u, d, l, i)+dp(u, d, i, r)+d-u);</span><br><span class="line">    f[u, d, l, r] := dp;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    _: integer;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    assign(input, <span class="hljs-string">&#x27;main.in&#x27;</span>);reset(input);</span><br><span class="line">    assign(output, <span class="hljs-string">&#x27;main.out&#x27;</span>);rewrite(output);</span><br><span class="line">    _ := <span class="hljs-number">0</span>;</span><br><span class="line">    readln(n, m, k);</span><br><span class="line">    <span class="hljs-keyword">while</span> n&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        inc(_);</span><br><span class="line">        fillchar(map, sizeof(map), <span class="hljs-number">0</span>);</span><br><span class="line">        fillchar(f, sizeof(f), -<span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> k <span class="hljs-keyword">do</span></span><br><span class="line">        <span class="hljs-keyword">begin</span></span><br><span class="line">            readln(cherries[i, <span class="hljs-number">1</span>], cherries[i, <span class="hljs-number">2</span>]);</span><br><span class="line">            map[cherries[i, <span class="hljs-number">1</span>], cherries[i, <span class="hljs-number">2</span>]] := true;</span><br><span class="line">        <span class="hljs-keyword">end</span>;</span><br><span class="line">        writeln(<span class="hljs-string">&#x27;Case &#x27;</span>,_,<span class="hljs-string">&#x27;: &#x27;</span>, dp(<span class="hljs-number">0</span>,n,<span class="hljs-number">0</span>,m));</span><br><span class="line">        readln(n, m, k);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="hljs-keyword">end</span>.</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/uva10285-cake-slicing/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/uva10285-longest-run-on-a-snowboard/">UVa10285 Longest Run on a Snowboard</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2014-09-29 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="4326be0f06a7e5167614300da524558eb2dfbfd387ee329781bce73b82827416" class="post__content font__body"><blockquote><p class="noindent">链接：<a target="_blank" rel="noopener" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=14&amp;problem=1226&amp;mosmsg=Submission%20received%20with%20ID%2014282250">Link</a> 耗时：0.028s</p></blockquote><p>一道简单的动态规划，主要思路就是：<strong>用 $f[i,j]$ 表示到达 $(i,j)$ 的最长路径的长度。</strong>找到每个最高点，从其开始向四周的低处搜索。如果该点已搜过并且 f 值大于当前长度则退出回溯。直到达到某个最低点为止。</p><p>不多说了，直接上代码：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">const</span></span><br><span class="line">    delta :<span class="hljs-keyword">array</span> [<span class="hljs-number">1</span>..<span class="hljs-number">4</span>, <span class="hljs-number">1</span>..<span class="hljs-number">2</span>] <span class="hljs-keyword">of</span> integer = ((-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)); <span class="hljs-comment">//四个方向向量</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    _: Integer;</span><br><span class="line">    <span class="hljs-keyword">name</span>: <span class="hljs-keyword">string</span>;</span><br><span class="line">    n, m, i, j, x: Integer;</span><br><span class="line">    ans: longint;</span><br><span class="line">    map: <span class="hljs-keyword">array</span> [<span class="hljs-number">0</span>..<span class="hljs-number">101</span>, <span class="hljs-number">0</span>..<span class="hljs-number">101</span>] <span class="hljs-keyword">of</span> integer;</span><br><span class="line">    f: <span class="hljs-keyword">array</span> [<span class="hljs-number">1</span>..<span class="hljs-number">100</span>, <span class="hljs-number">1</span>..<span class="hljs-number">100</span>] <span class="hljs-keyword">of</span> longint;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y: longint)</span>:</span> longint; <span class="hljs-keyword">inline</span>;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> x&gt;y <span class="hljs-keyword">then</span> <span class="hljs-keyword">exit</span>(x) <span class="hljs-keyword">else</span> <span class="hljs-keyword">exit</span>(y);</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">can</span><span class="hljs-params">(x, y: integer)</span>:</span> Boolean; <span class="hljs-keyword">inline</span>; <span class="hljs-comment">//判断是否是最高点</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    i: Integer;</span><br><span class="line">    tx, ty: integer;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    can := true;</span><br><span class="line">    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-number">4</span> <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        tx := x + delta[i, <span class="hljs-number">1</span>];</span><br><span class="line">        ty := y + delta[i, <span class="hljs-number">2</span>];</span><br><span class="line">        can := can <span class="hljs-keyword">and</span> (map[x, y] &gt;= map[tx, ty]);</span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> can <span class="hljs-keyword">then</span> <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">dp</span><span class="hljs-params">(x, y: integer; len: longint)</span>;</span> <span class="hljs-comment">//回溯进行动态规划</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    i: Integer;</span><br><span class="line">    tx, ty: integer;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    inc(len);</span><br><span class="line">    <span class="hljs-keyword">if</span> f[x, y] &gt; len <span class="hljs-keyword">then</span> <span class="hljs-keyword">exit</span>;</span><br><span class="line">    f[x, y] := len;</span><br><span class="line">    ans := max(ans, len);</span><br><span class="line">    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-number">4</span> <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        tx := delta[i, <span class="hljs-number">1</span>] + x;</span><br><span class="line">        ty := delta[i, <span class="hljs-number">2</span>] + y;</span><br><span class="line">        <span class="hljs-keyword">if</span> (tx = <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (tx &gt; n) <span class="hljs-keyword">or</span> (ty = <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (ty &gt; m) <span class="hljs-keyword">then</span> <span class="hljs-keyword">continue</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> map[x, y] &lt;= map[tx, ty] <span class="hljs-keyword">then</span> <span class="hljs-keyword">continue</span>;</span><br><span class="line">        dp(tx, ty, len);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">ReadAndProcessName</span>;</span> <span class="hljs-comment">//处理那行该死的名字！！</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    s: <span class="hljs-keyword">string</span>;</span><br><span class="line">    i: integer;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    readln(s);</span><br><span class="line">    i := <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">name</span> := <span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="line">    n := <span class="hljs-number">0</span>;</span><br><span class="line">    m := <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> s[i] &lt;&gt; <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        <span class="hljs-keyword">name</span> := <span class="hljs-keyword">name</span> + s[i];</span><br><span class="line">        inc(i);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    inc(i);</span><br><span class="line">    <span class="hljs-keyword">while</span> s[i] &lt;&gt; <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        n := n * <span class="hljs-number">10</span> + ord(s[i]) - ord(<span class="hljs-string">&#x27;0&#x27;</span>);</span><br><span class="line">        inc(i);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    inc(i);</span><br><span class="line">    <span class="hljs-keyword">while</span> i &lt;= length(s) <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        m := m * <span class="hljs-number">10</span> + ord(s[i]) - ord(<span class="hljs-string">&#x27;0&#x27;</span>);</span><br><span class="line">        inc(i);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    assign(input, <span class="hljs-string">&#x27;main.in&#x27;</span>);reset(input);</span><br><span class="line">    assign(output, <span class="hljs-string">&#x27;main.out&#x27;</span>);rewrite(output);</span><br><span class="line">    readln(_);</span><br><span class="line">    <span class="hljs-keyword">while</span> _&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        dec(_);</span><br><span class="line">        fillchar(map, sizeof(map), <span class="hljs-number">0</span>);</span><br><span class="line">        ReadAndProcessName;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span></span><br><span class="line">            <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> m <span class="hljs-keyword">do</span></span><br><span class="line">            <span class="hljs-keyword">begin</span></span><br><span class="line">                <span class="hljs-keyword">read</span>(x);</span><br><span class="line">                map[i, j] := x+<span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">end</span>;</span><br><span class="line">        readln;</span><br><span class="line"></span><br><span class="line">        fillchar(f, sizeof(f), <span class="hljs-number">0</span>);</span><br><span class="line">        ans := <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span></span><br><span class="line">            <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> m <span class="hljs-keyword">do</span></span><br><span class="line">                <span class="hljs-keyword">if</span> can(i, j) <span class="hljs-keyword">then</span></span><br><span class="line">                    dp(i, j, <span class="hljs-number">0</span>);</span><br><span class="line">        writeln(<span class="hljs-keyword">name</span>, <span class="hljs-string">&#x27;: &#x27;</span>, ans);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="hljs-keyword">end</span>.</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/uva10285-longest-run-on-a-snowboard/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/uva12186-another-crisis-dynamic-arrays-in-pascal/">UVa12186 Another Crisis &amp;&amp; [Dynamic Arrays in Pascal]</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2014-09-27 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="23854e2ac94632f225d1197789c2ce271f949be5466a8d286e832229d61ec1a9" class="post__content font__body"><blockquote><p class="noindent">链接：<a target="_blank" rel="noopener" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=243&page=show_problem&problem=3338">Link</a> 耗时：0.586s</p></blockquote><p>昨晚做的太急了，没时间写总结，正好下午有空，补上。</p><p>这是一道典型的树形动态规划，不是很难，但十分坑语言。思路大致如下：</p><p>对于第 $i$ 个节点，用 $d(i)$ 表示其上诉所需的最小工人数。若 $i$ 为叶节点，则 $d(i)=1$；否则，遍历求出 $i$ 的子节点所对应的 $d$ 值，并由小到大排序，取出最小的几个相加，即为 $d(i)$。</p><p>很容易想到用递归来实现。但对于“子节点的 d 值的排序”实现起来却十分困难：因为事先不知道有多少个数。当然啦，如果是 C++ 组，用 <code>vector</code> 可以轻松搞定，可至于 P 党，实现起来却难上加难。思来想去，决定试试 Pascal 的动态数组。磕磕碰碰调了近 1 个小时，终于 AC 了。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-comment">//Accepted</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    tree: <span class="hljs-keyword">array</span> [<span class="hljs-number">0</span>..<span class="hljs-number">100000</span>] <span class="hljs-keyword">of</span> <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> int64;</span><br><span class="line">    T: Integer;</span><br><span class="line">    f: <span class="hljs-keyword">array</span> [<span class="hljs-number">0</span>..<span class="hljs-number">100000</span>] <span class="hljs-keyword">of</span> int64;</span><br><span class="line">    i,l,n,x:longint;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">min</span><span class="hljs-params">(x,y: int64)</span>:</span> int64;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> x&lt;y <span class="hljs-keyword">then</span> <span class="hljs-keyword">exit</span>(x) <span class="hljs-keyword">else</span> <span class="hljs-keyword">exit</span>(y);</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">var</span> arr: <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> int64;l,r:longint)</span>;</span> <span class="hljs-keyword">overload</span>;</span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">  i,j:longint;</span><br><span class="line">  m,t: int64;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">  i := l;</span><br><span class="line">  j := r;</span><br><span class="line">  m := arr[(l+r) &gt;&gt; <span class="hljs-number">1</span>];</span><br><span class="line">  <span class="hljs-keyword">repeat</span></span><br><span class="line">    <span class="hljs-keyword">while</span> arr[i]&lt;m <span class="hljs-keyword">do</span> inc(i);</span><br><span class="line">    <span class="hljs-keyword">while</span> arr[j]&gt;m <span class="hljs-keyword">do</span> dec(j);</span><br><span class="line">    <span class="hljs-keyword">if</span> i&lt;=j <span class="hljs-keyword">then</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">      t := arr[i];</span><br><span class="line">      arr[i] := arr[j];</span><br><span class="line">      arr[j] := t;</span><br><span class="line">      inc(i);</span><br><span class="line">      dec(j);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">  <span class="hljs-keyword">until</span> i&gt;j;</span><br><span class="line">  <span class="hljs-keyword">if</span> i&lt;r <span class="hljs-keyword">then</span> sort(arr, i, r);</span><br><span class="line">  <span class="hljs-keyword">if</span> l&lt;j <span class="hljs-keyword">then</span> sort(arr, l, j);</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">var</span> arr: <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> int64)</span>;</span> <span class="hljs-keyword">overload</span>;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">  sort(arr, low(arr), high(arr));</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dp</span><span class="hljs-params">(x: longint)</span>:</span> int64;</span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">  arr: <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> int64;</span><br><span class="line">  l,i, num: longint;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> f[x] &lt;&gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        dp := f[x];</span><br><span class="line">        <span class="hljs-keyword">exit</span>;</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> length(tree[x]) = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">      dp := <span class="hljs-number">1</span>;</span><br><span class="line">      f[x] := <span class="hljs-number">1</span>;</span><br><span class="line">      <span class="hljs-keyword">exit</span>;</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    l := length(tree[x]);</span><br><span class="line">    SetLength(arr, l);</span><br><span class="line">    <span class="hljs-keyword">for</span> i := Low(tree[x]) <span class="hljs-keyword">to</span> High(Tree[x]) <span class="hljs-keyword">do</span></span><br><span class="line">      arr[i] := dp(tree[x][i]);</span><br><span class="line">    Sort(arr);</span><br><span class="line">    num := (l*T-<span class="hljs-number">1</span>) <span class="hljs-keyword">div</span> <span class="hljs-number">100</span>+<span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> i := Low(arr) <span class="hljs-keyword">to</span> num-<span class="hljs-number">1</span> <span class="hljs-keyword">do</span></span><br><span class="line">      f[x] := f[x] + arr[i];</span><br><span class="line">    dp := f[x];</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    assign(input, <span class="hljs-string">&#x27;main.in&#x27;</span>);reset(input);</span><br><span class="line">    assign(output,<span class="hljs-string">&#x27;main.out&#x27;</span>);rewrite(output);</span><br><span class="line">    readln(n, T);</span><br><span class="line">    <span class="hljs-keyword">while</span> n&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        fillchar(f, sizeof(f), <span class="hljs-number">0</span>);</span><br><span class="line">        fillchar(tree, sizeof(tree), <span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span></span><br><span class="line">        <span class="hljs-keyword">begin</span></span><br><span class="line">            <span class="hljs-keyword">read</span>(x);</span><br><span class="line">            SetLength(tree[x], length(tree[x])+<span class="hljs-number">1</span>);</span><br><span class="line">            tree[x][high(tree[x])] := i;</span><br><span class="line">        <span class="hljs-keyword">end</span>;</span><br><span class="line">        readln;</span><br><span class="line">        dp(<span class="hljs-number">0</span>);</span><br><span class="line">        writeln(f[<span class="hljs-number">0</span>]);</span><br><span class="line">        readln(n, T);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    close(input); close(output);</span><br><span class="line"><span class="hljs-keyword">end</span>.</span><br></pre></div></div><h2 id="dynamic-arrays">Dynamic Arrays</h2><p class="noindent">这里，再总结一下动态数组的用法。</p><ol><li>定义：<code>a: array of [type];</code></li><li>设置长度： <code>SetLength(a, 10);</code></li><li>长度加一： <code>SetLength(a, Length(a)+1);</code></li><li>取得最大、最小下标： <code>High(a)</code>, <code>Low(a)</code></li></ol><p class="par">事实上，从 <a target="_blank" rel="noopener" href="http://freepascal.org/docs-html/ref/refsu18.html#x42-480003.3.1">1.1</a> 版本开始 FPC 就支持 Dynamic Arrays 了。所以在 NOIP 竞赛中我们大可放心使用。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/uva12186-another-crisis-dynamic-arrays-in-pascal/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/uva-11584-partitioning-by-palindromes/">UVa11584 Partitioning by Palindromes</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2014-09-24 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="eda88567baedd8ffd0a43aad985cb603c1e687f6632e800d9f56e365a07ff63f" class="post__content font__body"><blockquote><p class="noindent">这是一道区间型 DP，转移方程很简单，但在实现的过程中却遇见了很多坑，在此记录一下。链接：<a target="_blank" rel="noopener" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=27&problem=2631&mosmsg=Submission%20received%20with%20ID%2014256745%22">Link</a> 耗时：0.368s</p></blockquote><p>容易想到，前 $i$ 个数的划分情况可以由 $1,2,3,\ldots,i-1$ 的划分情况来决定。因此很容易得到状态转移方程：</p><p>$$d[i] = min(d[i], d[j]+1)$$</p><p class="par">其中 $j = 0, 1, 2,\ldots,n-1$ 并且 $s[j+1, i]$ 为回文串，初始条件：$d[i] = i$。$d[i]$ 表示前 i 项的最小划分。这样一来状态转移的复杂度就为 $O(n^2)$。</p><p>但状态转移的判断呢？“回文串”是一个复杂的条件，判断一个串是否为回文串需要将该串至少遍历一遍。这样一来时间复杂度就上升为 $O(n^3)$ 了。而事实上在这种算法中有许多无谓的计算，因此我们可以先对字符串进行预处理：用 <code>huiwen[i,j]</code> 表示 $s[i,j]$ 是否为回文串（奇怪的名字。。。）。如此一来，时间复杂度就降为 $O(n^2)$ 了。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    s: AnsiString;</span><br><span class="line">    n, _, i, j, l: integer;</span><br><span class="line">    huiwen: <span class="hljs-keyword">array</span> [<span class="hljs-number">1</span>..<span class="hljs-number">1000</span>, <span class="hljs-number">1</span>..<span class="hljs-number">1000</span>] <span class="hljs-keyword">of</span> boolean; <span class="hljs-comment">//s[i,j]是否为回文串</span></span><br><span class="line">    dp: <span class="hljs-keyword">array</span> [<span class="hljs-number">0</span>..<span class="hljs-number">1000</span>] <span class="hljs-keyword">of</span> integer; <span class="hljs-comment">//一定从0开始，否则当整串为回文串时就考虑不到了。</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">min</span><span class="hljs-params">(x,y: integer)</span>:</span> integer;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> x&lt;y <span class="hljs-keyword">then</span> <span class="hljs-keyword">exit</span>(x) <span class="hljs-keyword">else</span> <span class="hljs-keyword">exit</span>(y);</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">process</span><span class="hljs-params">(i,j: integer)</span>;</span> <span class="hljs-comment">//对回文串进行预处理</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    mid: Integer;</span><br><span class="line">    x,y: integer;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> j = i <span class="hljs-keyword">then</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        huiwen[i,j] := true;</span><br><span class="line">        <span class="hljs-keyword">exit</span>;</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    mid := i + (j-i+<span class="hljs-number">1</span>) <span class="hljs-keyword">shr</span> <span class="hljs-number">1</span>;</span><br><span class="line">    x := i;</span><br><span class="line">    y := j;</span><br><span class="line">    <span class="hljs-keyword">while</span> (x &lt;= mid) <span class="hljs-keyword">and</span> (s[x] = s[y]) <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        inc(x);</span><br><span class="line">        dec(y);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    huiwen[i, j] := x &gt; mid;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-comment">//assign(input, &#x27;main.in&#x27;); reset(input);</span></span><br><span class="line">    <span class="hljs-comment">//assign(output, &#x27;main.out&#x27;); rewrite(output);</span></span><br><span class="line">    readln(n);</span><br><span class="line">    <span class="hljs-keyword">for</span> _ := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        readln(s);</span><br><span class="line">        l := length(s);</span><br><span class="line">        <span class="hljs-comment">//Pre-process</span></span><br><span class="line">        fillchar(huiwen, sizeof(huiwen), <span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> l <span class="hljs-keyword">do</span></span><br><span class="line">            <span class="hljs-keyword">for</span> j := i <span class="hljs-keyword">to</span> l <span class="hljs-keyword">do</span> <span class="hljs-comment">//一定是从i开始，这个错卡了我很久。</span></span><br><span class="line">                process(i, j);</span><br><span class="line">        <span class="hljs-comment">//DP</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> l <span class="hljs-keyword">do</span></span><br><span class="line">        <span class="hljs-keyword">begin</span></span><br><span class="line">            dp[i] := i;</span><br><span class="line">            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> i-<span class="hljs-number">1</span> <span class="hljs-keyword">do</span></span><br><span class="line">                <span class="hljs-keyword">if</span> huiwen[j+<span class="hljs-number">1</span>, i] <span class="hljs-keyword">then</span></span><br><span class="line">                    dp[i] := min(dp[i], dp[j]+<span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">end</span>;</span><br><span class="line">        <span class="hljs-keyword">write</span>(dp[l]);</span><br><span class="line">        <span class="hljs-comment">{if _ &lt;&gt;n then }</span>writeln; <span class="hljs-comment">//吐槽一下：一开始我还谨慎地加上这句以避免行末回车，没想到UVa居然报错了。。看来UVa的比较算法还有待改进啊。</span></span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//close(input);close(output);</span></span><br><span class="line"><span class="hljs-keyword">end</span>.</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/uva-11584-partitioning-by-palindromes/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/uva437-the-tower-of-babylon/">UVa437 The Tower of Babylon</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2014-09-23 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="68f9eef2f1da2675e0648f24d4a34d97ecc77def30308d3c41609a4f75705488" class="post__content font__body"><blockquote><p class="noindent">链接：<a target="_blank" rel="noopener" href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=6&page=show_problem&problem=378">The Tower of Babylon</a> 耗时：0.015s</p></blockquote><p>这是刘汝佳的紫书中”DAG 中的动态规划”中的习题，我拿它用来熟悉 DAG 中的动态规划。</p><p>我们不妨进行逆向考虑：现堆上面的方块，然后考虑在下面进行叠加。这样子一来，影响决策的就只是最下面方块的尺寸了。</p><p>对于这种出现了”大套小”这样的二元关系的题，我们可以将其视为一个有向无环图：<strong>其中每个节点为一个状态，状态的转移是有固定的方向的</strong>（在此题中，状态转移为从小的方块到大的方块）。</p><p>但是这道题又不同于平常的 DAG 动态规划：若将边长视为状态的话，则要开一个巨大的数组，这是不可以接受的。因此，我们要换一种思维方式：只记录方块的序号和摆放的方式（如现将边长从小到大进行排序，然后用一个标志 k 表示当前是以第 k 小的边长作为高）。</p><p>至此，思路已经清晰了。用 $dp(i, k)$ 表示 <strong>“第 i 个方块以第 k 条边为高进行摆放”</strong> ，以下给出状态转移方程：</p><p>$$dp(i, k) = max\{dp(i, k), dp(j, k_2)\}$$</p><p class="par">其中 $j，k_2$ 遍历所有顶面矩形比 $dp(i, k)$ 小的状态。</p><p>代码实现首次尝试了 Pascal 中的 object 类型，使其更加工整，但不可避免地损耗了一些性能。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">type</span></span><br><span class="line">    Cube = <span class="hljs-keyword">object</span></span><br><span class="line">        a: <span class="hljs-keyword">array</span> [<span class="hljs-number">1</span>..<span class="hljs-number">3</span>] <span class="hljs-keyword">of</span> longint;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">init</span><span class="hljs-params">(x,y,z: longint)</span>;</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">height</span><span class="hljs-params">(k: integer)</span>:</span> longint;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">low</span><span class="hljs-params">(k: integer)</span>:</span> longint;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">high</span><span class="hljs-params">(k: integer)</span>:</span> longint;</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max</span><span class="hljs-params">(x,y: longint)</span>:</span> longint;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> x&gt;y <span class="hljs-keyword">then</span> max := x <span class="hljs-keyword">else</span> max := y;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">var</span> x,y: longint)</span>;</span></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    t: longint;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    t := x;</span><br><span class="line">    x := y;</span><br><span class="line">    y := t;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cube</span>.<span class="hljs-title">height</span><span class="hljs-params">(k: integer)</span>:</span> longint;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    height := self.a[k];</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cube</span>.<span class="hljs-title">high</span><span class="hljs-params">(k: integer)</span>:</span> longint;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">case</span> k <span class="hljs-keyword">of</span></span><br><span class="line">        <span class="hljs-number">1</span>: high := a[<span class="hljs-number">3</span>];</span><br><span class="line">        <span class="hljs-number">2</span>: high := a[<span class="hljs-number">3</span>];</span><br><span class="line">        <span class="hljs-number">3</span>: high := a[<span class="hljs-number">2</span>];</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cube</span>.<span class="hljs-title">low</span><span class="hljs-params">(k: integer)</span>:</span> longint;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">case</span> k <span class="hljs-keyword">of</span></span><br><span class="line">        <span class="hljs-number">1</span>: low := a[<span class="hljs-number">2</span>];</span><br><span class="line">        <span class="hljs-number">2</span>,<span class="hljs-number">3</span>: low := a[<span class="hljs-number">1</span>];</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">Cube</span>.<span class="hljs-title">init</span><span class="hljs-params">(x, y, z: longint)</span>;</span></span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">   <span class="hljs-keyword">if</span> x&gt;y <span class="hljs-keyword">then</span> swap(x,y);</span><br><span class="line">   <span class="hljs-keyword">if</span> y&gt;z <span class="hljs-keyword">then</span> swap(y,z);</span><br><span class="line">   <span class="hljs-keyword">if</span> x&gt;y <span class="hljs-keyword">then</span> swap(x,y);</span><br><span class="line">   a[<span class="hljs-number">1</span>] := x;</span><br><span class="line">   a[<span class="hljs-number">2</span>] := y;</span><br><span class="line">   a[<span class="hljs-number">3</span>] := z;</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    f: <span class="hljs-keyword">array</span> [<span class="hljs-number">1</span>..<span class="hljs-number">30</span>, <span class="hljs-number">1</span>..<span class="hljs-number">3</span>] <span class="hljs-keyword">of</span> longint;</span><br><span class="line">    i,j,m,n,x,y,z: longint;</span><br><span class="line">    cnt: longint;</span><br><span class="line">    cubes: <span class="hljs-keyword">array</span> [<span class="hljs-number">1</span>..<span class="hljs-number">30</span>] <span class="hljs-keyword">of</span> Cube;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dp</span><span class="hljs-params">(id, k: integer)</span>:</span> longint;</span><br><span class="line"><span class="hljs-keyword">var</span></span><br><span class="line">    l, h, hi: longint;</span><br><span class="line">    i, j: integer;</span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    <span class="hljs-keyword">if</span> f[id, k] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span></span><br><span class="line">        <span class="hljs-keyword">exit</span>(f[id, k]);</span><br><span class="line">    l := cubes[id].low(k);</span><br><span class="line">    hi := cubes[id].height(k);</span><br><span class="line">    h := cubes[id].high(k);</span><br><span class="line"></span><br><span class="line">    f[id, k] := hi;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        <span class="hljs-comment">//if i = id then continue;  //此处在一开始时忘记考虑了立方体有无穷多个这一条件。</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-number">3</span> <span class="hljs-keyword">do</span></span><br><span class="line">        <span class="hljs-keyword">begin</span></span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ((cubes[i].low(j) &lt; l) <span class="hljs-keyword">and</span> (cubes[i].high(j) &lt; h)) <span class="hljs-keyword">then</span></span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            f[id, k] := max(f[id, k], dp(i, j)+hi);</span><br><span class="line">        <span class="hljs-keyword">end</span>;</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    dp := f[id, k];</span><br><span class="line"><span class="hljs-keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">begin</span></span><br><span class="line">    assign(input, <span class="hljs-string">&#x27;main.in&#x27;</span>);reset(input);</span><br><span class="line">    assign(output, <span class="hljs-string">&#x27;main.out&#x27;</span>);rewrite(output);</span><br><span class="line">    <span class="hljs-keyword">read</span>(n);</span><br><span class="line">    cnt := <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">do</span></span><br><span class="line">    <span class="hljs-keyword">begin</span></span><br><span class="line">        inc(cnt);</span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span></span><br><span class="line">        <span class="hljs-keyword">begin</span></span><br><span class="line">            <span class="hljs-keyword">read</span>(x,y,z);</span><br><span class="line">            cubes[i].init(x,y,z);</span><br><span class="line">        <span class="hljs-keyword">end</span>;</span><br><span class="line">        fillchar(f, sizeof(f), <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">        m := <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span></span><br><span class="line">            <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-number">3</span> <span class="hljs-keyword">do</span></span><br><span class="line">                m := max(m, dp(i, j));</span><br><span class="line"></span><br><span class="line">        writeln(<span class="hljs-string">&#x27;Case &#x27;</span>, cnt, <span class="hljs-string">&#x27;: maximum height = &#x27;</span>, m);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">read</span>(n);</span><br><span class="line">    <span class="hljs-keyword">end</span>;</span><br><span class="line">    close(input);close(output);</span><br><span class="line"><span class="hljs-keyword">end</span>.</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/uva437-the-tower-of-babylon/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/noip2011-expression/">NOIP2011 表达式计算</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2014-09-22 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="4890610a14c335c7519cf8aea4675bf5941203e4ad4edaad7910fe5500717ce0" class="post__content font__body"><blockquote><p class="noindent">记得 11 年的时候，觉得这道题爆难，根本无从下手。三年后再次回顾，终于 AC 了，就当是对表达式求值和动态规划的复习吧。</p></blockquote><p class="noindent">题目：<a target="_blank" rel="noopener" href="http://codevs.cn/problem/1133/">Link</a></p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-comment">// Accepted.</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Mod 10007</span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {</span><br><span class="line">    <span class="hljs-type">long</span> <span class="hljs-type">long</span> v0;  <span class="hljs-comment">//当前值为 0 的个数</span></span><br><span class="line">    <span class="hljs-type">long</span> <span class="hljs-type">long</span> v1;  <span class="hljs-comment">//当前值为 1 的个数</span></span><br><span class="line">    <span class="hljs-type">char</span> ch;  <span class="hljs-comment">//当前字符</span></span><br><span class="line">} vertex;</span><br><span class="line"></span><br><span class="line">vertex f[<span class="hljs-number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>{</span><br><span class="line">    <span class="hljs-type">int</span> w0 = f[p<span class="hljs-number">-1</span>].v0 * f[p].v0;</span><br><span class="line">    <span class="hljs-type">int</span> w1 = f[p<span class="hljs-number">-1</span>].v0*f[p].v1+f[p<span class="hljs-number">-1</span>].v1*f[p].v0+f[p<span class="hljs-number">-1</span>].v1*f[p].v1;</span><br><span class="line">    f[p<span class="hljs-number">-1</span>].v0 = w0 % Mod;</span><br><span class="line">    f[p<span class="hljs-number">-1</span>].v1 = w1 % Mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">merge_product</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span>  <span class="hljs-comment">//处理当前的值和前一个值取&#x27;*&#x27;的操作</span></span></span><br><span class="line"><span class="hljs-function"></span>{</span><br><span class="line">       <span class="hljs-type">int</span> w0=f[p<span class="hljs-number">-1</span>].v0*f[p].v0+f[p<span class="hljs-number">-1</span>].v0*f[p].v1+f[p<span class="hljs-number">-1</span>].v1*f[p].v0;</span><br><span class="line">       <span class="hljs-type">int</span> w1=f[p<span class="hljs-number">-1</span>].v1*f[p].v1;</span><br><span class="line">       f[p<span class="hljs-number">-1</span>].v0=w0%Mod;</span><br><span class="line">       f[p<span class="hljs-number">-1</span>].v1=w1%Mod;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>{</span><br><span class="line">    <span class="hljs-type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    f[<span class="hljs-number">0</span>].v0=f[<span class="hljs-number">0</span>].v1=<span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (n--)</span><br><span class="line">    {</span><br><span class="line">          now++;   <span class="hljs-comment">//新建一个空位读入新符号</span></span><br><span class="line">          cin&gt;&gt;f[now].ch;</span><br><span class="line">          f[now].v0=f[now].v1=<span class="hljs-number">1</span>;  <span class="hljs-comment">//初始化当前符号的前面的值 (虽然&#x27;)&#x27;除外，但也不影响)</span></span><br><span class="line">          <span class="hljs-keyword">if</span> (f[now].ch==<span class="hljs-string">&#x27;+&#x27;</span>)</span><br><span class="line">          {</span><br><span class="line">             <span class="hljs-keyword">if</span> (f[now<span class="hljs-number">-1</span>].ch==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-comment">//处理&#x27;*&#x27;</span></span><br><span class="line">             {</span><br><span class="line">                now--;</span><br><span class="line">                <span class="hljs-built_in">merge_product</span>(now);</span><br><span class="line">                f[now]=f[now+<span class="hljs-number">1</span>];</span><br><span class="line">             }</span><br><span class="line">             <span class="hljs-keyword">if</span> (f[now<span class="hljs-number">-1</span>].ch==<span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-comment">//处理&#x27;+&#x27;</span></span><br><span class="line">             {</span><br><span class="line">                now--;</span><br><span class="line">                <span class="hljs-built_in">merge_sum</span>(now);</span><br><span class="line">                f[now]=f[now+<span class="hljs-number">1</span>];</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line">          <span class="hljs-keyword">if</span> (f[now].ch==<span class="hljs-string">&#x27;*&#x27;</span>)</span><br><span class="line">           <span class="hljs-keyword">if</span> (f[now<span class="hljs-number">-1</span>].ch==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-comment">//处理&#x27;*&#x27;</span></span><br><span class="line">           {</span><br><span class="line">              now--;</span><br><span class="line">              <span class="hljs-built_in">merge_product</span>(now);</span><br><span class="line">              f[now]=f[now+<span class="hljs-number">1</span>];</span><br><span class="line">           }</span><br><span class="line">          <span class="hljs-keyword">if</span> (f[now].ch==<span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-comment">//处理&#x27;)&#x27;(比较麻烦)</span></span><br><span class="line">          {</span><br><span class="line">             now--;</span><br><span class="line">             <span class="hljs-keyword">if</span> (f[now].ch==<span class="hljs-string">&#x27;*&#x27;</span>)</span><br><span class="line">             {</span><br><span class="line">                <span class="hljs-built_in">merge_product</span>(now);</span><br><span class="line">                now--;</span><br><span class="line">             }</span><br><span class="line">             <span class="hljs-keyword">if</span> (f[now].ch==<span class="hljs-string">&#x27;+&#x27;</span>)</span><br><span class="line">             {</span><br><span class="line">                <span class="hljs-built_in">merge_sum</span>(now);</span><br><span class="line">                now--;</span><br><span class="line">             }</span><br><span class="line">             now--;</span><br><span class="line">             f[now].v0=f[now+<span class="hljs-number">1</span>].v0;</span><br><span class="line">             f[now].v1=f[now+<span class="hljs-number">1</span>].v1;</span><br><span class="line">             <span class="hljs-keyword">if</span> (f[now].ch==<span class="hljs-string">&#x27;*&#x27;</span>)</span><br><span class="line">             {</span><br><span class="line">                <span class="hljs-built_in">merge_product</span>(now);</span><br><span class="line">                now--;</span><br><span class="line">             }</span><br><span class="line">          }</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">if</span> (f[now].ch==<span class="hljs-string">&#x27;*&#x27;</span>)  <span class="hljs-comment">//处理完了以后，可能还有残留的&#x27;*&#x27;和&#x27;+&#x27;</span></span><br><span class="line">    {</span><br><span class="line">       <span class="hljs-built_in">merge_product</span>(now);</span><br><span class="line">       now--;</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">if</span> (f[now].ch==<span class="hljs-string">&#x27;+&#x27;</span>)</span><br><span class="line">    {</span><br><span class="line">       <span class="hljs-built_in">merge_sum</span>(now);</span><br><span class="line">       now--;</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;f[<span class="hljs-number">0</span>].v0;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">}</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/noip2011-expression/">READ MORE</a></div></article></div><div lang="zh" class="page-navigator font__ui"><span class="page__button"><a href="/categories/Tech/page/8/" class="pre">PREV</a></span><span class="page__button"><a href="/categories/Tech/page/10/" class="next">NEXT</a></span></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>