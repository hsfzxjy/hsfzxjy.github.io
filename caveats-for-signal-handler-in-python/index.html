<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script>(()=>{let r="/cnfonts.js",n=document,e=n.createElement("link");e.rel="stylesheet",e.href="/fontchan/jBKCaHQX.css",e.blocking="render",e.onerror=()=>{var e=n.createElement("script");e.src=r,e.onload=()=>$fontchan.injectCss(),n.head.appendChild(e)},n.head.appendChild(e),"serviceWorker"in navigator&&navigator.serviceWorker.register(r,{scope:"/"}).then(e=>e.update())})()</script><title>一个 Reentrant Error 引发的对 Python 信号机制的探索和思考</title><meta itemprop="title" content="一个 Reentrant Error 引发的对 Python 信号机制的探索和思考 - hsfzxjy 的博客"><meta itemprop="og:title" content="一个 Reentrant Error 引发的对 Python 信号机制的探索和思考 - hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="description" content="写在前面
前几天工作时遇到了一个匪夷所思的问题。经过几次尝试后问题得以解决，但问题产生的原因却仍令人费解。查找 S..."><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div lang="zh" class="post post-page"><h1 lang="zh" class="post__title">一个 Reentrant Error 引发的对 Python 信号机制的探索和思考</h1><div class="post__meta font__ui">2017-08-17 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div class="post__content font__body noindent"><h2 id="写在前面-4">写在前面</h2><p>前几天工作时遇到了一个匪夷所思的问题。经过几次尝试后问题得以解决，但问题产生的原因却仍令人费解。查找 SO 无果，我决定翻看 Python 的源码。断断续续地研究了几天，终于恍然大悟。撰此文以记。</p><p class="noindent">本文环境：</p><ul><li>Ubuntu 16.04 (64 bit)</li><li>Python 3.6.2</li></ul><p class="par">使用的 C 源码可以从 <a target="_blank" rel="noopener" href="https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgz">Python 官网</a> 获取。</p><h2 id="起因">起因</h2><p>工作时用到了 celery 作为异步任务队列，为方便调试，我写了一个脚本用以启动/关闭 celery 主进程。代码简化后如下：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">import</span> sys</span><br><span class="line"><span class="hljs-keyword">import</span> subprocess</span><br><span class="line"><span class="hljs-comment"># ...</span></span><br><span class="line">celery_process = subprocess.Popen(</span><br><span class="line">    [<span class="hljs-string">&#x27;celery&#x27;</span>, <span class="hljs-string">&#x27;-A&#x27;</span>, <span class="hljs-string">&#x27;XXX&#x27;</span>, <span class="hljs-string">&#x27;worker&#x27;</span>],</span><br><span class="line">    stdout=subprocess.PIPE,</span><br><span class="line">    stderr=sys.stderr</span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">try</span>:</span><br><span class="line">    <span class="hljs-comment"># Start and wait for server process</span></span><br><span class="line"><span class="hljs-keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="hljs-comment"># Ctrl + C pressed</span></span><br><span class="line">    celery_process.terminate()</span><br><span class="line">    celery_process.wait()</span><br></pre></div></div><p class="par">代码启动了 celery worker，并尝试在捕获到 <code>KeyboardInterrupt</code> 异常时将其热关闭。</p><p>初看上去没什么问题。然而实际测试时却发生了十分诡异的事情：按下 <code>Ctrl+C</code> 后，程序 <strong>偶尔</strong> 会抛出这样的异常：<code>RuntimeError: reentrant call inside &lt;_io.BufferedWriter name=&#39;&lt;stdout&gt;&#39;&gt;</code>。诡异之处有两点：</p><ul><li>异常发生的时机有随机性</li><li>异常的 traceback 指向 celery 包，也就是说这是在 celery 主进程内部发生的异常</li></ul><p class="par">这个结果大大出乎了我的意料。随机性异常是众多最难缠的问题之一，因为这常常意味着并发问题，涉及底层知识，病灶隐蔽，调试难度大，同时没有有效的手段判断问题是否彻底解决（可能只是降低了频率）。</p><h2 id="解决">解决</h2><p>异常信息中有两个词很关键：<code>reentrant</code> 和 <code>stdout</code>。<code>reentrant call</code> 说明有一个不可重入的函数被递归调用了；<code>stdout</code> 则指明了发生的地点和时机。初步可以判定：<strong>由于某种原因，有两股控制流在同时操控 <code>stdout</code></strong> 。</p><p>“可重入”是什么？根据 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reentrancy_%28computing%29">Wikipedia</a> 的定义：<strong>如果一个子程序能在执行时被中断并在之后被正确地、安全地唤起，它就被称为可重入的</strong>。依赖于全局数据的过程是不可重入的，如 <code>printf</code>（依赖于全局文件描述符）、<code>malloc</code>（依赖与和堆相关的一系列数据结构）等函数。需要注意的是，可重入性（reentrant）与 线程安全性（thread-safe）并不等价，甚至不存在包含关系，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reentrancy_%28computing%29#Examples">Wikipedia</a> 中给出了相关的反例。</p><p>多次尝试后，出现了一条线索：有时候 <code>worker: Warm shutdown (MainProcess)</code> 这个字符串会被二次打印，时机不确定。这句话是 celery 将要热关闭时的提示语，二次出现只可能是主进程收到了第二个信号。阅读 <a target="_blank" rel="noopener" href="http://docs.celeryproject.org/en/latest/userguide/workers.html#process-signals">celery 的文档</a> 可知，<code>SIGINT</code> 和 <code>SIGTERM</code> 信号可以引发热关闭。回头浏览我的代码，其中只有一处发送了 <code>SIGTERM</code> 信号（<code>celery_process.terminate()</code>），至于另一个神秘的信号，我怀疑是 <code>SIGINT</code>。</p><p>SO 一下，结果印证了我的猜想：</p><blockquote><p>If you are generating the SIGINT with Ctrl-C on a Unix system, then the signal is being sent to the entire process group. – via <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6803395/child-process-receives-parents-sigint">StackOverflow</a></p></blockquote><p class="par"><code>SIGINT</code> 信号不仅会发送到父进程，而是会发到整个进程组，默认情况下包括了所有子进程。也就是说——在拦截了 <code>KeyboardInterrupt</code> 之后执行的 <code>celery_process.terminate()</code> 是多此一举，因为 <code>SIGINT</code> 信号也会被发送至 celery 主进程，同样会引起热关闭。代码稍作修改即可正常运行：</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-comment"># ...</span></span><br><span class="line"><span class="hljs-keyword">try</span>:</span><br><span class="line">    <span class="hljs-comment"># Start and wait for server process</span></span><br><span class="line"><span class="hljs-keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="hljs-comment"># Ctrl + C pressed</span></span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    <span class="hljs-comment"># Signal SIGTERM if no exception raised</span></span><br><span class="line">    celery_process.terminate()</span><br><span class="line"><span class="hljs-keyword">finally</span>:</span><br><span class="line">    <span class="hljs-comment"># Wait for it to avoid it becoming orphan</span></span><br><span class="line">    celery_process.wait()</span><br></pre></div></div><h2 id="猜测">猜测</h2><p>UNIX 信号处理是一个相当奇葩的过程——当进程收到一个信号时，内核会选择一条线程（以一定的规则），中断其当前控制流，将控制流强行转给信号处理函数，待其执行完毕后再将控制流交还给原线程。时序图如下：</p><p><img loading="lazy" src="/assets/caveats-for-signal-handler-in-python/bVS7gW" alt=""></p><p>由于控制流转换发生在同一条线程上，许多线程间同步机制会失效甚至报错。因此信号处理函数的编写要比线程函数更加严格，对同一个文件输出是被禁止并且无解的，因为很可能会发生这样的事情：</p><p><img loading="lazy" src="/assets/caveats-for-signal-handler-in-python/bVS7nP" alt=""></p><p>而且这个问题不能通过加锁来解决（因为是在同一个线程中，会死锁）。</p><p>因此，我猜测异常发生时的事件时序是这样的：在 <code>print</code> 未执行完时中断，又在信号处理函数中调用 print，触发了重入检测，引起 <code>RuntimeError</code>：</p><p><img loading="lazy" src="/assets/caveats-for-signal-handler-in-python/bVS831" alt=""></p><h2 id="疑云又起">疑云又起</h2><p>不幸的是，我的猜想很快被推翻了。</p><p>在翻看 Python <code>signal</code> 模块的官方文档，我看到了如下叙述：</p><blockquote><p>A Python signal handler does not get executed inside the low-level (C) signal handler. Instead, the low-level signal handler sets a flag which tells the virtual machine to execute the corresponding Python signal handler at a later point(for example at the next bytecode instruction). <cite>– via <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/signal.html?highlight=signal#execution-of-python-signal-handlers">Python Documentation</a></cite></p></blockquote><p class="par">也就是说，<strong>Python 中使用 <code>signal.signal</code> 注册的信号处理函数并不会在收到信号时立即执行，而只是简单做一个标记，将其延迟至之后的某个时机</strong>。这么做可以尽量快地结束异常控制流，减少其对被阻断进程的影响。</p><p>这番表述可以说是推翻了我的猜想，因为 Signal Handler 中的 <code>print</code> 并没有在异常控制流中执行。那异常又是怎么产生的呢？</p><p>文档说 Python Signal Handler 会被延后至某个时机进行，但并没有明示是什么时候。对于这个疑问，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19699314/how-to-use-a-separate-thread-for-asynchronous-signal-handling-in-python">这个提问的被采纳回答</a> 则斩钉截铁地将其具体化到了“某两个 Python 字节码之间”。</p><p>我们知道，Python 程序在执行前会被编译成 Python 内定的字节码（bytecode）,Python 虚拟机实际执行的正是这些字节码。倘若该回答是正确的，则立即有如下推论：<strong>在处理信号的过程中，字节码具有原子性（atomic）</strong>。也就是说，主线程总是在两个字节码之间决定是否转移控制流，而 <strong>不会</strong> 出现以下情况：</p><p><img loading="lazy" src="/assets/caveats-for-signal-handler-in-python/bVS7EH" alt=""></p><p>这很显然与我的程序结果相悖：<code>print</code> 与 <code>print</code> 所调用的 <code>io.BufferedWriter.write</code> 和 <code>io.BufferedWriter.flush</code> 都是用纯 C 代码编写的，对其的调用只消耗一条字节码（<code>CALL_FUNCTION</code> 或 <code>CALL_FUNCTION_KW</code>），在信号中断的影响下，这几个函数仍保持原子性，在时序图上互不重叠，更不会发生重入。</p><p><img loading="lazy" src="/assets/caveats-for-signal-handler-in-python/bVS7ag" alt=""></p><p>因此，<strong>除了在两个字节码之间，应该还有其他时机唤起了 Python Signal Handler</strong>。</p><p>至此，问题已触及 Python 的地板了，需向更底层挖掘才能找到答案。</p><h2 id="深入源码">深入源码</h2><p>信号注册逻辑位于 <code>Modules/signalmodule.c</code> 文件中。313 行的 <code>signal_handler</code> 是信号处理函数的最外层包装，由系统调用 <code>signal</code> 或 <code>sigaction</code> 注册至内核，并在信号发生时被内核回调，是异常控制流的入口。<code>signal_handler</code> 主要调用了 239 行处的 <code>trip_signal</code> 函数，其中有这样一段代码：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line">Handlers[sig_num].tripped = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (!is_tripped) {</span><br><span class="line">    is_tripped = <span class="hljs-number">1</span>;</span><br><span class="line">    Py_AddPendingCall(checksignals_witharg, <span class="hljs-literal">NULL</span>);</span><br><span class="line">}</span><br></pre></div></div><p class="par">这段代码便是文档中所说的逻辑：做标记并延后 Python Signal Handler。其中 <code>checksignals_witharg</code> 即为被延后调用的函数，位于 192 行，核心代码只有一句：</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-type">static</span> <span class="hljs-type">int</span></span><br><span class="line"><span class="hljs-title function_">checksignals_witharg</span><span class="hljs-params">(<span class="hljs-type">void</span> * unused)</span></span><br><span class="line">{</span><br><span class="line">    <span class="hljs-keyword">return</span> PyErr_CheckSignals();</span><br><span class="line">}</span><br></pre></div></div><p class="par"><code>PyErr_CheckSignals</code> 位于 1511 行：</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line"><span class="hljs-type">int</span></span><br><span class="line"><span class="hljs-title function_">PyErr_CheckSignals</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="hljs-type">int</span> i;</span><br><span class="line">    PyObject *f;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (!is_tripped)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WITH_THREAD</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (PyThread_get_thread_ident() != main_thread)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    is_tripped = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (!(f = (PyObject *)PyEval_GetFrame()))</span><br><span class="line">        f = Py_None;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NSIG; i++) {</span><br><span class="line">        <span class="hljs-keyword">if</span> (Handlers[i].tripped) {</span><br><span class="line">            PyObject *result = <span class="hljs-literal">NULL</span>;</span><br><span class="line">            PyObject *arglist = Py_BuildValue(<span class="hljs-string">&quot;(iO)&quot;</span>, i, f);</span><br><span class="line">            Handlers[i].tripped = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (arglist) {</span><br><span class="line">                result = PyEval_CallObject(Handlers[i].func,</span><br><span class="line">                                           arglist);</span><br><span class="line">                Py_DECREF(arglist);</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">if</span> (!result)</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line"></span><br><span class="line">            Py_DECREF(result);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">}</span><br></pre></div></div><p class="par">可见，这个函数便是异步回调的最里层，包含了执行 Python Signal Handler 的逻辑。</p><p>至此我们可以发现，整个 Python 中有两个办法可以唤起 Python Signal Handler，一个是调用 <code>checksignals_witharg</code>，另一个是调用 <code>PyErr_CheckSignals</code>。前者只是后者的简单封包。</p><p><code>checksignals_witharg</code> 在 Python 源码中只出现了一次（不包括定义，下同），没有被直接调用的迹象。但需要注意的是，<code>checksignals_witharg</code> 曾被当做 <code>Py_AddPendingCall</code> 的参数，<code>Py_AddPendingCall</code> 所做的工作时将其加入到一个全局队列中。与之对应的出队操作是 <code>Py_MakePendingCalls</code>，位于 <code>Python/ceval.c</code> 的 464 行。此函数会间接调用 <code>checksignals_witharg</code>，在 Python 源码中被调用了 3 次：</p><ul><li><code>Modules/_threadmodule.c</code> 52 行的 <code>acquire_timed</code></li><li><code>Modules/main.c</code> 310 行的 <code>run_file</code></li><li><code>Python/ceval.c</code> 722 行的 <code>_PyEval_EvalFrameDefault</code></li></ul><p class="par">值得注意的是，<code>_PyEval_EvalFrameDefault</code> 是一个长达 2600 多行的状态机，是解析字节码的核心逻辑所在。此处调用出现于状态机主循环开始处——这印证了上面回答中的部分说法，即 Python 会在两个字节码中间唤起 Python Signal Hanlder。</p><p>而 <code>PyErr_CheckSignals</code> 在 Python 源码中出现了 80 多处，遍布 Python 的各个模块中——这说明该回答的另一半说法是错误的：<strong>除了在两个字节码之间，Python 还可能在其他角落唤起 Python Signal Handler</strong>。其中有两处值得注意，它们都位于 <code>Modules/_io/bufferedio.c</code> 中：</p><ul><li>1884 行的 <code>_bufferedwriter_flush_unlocked</code></li><li>1939 行的 <code>_io_BufferedWriter_write_impl</code></li></ul><p class="par">这两个函数是 <code>io.BufferedWriter</code> 类的底层实现，会被 <code>print</code> 间接调用。仔细观察可以发现，它们都有着相似的结构：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line">ENTER_BUFFERED(self)</span><br><span class="line"><span class="hljs-comment">// ...</span></span><br><span class="line">PyErr_CheckSignals();</span><br><span class="line"><span class="hljs-comment">// ...</span></span><br><span class="line">LEAVE_BUFFERED(self)</span><br></pre></div></div><p class="par"><code>ENTER_BUFFERED</code> 是一个宏，会尝试申请无阻塞线程锁以保证函数不会被重入：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENTER_BUFFERED(self) \</span></span><br><span class="line"><span class="hljs-meta">    ( (PyThread_acquire_lock(self-&gt;lock, 0) ? \</span></span><br><span class="line"><span class="hljs-meta">       1 : _enter_buffered_busy(self)) \</span></span><br><span class="line"><span class="hljs-meta">     &amp;&amp; (self-&gt;owner = PyThread_get_thread_ident(), 1) )</span></span><br></pre></div></div><p><img loading="lazy" src="/assets/caveats-for-signal-handler-in-python/bVS9AJ" alt=""></p><p>至此，真相已经大白了。</p><h2 id="真相-1">真相</h2><p>当信号中断发生在 <code>_bufferedwriter_flush_unlocked</code> 或 <code>_io_BufferedWriter_write_impl</code> 中时，这两个函数中的 <code>PyErr_CheckSignals</code> 会直接唤起 Python Signal Handler，而此时由 <code>ENTER_BUFFERED</code> 上的锁尚未解开，若 Python Signal Handler 中又有 <code>print</code> 函数调用，则会导致再次 <code>ENTER_BUFFERED</code> 上锁失败，从而抛出异常。时序图如下：</p><p><img loading="lazy" src="/assets/caveats-for-signal-handler-in-python/bVS9lQ" alt=""></p><h2 id="思考">思考</h2><p>为什么不将 Python Signal Handler 调用的地点统一在一个地方，而是散布在程序的各处呢？阅读相关代码，我认为有两点原因：</p><ul><li>信号中断会使某些系统调用行为异常，从而使系统调用的调用者不知如何处理，此时需要调用 Signal Handler 进行可能的状态恢复。一个例子是 <code>write</code> 系统调用，信号中断会导致数据部分写回，与此相关的一大批 I/O 函数（包括出问题的 <code>_bufferedwriter_flush_unlocked</code> 和 <code>_io_BufferedWriter_write_impl</code>）便只能相应地调用 <code>PyErr_CheckSignals</code>。</li><li>某些函数需要做计算密集型任务，为了防止 Python Signal Handler 的调用被过长地延后（其实主要是为了及时响应键盘中断，防止程序无法从前台结束），必须适时地检查并调用 Python Signal Handler。一个例子是 <code>Objects/longobject.c</code> 中的诸函数，<code>longobject.c</code> 定义了 Python 特有的无限长整型，其相关的运算可能耗时相当长，必须做这样的处理。</li></ul><h2 id="总结">总结</h2><ul><li>Python Signal Handler 的调用会被延后，但时机不止在两个字节码之间，而是可能出现在任何地方。</li><li>由于第一条，Python Signal Handler 中尽量都使用 <strong>可重入的</strong> 的函数，以避免奇怪的问题。可重入性可以从文档获知，也可以结合定义由源码推断出来。</li><li>有疑问，翻源码。人会说谎，代码不会。</li></ul><br><blockquote><p class="cc">作者：hsfzxjy<br>链接：<span class="cc-link"></span><br>许可：<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>.<br>著作权归作者所有。本文<b>不允许</b>被用作商业用途，非商业转载请注明出处。</p></blockquote><script>!function(){var n=document.querySelector("span.cc-link");n&&(n.innerHTML='<a href="'+location.href+'">'+location.href+"</a>")}()</script></div><div class="post__tags"><a href="/tags/Python/">Python</a><a href="/tags/POSIX/">POSIX</a><a href="/tags/Reentrancy/">Reentrancy</a></div><div class="post-nav"><a href="/python-gil-and-threads/" class="pre">«从伪并行的 Python 多线程说起</a><a href="/linux-file-permissions/" class="next">Linux 文件权限»</a></div><div id="disqus_thread"><div id="no-comment"><h2>OOPS!</h2><span>A comment box should be right here...</span><span>But it was gone due to network issues :-(</span><span>If you want to leave comments, make sure you have access to&nbsp;<a target="_blank" rel="noopener" href="https://disqus.com">disqus.com</a>.</span></div><script>var disqus_shortname="hsfzxjy",disqus_identifier="caveats-for-signal-handler-in-python/",disqus_title="一个 Reentrant Error 引发的对 Python 信号机制的探索和思考",disqus_url="https://i.hsfzxjy.site/caveats-for-signal-handler-in-python/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.defer=!0,e.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(e),e.onerror=function(){document.getElementById("no-comment").classList.add("show")}}()</script><script id="dsq-count-scr" src="//hsfzxjy.disqus.com/count.js" async defer></script></div></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"><div id="toc" lang="zh" class="font__body"><div class="toc-toggler"></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2-4"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%B7%E5%9B%A0"><span class="toc-number">2.</span> <span class="toc-text">起因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3"><span class="toc-number">3.</span> <span class="toc-text">解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8C%9C%E6%B5%8B"><span class="toc-number">4.</span> <span class="toc-text">猜测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%96%91%E4%BA%91%E5%8F%88%E8%B5%B7"><span class="toc-number">5.</span> <span class="toc-text">疑云又起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">深入源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E7%9B%B8-1"><span class="toc-number">7.</span> <span class="toc-text">真相</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol></div></div></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>