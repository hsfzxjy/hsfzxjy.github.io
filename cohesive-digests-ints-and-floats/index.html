<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script>(()=>{let r="/cnfonts.js",n=document,e=n.createElement("link");e.rel="stylesheet",e.href="/fontchan/jBKCaHQX.css",e.blocking="render",e.onerror=()=>{var e=n.createElement("script");e.src=r,e.onload=()=>$fontchan.injectCss(),n.head.appendChild(e)},n.head.appendChild(e),"serviceWorker"in navigator&&navigator.serviceWorker.register(r,{scope:"/"}).then(e=>e.update())})()</script><title>Cohesive Digests for Ints and Floats</title><meta itemprop="title" content="Cohesive Digests for Ints and Floats - hsfzxjy 的博客"><meta itemprop="og:title" content="Cohesive Digests for Ints and Floats - hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="description" content="On developing sdxtra there comes a problem that is to cal..."><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div lang="en" class="post post-page"><h1 lang="en" class="post__title">Cohesive Digests for Ints and Floats</h1><div class="post__meta font__ui">2025-01-14 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div class="post__content font__body"><p>On developing <a target="_blank" rel="noopener" href="https://github.com/hsfzxjy/sdxtra">sdxtra</a> there comes a problem that is to calculate cohesive digests for numeric values, in a way agnostic to their types. This post discusses the problem and presents solutions in Go, though the ideas are applicable to other languages as well.</p><h2 id="the-cohesive-digesting-problem">The Cohesive Digesting Problem</h2><h3 id="numeric-values-and-their-representations">Numeric Values and Their Representations</h3><p>In most programming languages, numeric values are usually represented as various types, such as <code>float64</code>, <code>int32</code>, <code>uint64</code>, etc., to meet different requirements of precision, range, and memory usage. Internally, these types diverse in bit lengths, layouts or signedness. Therefore, even referring to the same number in math, they may have different bit representation.</p><div class="gk-code hljs" data-gk-id="BLOCK1" data-gk-title="Same number, different representations"><div class="gk-code-display"><pre><span class="gk-section gk-zip zipped" data-gk-sid="BLOCK1.SEC1" data-gk-type="zip"><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">  <span class="hljs-string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="hljs-string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {</span><br><span class="line">  fmt.Printf(<span class="hljs-string">&quot;%016x %x\n&quot;</span>, <span class="hljs-type">uint64</span>(<span class="hljs-number">42</span>), math.Float64bits(<span class="hljs-number">42.0</span>))</span><br><span class="line">  <span class="hljs-comment">// 000000000000002a 4045000000000000</span></span><br><span class="line">}</span><br></pre></div></div><h3 id="digesting">Digesting</h3><p><strong>Digesting</strong> is a process that maps arbitary data into a fixed-length string, called a <strong>digest</strong>.</p><p>Digests are deterministic and discriminative. By deterministic, it means the same input data would always generate the same digest string. By discriminative, it means different input data would hopefully generate different digest strings. Though there will always be collisions, due to pigeonhole principle, modern digesting algorithms like SHA-256 are designed to minimize such probability, which effectively enables usage of digests in scenarios like data deduplication, data indexing, etc.</p><p>Modern digesting algorithms are byte-oriented. During the digesting process, one should first convert the input data into a byte sequence following a designated scheme, with which the algorithms like SHA-256 further calculate the digest string. The scheme one adopts should be carefully chosen, such that the resulting byte sequence faithfully reflects the information of the input data.</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="gk-section gk-zip zipped" data-gk-sid="BLOCK2.SEC1" data-gk-type="zip"><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">  <span class="hljs-string">&quot;crypto/sha256&quot;</span></span><br><span class="line">  <span class="hljs-string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="hljs-string">&quot;encoding/binary&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br></span><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> {</span><br><span class="line">  A <span class="hljs-type">uint32</span></span><br><span class="line">  B <span class="hljs-type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {</span><br><span class="line">  foo := Foo{<span class="hljs-number">42</span>, <span class="hljs-string">&quot;hello&quot;</span>}</span><br><span class="line">  h := sha256.New()</span><br><span class="line">  h.Write(binary.BigEndian.AppendUint32(<span class="hljs-literal">nil</span>, foo.A))</span><br><span class="line">  h.Write([]<span class="hljs-type">byte</span>(foo.B))</span><br><span class="line">  fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, h.Sum(<span class="hljs-literal">nil</span>))</span><br><span class="line">}</span><br></pre></div></div><p>Above is a simple example of digesting a struct <code>Foo</code> using SHA-256 algorithm. The scheme here for byte-sequence generation is straightforward: we first encode the uint32 value <code>foo.A</code> with a 4-byte big-endian format, then append all bytes of string value <code>foo.B</code> to the end and finalize the byte sequence.</p><h3 id="type-leakage-in-digesting">Type Leakage in Digesting</h3><p>One might easily derive such a digesting scheme, which, however, could sometimes encode more information than what we expect.</p><p>The problem lies in the type information leakage. For the field <code>foo.A</code>, we not only encode the numeric value <code>42</code>, the way we encode it also reveals the type information of the field – the 4-byte length, the big-endian format, altogether constitutes the byte sequence. If later we switch to <code>int64</code> or <code>float32</code>, but keep encoding by their bit representation, the digest would change accordingly.</p><p>Well… this might frustrate our users, as most of them are unaware of the distinction between ints and floats. Imagine they enquire our application with the same set of parameters, only to find out resources exist yesterday are gone now, owing to an upgrade at midnight that modifies a field type. What a nightmare.</p><h3 id="the-problem-3">The Problem</h3><p>Thereby we have the cohesive digesting problem: how to properly calculate digests for numeric values, such that their types are not leaked into the digested results?</p><p>As said, the problem is equivalent to finding an type-agnostic <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Injective_function">injective</a> that converts numeric values to byte sequences. To simplify the problem, this post focuses on handling <code>uint64</code> and <code>float64</code> types, as they are the most generic numeric types in Go. Towards this goal, there are two possible solutions:</p><ol><li>Convert <code>uint64</code> and <code>float64</code> to some “super type” <code>X</code>, then convert <code>X</code> to byte sequence.</li><li>Develop respective dedicated schemes for <code>uint64</code> and <code>float64</code>.</li></ol><h2 id="attempt-1-find-super-type-x">Attempt 1: Find “Super Type” X</h2><p>The first idea is natural – we purge the type information by introducing a “super type” <code>X</code>. This type should be able to cover all possible values of <code>uint64</code> and <code>float64</code>, and should be able to convert between them without loss of information.</p><p>Considering integers are a subset of real nunbers, we are going to investigate two candidates: <code>float64</code> and <code>big.Float</code>.</p><h3 id="float64-as-super-type"><code>float64</code> as Super Type</h3><p>One might easily think of <code>float64</code> as the super type, as it has a wide value range of $-10^{308} \sim 10^{308}$, enough to cover all possible <code>uint64</code> values, likely.</p><p>This is however not true. In fact, the distribution of <code>float64</code>s becomes “sparse” when the value is large, due to limited precision. Only integers $\leq 2^{53}$ can be represented exactly in <code>float64</code>, while others larger are rounded to the nearest representable value. The following code snippet demonstrates that large integers are not well preserved when coerced into <code>float64</code>:</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {</span><br><span class="line">  <span class="hljs-built_in">println</span>(<span class="hljs-type">float64</span>(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">53</span>) == <span class="hljs-type">float64</span>(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">53</span>+<span class="hljs-number">1</span>)) <span class="hljs-comment">// true</span></span><br><span class="line">}</span><br></pre></div></div><p>Obviously, <code>float64</code> must be crossed out from the list.</p><h3 id="bigfloat-as-super-type"><code>big.Float</code> as Super Type</h3><p>If <code>float64</code> is not suitable, how about types with more precision?</p><p><code>big.Float</code> is a handy type in Go that emulates arbitary precision floating-point numbers. One can tweak the precision with <code>(big.Float).SetPrec</code> to cover all possible <code>uint64</code> and <code>float64</code> values, then convert the value to a byte sequence.</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteUint64</span><span class="hljs-params">(v <span class="hljs-type">uint64</span>, h hash.Hash)</span></span> {</span><br><span class="line">  <span class="hljs-keyword">var</span> f big.Float</span><br><span class="line">  f.SetPrec(<span class="hljs-number">128</span>)</span><br><span class="line">  f.SetUint64(v)</span><br><span class="line">  b, _ := f.GobEncode()</span><br><span class="line">  h.Write(b)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteFloat64</span><span class="hljs-params">(v <span class="hljs-type">float64</span>, h hash.Hash)</span></span> {</span><br><span class="line">  <span class="hljs-keyword">var</span> f big.Float</span><br><span class="line">  f.SetPrec(<span class="hljs-number">128</span>)</span><br><span class="line">  f.SetFloat64(v)</span><br><span class="line">  b, _ := f.GobEncode()</span><br><span class="line">  h.Write(b)</span><br><span class="line">}</span><br></pre></div></div><p>Here we set the precision of <code>big.Float</code> to 128 bits, such that conversion from either <code>uint64</code> or <code>float64</code> to <code>big.Float</code> won’t be truncated. We then serialize the <code>big.Float</code> value using <code>GobEncode</code> method, which converts the value to a byte sequence.</p><p>This solution is neat, yet with several drawbacks:</p><ul><li><code>GobEncode</code> is designed for serialization, not digesting, with no guarantee for an injection between the values and the byte sequences (though it does for now).</li><li>It depends on the specific implementation of <code>GobEncode</code>, which might change in the future.</li><li>It cannot handle <code>Nan</code> values. <code>SetFloat64</code> would panic if the input is <code>Nan</code>. If that is a must, the solution is not applicable.</li><li>It is hard to replicate this solution in other languages. As <code>math/big</code> is unique to Go, other parts of the system written by different languages will struggle to align with this specific behavior.</li></ul><p>Of course, one could roll their own digesting scheme based on <code>big.Float</code>. I instead chose to develop a dedicated scheme for <code>uint64</code> and <code>float64</code>, as described in the next section.</p><h2 id="attempt-2-final-develop-dedicated-schemes">Attempt 2 (Final): Develop Dedicated Schemes</h2><p>To avoid the drawbacks of the first attempt, I have developed a customized scheme that cohesively maps number <code>x</code> to a 17-byte length sequence <code>b</code>. The scheme is designed as follows:</p><ul><li><code>b[0]</code> is the category flag. <code>b[0]</code> could be <code>0</code> (zero), <code>1</code> (positive), <code>2</code> (negative), <code>3</code> (positive inf), <code>4</code> (negative inf), <code>5</code> (Nan), indicating the characteristic of the digested number.</li><li>If x is zero or not finite (<code>b[0]</code> is <code>0, 3, 4, 5</code>),<ul><li>let <code>b[1:17]</code> be all zeros;</li></ul></li><li>If <code>x</code> is non-zero finite and <code>abs(x) &lt; 2^64</code>,<ul><li>let <code>b[1:9]</code> be the little-endian representation of <code>floor(abs(x))</code>,</li><li>let <code>b[9:17]</code> be the IEEE-754 representation of <code>frac(abs(x))</code>;</li></ul></li><li>If <code>x</code> is non-zero finite and <code>abs(x) &gt;= 2^64</code>,<ul><li><code>b[1:9]</code> being the IEEE-754 representation of <code>abs(x)</code>.</li><li>let <code>b[9:17]</code> be all zeros.</li></ul></li></ul><p>A reference implementation in Go is as follows (adapted from <a target="_blank" rel="noopener" href="https://github.com/hsfzxjy/sdxtra/blob/490e641684d1482df475ef57bd491459cf9f8880/internal/dig/helper/helper.go">sdxtra/…/helper.go</a>):</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="gk-section gk-zip zipped" data-gk-sid="BLOCK5.SEC1" data-gk-type="zip"><span class="line"><span class="hljs-keyword">const</span> (</span><br><span class="line">  zero     = <span class="hljs-number">0</span></span><br><span class="line">  positive = <span class="hljs-number">1</span></span><br><span class="line">  negative = <span class="hljs-number">2</span></span><br><span class="line">  inf      = <span class="hljs-number">3</span></span><br><span class="line">  neginf   = <span class="hljs-number">4</span></span><br><span class="line">  nan      = <span class="hljs-number">5</span></span><br><span class="line">)</span><br><span class="line"></span><br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteFloat64</span><span class="hljs-params">(x <span class="hljs-type">float64</span>, h hash.Hash)</span></span> {</span><br><span class="line">  buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">17</span>)</span><br><span class="line">  <span class="hljs-keyword">switch</span> {</span><br><span class="line">  <span class="hljs-keyword">case</span> x == <span class="hljs-number">0</span>:</span><br><span class="line">    buf[<span class="hljs-number">0</span>] = zero</span><br><span class="line">  <span class="hljs-keyword">case</span> math.IsInf(x, <span class="hljs-number">1</span>):</span><br><span class="line">    buf[<span class="hljs-number">0</span>] = inf</span><br><span class="line">  <span class="hljs-keyword">case</span> math.IsInf(x, <span class="hljs-number">-1</span>):</span><br><span class="line">    buf[<span class="hljs-number">0</span>] = neginf</span><br><span class="line">  <span class="hljs-keyword">case</span> math.IsNaN(x):</span><br><span class="line">    buf[<span class="hljs-number">0</span>] = nan</span><br><span class="line">  <span class="hljs-keyword">default</span>:</span><br><span class="line">    <span class="hljs-keyword">goto</span> NORMAL</span><br><span class="line">  }</span><br><span class="line">  h.Write(buf)</span><br><span class="line">  <span class="hljs-keyword">return</span></span><br><span class="line">NORMAL:</span><br><span class="line">  <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> {</span><br><span class="line">    buf[<span class="hljs-number">0</span>] = negative</span><br><span class="line">    x = -x</span><br><span class="line">  } <span class="hljs-keyword">else</span> {</span><br><span class="line">    buf[<span class="hljs-number">0</span>] = positive</span><br><span class="line">  }</span><br><span class="line">  i, f := math.Modf(x)</span><br><span class="line">  <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">64</span> {</span><br><span class="line">    binary.LittleEndian.PutUint64(buf[<span class="hljs-number">1</span>:], <span class="hljs-type">uint64</span>(i))</span><br><span class="line">  } <span class="hljs-keyword">else</span> {</span><br><span class="line">    binary.LittleEndian.PutUint64(buf[<span class="hljs-number">1</span>:], math.Float64bits(x))</span><br><span class="line">  }</span><br><span class="line">  binary.LittleEndian.PutUint64(buf[<span class="hljs-number">9</span>:], math.Float64bits(f))</span><br><span class="line">  h.Write(buf)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteUint64</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>, h hash.Hash)</span></span> {</span><br><span class="line">  buf := <span class="hljs-built_in">new</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">17</span>)</span><br><span class="line">  <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> {</span><br><span class="line">    buf[<span class="hljs-number">0</span>] = positive</span><br><span class="line">    binary.LittleEndian.PutUint64(buf[<span class="hljs-number">1</span>:], x)</span><br><span class="line">  }</span><br><span class="line">  h.Write(buf)</span><br><span class="line">}</span><br></pre></div></div><h2 id="discussion-on-the-scheme-and-implementation">Discussion on the Scheme and Implementation</h2><p>There are several points worth discussing about the final scheme and within the implementation:</p><h3 id="category-flag">Category Flag</h3><p>This scheme use the first byte to signify special values, which helps handle some quirky cases of IEEE-754 floating-point numbers, including:</p><ol><li><strong>Zeros</strong> IEEE-754 has both positive and negative zeros, which are different in bit representation but should be treated as the same value.</li><li><strong>Nans</strong> IEEE-754 has multiple representations for <code>Nan</code>, all of which should be treated as the same value during digesting.</li></ol><h3 id="short-path-for-uint64">Short-path for Uint64</h3><p>The scheme enables direct conversion from <code>uint64</code> to byte sequence, without the need to convert to <code>float64</code> first. This would save some computation and accelerate the digesting process.</p><h3 id="mathmodf"><code>math.Modf</code></h3><p>For some values, the scheme involves decomposition into their integral and fractional parts. This operation has several advantages:</p><ol><li>It forms an injection, that is, different <code>x</code> corresponds to different pair of <code>(floor(x), frac(x))</code>.</li><li>It can be implemented via bit operations in most programming languages, with promising efficiency and strong consistency.</li></ol><p>One can try to verify these properties by referring to IEEE-754 standards.</p><br><blockquote><p class="cc"><b>Author:</b> hsfzxjy.<br><b>Link:</b> <span class="cc-link"></span>.<br><b>License:</b> <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>.<br>All rights reserved by the author.<br>Commercial use of this post in any form is <b>NOT</b> permitted.<br>Non-commercial use of this post should be attributed with this block of text.</p></blockquote><script>!function(){var n=document.querySelector("span.cc-link");n&&(n.innerHTML='<a href="'+location.href+'">'+location.href+"</a>")}()</script></div><div class="post__tags"><a href="/tags/Go/">Go</a><a href="/tags/Algorithm/">Algorithm</a><a href="/tags/Hashing/">Hashing</a></div><div class="post-nav"><a href="/devcontainers-behind-jump-proxy/" class="pre">«如何在跳板机背后的服务器上使用 VS Code Remote - Containers</a><a href="/rust-place-expression/" class="next">Rust 中的隐匿概念 —— Place（位置）»</a></div><div id="disqus_thread"><div id="no-comment"><h2>OOPS!</h2><span>A comment box should be right here...</span><span>But it was gone due to network issues :-(</span><span>If you want to leave comments, make sure you have access to&nbsp;<a target="_blank" rel="noopener" href="https://disqus.com">disqus.com</a>.</span></div><script>var disqus_shortname="hsfzxjy",disqus_identifier="cohesive-digests-ints-and-floats/",disqus_title="Cohesive Digests for Ints and Floats",disqus_url="https://i.hsfzxjy.site/cohesive-digests-ints-and-floats/";!function(){var s=document.createElement("script");s.type="text/javascript",s.async=!0,s.defer=!0,s.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(s),s.onerror=function(){document.getElementById("no-comment").classList.add("show")}}()</script><script id="dsq-count-scr" src="//hsfzxjy.disqus.com/count.js" async defer></script></div></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"><div id="toc" lang="en" class="font__body"><div class="toc-toggler"></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#the-cohesive-digesting-problem"><span class="toc-number">1.</span> <span class="toc-text">The Cohesive Digesting Problem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#numeric-values-and-their-representations"><span class="toc-number">1.1.</span> <span class="toc-text">Numeric Values and Their Representations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#digesting"><span class="toc-number">1.2.</span> <span class="toc-text">Digesting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-leakage-in-digesting"><span class="toc-number">1.3.</span> <span class="toc-text">Type Leakage in Digesting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-problem-3"><span class="toc-number">1.4.</span> <span class="toc-text">The Problem</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attempt-1-find-super-type-x"><span class="toc-number">2.</span> <span class="toc-text">Attempt 1: Find “Super Type” X</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#float64-as-super-type"><span class="toc-number">2.1.</span> <span class="toc-text">float64 as Super Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bigfloat-as-super-type"><span class="toc-number">2.2.</span> <span class="toc-text">big.Float as Super Type</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attempt-2-final-develop-dedicated-schemes"><span class="toc-number">3.</span> <span class="toc-text">Attempt 2 (Final): Develop Dedicated Schemes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#discussion-on-the-scheme-and-implementation"><span class="toc-number">4.</span> <span class="toc-text">Discussion on the Scheme and Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#category-flag"><span class="toc-number">4.1.</span> <span class="toc-text">Category Flag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#short-path-for-uint64"><span class="toc-number">4.2.</span> <span class="toc-text">Short-path for Uint64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mathmodf"><span class="toc-number">4.3.</span> <span class="toc-text">math.Modf</span></a></li></ol></li></ol></div></div></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>