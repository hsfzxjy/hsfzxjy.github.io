{
  "version": 3,
  "sources": ["source/_js/src/util.ts", "source/_js/src/endec.ts"],
  "sourcesContent": ["export function docReady(body: () => void) {\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", body)\n  } else {\n    body()\n  }\n}\n\nexport function throttle(f: (...args: any[]) => void, time: number) {\n  let lastTime: null | number = null\n  return function (this: any) {\n    const current = Date.now()\n    if (lastTime !== null && current - lastTime < time) return\n    lastTime = current\n    // eslint-disable-next-line prefer-rest-params\n    return f.call(this, arguments)\n  }\n}\n\ntype _HTMLElement = HTMLElement & {\n  on: (eventName: string, callback: (...args: any[]) => any) => _HTMLElement\n  attr: (name: string, value: string) => _HTMLElement\n}\n\nexport function h(\n  tagName: string,\n  classes?: string[],\n  ...children: (HTMLElement | string | null | false | undefined)[]\n): _HTMLElement {\n  const $el = document.createElement(tagName) as ReturnType<typeof h>\n  if (classes) $el.classList.add(...classes)\n  for (const child of children) {\n    if (!child) continue\n    let $child: Node\n    if (typeof child === \"string\") $child = document.createTextNode(child)\n    else $child = child\n    $el.appendChild($child)\n  }\n  $el.on = (eventName, callback) => {\n    $el.addEventListener(eventName, callback)\n    return $el\n  }\n  $el.attr = (name, value) => {\n    $el.setAttribute(name, value)\n    return $el\n  }\n  return $el\n}\n\nexport function a(text: string, url: string): HTMLElement {\n  return h(\"a\", [], text).attr(\"target\", \"_blank\").attr(\"href\", url)\n}\n", "import { docReady } from \"./util\"\n\nenum State {\n  encrypted,\n  decrypting,\n  cleartext,\n}\n\nnamespace State {\n  export type Terminal = State.encrypted | State.cleartext\n}\n\ntype Kind = string\n\ntype Meta = {\n  kind: Kind\n  keySalt: Uint8Array\n  ivSalt: Uint8Array\n  content: Uint8Array\n}\n\nclass Nodes<T extends { $el: HTMLElement }> {\n  private store = new Map<Kind, T[]>()\n  private el2node = new Map<HTMLElement, T>()\n  get($el: HTMLElement): T | undefined {\n    return this.el2node.get($el)\n  }\n  put(kind: Kind, node: T) {\n    const arr = this.store.get(kind) ?? []\n    arr.push(node)\n    this.store.set(kind, arr)\n    this.el2node.set(node.$el, node)\n  }\n  mapKind<R>(kind: Kind, f: (node: T) => R): R[] {\n    return this.store.get(kind)!.map(f)\n  }\n  forEachAll(f: (node: T) => void): void {\n    for (const node of this.el2node.values()) {\n      f(node)\n    }\n  }\n}\n\nconst nodes = new Nodes<EncryptedNode>()\n\nclass EncryptedNode {\n  private state: State\n  private promise?: Promise<State.Terminal>\n  private meta: Meta\n  private listeners: cleartext.ListenerFn[]\n\n  static of($el: HTMLElement): EncryptedNode {\n    return nodes.get($el) ?? new EncryptedNode($el)\n  }\n\n  private constructor(public readonly $el: HTMLElement) {\n    if ($el.classList.contains(\"encrypted\")) {\n      this.state = State.encrypted\n      this.promise = Promise.resolve(State.cleartext)\n      this.meta = this.getMeta()\n    } else {\n      this.state = State.cleartext\n      this.meta = { kind: \"\" } as Meta\n    }\n    nodes.put(this.meta.kind, this)\n    this.listeners = cleartext.listeners.slice()\n    this.emitListeners()\n  }\n\n  addListener(fn: cleartext.ListenerFn) {\n    this.listeners.push(fn)\n    this.emitListeners()\n  }\n\n  private emitListeners() {\n    if (this.state !== State.cleartext) return\n    this.listeners.forEach((fn) => fn(this.$el))\n    this.listeners.length = 0\n  }\n\n  private getPassphase(kind?: string): string | null {\n    return window.localStorage.getItem(`passphase-${kind}`)\n  }\n\n  decrypt(opts: { kind?: string; passphase?: string }): Promise<State.Terminal> {\n    switch (this.state) {\n      case State.decrypting:\n        if (!this.promise) throw new Error(\"bad state\")\n        return this.promise.then((state) => {\n          if (state !== State.cleartext) return this.decrypt(opts)\n          return state\n        })\n      case State.cleartext:\n        return Promise.resolve(State.cleartext)\n    }\n    this.state = State.decrypting\n    const $cover = this.$el.querySelector(\".cover\")!\n    $cover.classList.remove(\"hide\")\n    const passphase = opts.passphase ?? this.getPassphase(opts.kind) ?? \"\"\n    this.promise = this._decrypt(passphase).then((state) => {\n      this.promise = undefined\n      this.state = state\n      this.emitListeners()\n      $cover.classList.add(\"hide\")\n      return state\n    })\n    return this.promise\n  }\n\n  private getMeta(): Meta {\n    const meta: Array<string> = []\n    for (const node of this.$el.childNodes) {\n      if (node.nodeType !== Node.TEXT_NODE) break\n      meta.push((node as Text).data)\n    }\n    const [kind, keySalt, ivSalt, content] = meta.join(\"\").split(\":\")\n\n    return {\n      kind,\n      keySalt: Base64.decode(keySalt),\n      ivSalt: Base64.decode(ivSalt),\n      content: Base64.decode(content),\n    }\n  }\n\n  private async _decrypt(passphase: string): Promise<State.Terminal> {\n    const { keySalt, ivSalt, content } = this.meta\n    const { $el } = this\n\n    const keyMaterial = await cryptoUtil.getKeyMaterial(passphase)\n    const decryptKey = await cryptoUtil.getDecryptKey(keyMaterial, keySalt)\n    const iv = await cryptoUtil.getIv(keyMaterial, ivSalt)\n\n    let result: ArrayBuffer\n    const algorithm = {\n      name: \"AES-CBC\",\n      iv: iv,\n    }\n    try {\n      result = await cryptoUtil.subtle.decrypt(algorithm, decryptKey, content.buffer)\n    } catch (e) {\n      console.warn(e)\n      return State.encrypted\n    }\n\n    const decoder = new TextDecoder()\n    const decoded = decoder.decode(result)\n\n    // check the prefix, if not then we can sure here is wrong password.\n    if (!decoded.startsWith(cryptoUtil.KNOWN_PREFIX)) {\n      return State.encrypted\n    }\n\n    $el.classList.remove(\"encrypted\")\n    $el.innerHTML = decoded.slice(cryptoUtil.KNOWN_PREFIX.length)\n    return State.cleartext\n  }\n\n  initForm() {\n    switch (this.state) {\n      case State.encrypted:\n        this._initForm()\n        return\n      case State.decrypting:\n        if (!this.promise) throw new Error(\"bad state\")\n        this.promise.then(() => this.initForm())\n        return\n    }\n  }\n\n  private _initForm() {\n    const { $el } = this\n    const { kind } = this.meta\n    const $input: HTMLInputElement = $el.querySelector(\"input[type=password]\")!\n    const handler = async (evt: Event) => {\n      evt.preventDefault()\n      const passphase = $input.value\n      const state = await this.decrypt({ passphase })\n      if (state === State.encrypted) {\n        alert(\"Incorrect passphase!\")\n        return\n      }\n      await Promise.all(nodes.mapKind(kind, (node) => node.decrypt({ passphase })))\n      window.localStorage.setItem(`passphase-${kind}`, passphase)\n      return false\n    }\n    $el.querySelector(\"button\")!.addEventListener(\"click\", handler)\n    $el.querySelector(\"form\")!.addEventListener(\"submit\", handler)\n\n    const $lgHeader = $el.querySelector(\"legend.header\")!\n    const $lgHint = $el.querySelector(\"legend.hint\")!\n    const hintText = $lgHeader.getAttribute(\"data-hint\")\n    $lgHeader.addEventListener(\"click\", () => {\n      $lgHint.innerHTML = \"HINT: \" + hintText\n    })\n  }\n}\n\nnamespace cleartext {\n  export type ListenerFn = (node: HTMLElement) => any\n  export const listeners: ListenerFn[] = []\n}\n\nwindow.ENDEC = {\n  decryptEager($el: HTMLElement, kind: Kind) {\n    EncryptedNode.of($el).decrypt({ kind })\n  },\n  onCleartext(fn: cleartext.ListenerFn) {\n    cleartext.listeners.push(fn)\n    nodes.forEachAll((node) => node.addListener(fn))\n  },\n}\n\ndocReady(() => {\n  document\n    .querySelectorAll(\"div.post__content\")\n    .forEach(($el) => EncryptedNode.of($el as HTMLElement).initForm())\n})\n\nnamespace Base64 {\n  const _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n\n  function removePaddingChars(input: string) {\n    const lkey = _keyStr.indexOf(input.charAt(input.length - 1))\n    if (lkey == 64) {\n      return input.substring(0, input.length - 1)\n    }\n    return input\n  }\n\n  export function decode(input: string, arrayBuffer: ArrayBuffer | null = null): Uint8Array {\n    //get last chars to see if are valid\n    input = removePaddingChars(input)\n    input = removePaddingChars(input)\n    const bytes = Math.trunc((input.length / 4) * 3)\n\n    let uarray: Uint8Array\n    let chr1: number, chr2: number, chr3: number\n    let enc1: number, enc2: number, enc3: number, enc4: number\n    let i = 0\n    let j = 0\n\n    if (arrayBuffer) uarray = new Uint8Array(arrayBuffer)\n    else uarray = new Uint8Array(bytes)\n\n    input = input.replace(/[^A-Za-z0-9+/=]/g, \"\")\n    for (i = 0; i < bytes; i += 3) {\n      // get the 3 octects in 4 ascii chars\n      enc1 = _keyStr.indexOf(input.charAt(j++))\n      enc2 = _keyStr.indexOf(input.charAt(j++))\n      enc3 = _keyStr.indexOf(input.charAt(j++))\n      enc4 = _keyStr.indexOf(input.charAt(j++))\n\n      chr1 = (enc1 << 2) | (enc2 >> 4)\n      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\n      chr3 = ((enc3 & 3) << 6) | enc4\n\n      uarray[i] = chr1\n      if (enc3 != 64) uarray[i + 1] = chr2\n      if (enc4 != 64) uarray[i + 2] = chr3\n    }\n\n    return uarray\n  }\n}\n\nnamespace cryptoUtil {\n  const cryptoObj: Crypto = window.crypto || window.msCrypto\n  export const subtle = cryptoObj.subtle || cryptoObj.webkitSubtle\n  export const KNOWN_PREFIX = \"<hexo-enhanced-encrytion></hexo-enhanced-encrytion>\"\n\n  export function getKeyMaterial(passphase: string) {\n    const encoder = new TextEncoder()\n    return subtle.importKey(\n      \"raw\",\n      encoder.encode(passphase),\n      {\n        name: \"PBKDF2\",\n      },\n      false,\n      [\"deriveKey\", \"deriveBits\"],\n    )\n  }\n\n  export function getDecryptKey(keyMaterial: CryptoKey, keySalt: Uint8Array) {\n    return subtle.deriveKey(\n      {\n        name: \"PBKDF2\",\n        hash: \"SHA-256\",\n        salt: keySalt.buffer,\n        iterations: 1024,\n      },\n      keyMaterial,\n      {\n        name: \"AES-CBC\",\n        length: 256,\n      },\n      true,\n      [\"decrypt\"],\n    )\n  }\n\n  export function getIv(keyMaterial: CryptoKey, ivSalt: Uint8Array) {\n    return subtle.deriveBits(\n      {\n        name: \"PBKDF2\",\n        hash: \"SHA-256\",\n        salt: ivSalt.buffer,\n        iterations: 512,\n      },\n      keyMaterial,\n      16 * 8,\n    )\n  }\n}\n"],
  "mappings": "mBAAO,SAASA,EAASC,EAAkB,CACrC,SAAS,aAAe,UAC1B,SAAS,iBAAiB,mBAAoBA,CAAI,EAElDA,EAAK,CAET,CCeA,IAAMC,EAAN,KAA4C,CAA5C,cACE,KAAQ,MAAQ,IAAI,IACpB,KAAQ,QAAU,IAAI,IACtB,IAAIC,EAAiC,CACnC,OAAO,KAAK,QAAQ,IAAIA,CAAG,CAC7B,CACA,IAAIC,EAAYC,EAAS,CACvB,IAAMC,EAAM,KAAK,MAAM,IAAIF,CAAI,GAAK,CAAC,EACrCE,EAAI,KAAKD,CAAI,EACb,KAAK,MAAM,IAAID,EAAME,CAAG,EACxB,KAAK,QAAQ,IAAID,EAAK,IAAKA,CAAI,CACjC,CACA,QAAWD,EAAYG,EAAwB,CAC7C,OAAO,KAAK,MAAM,IAAIH,CAAI,EAAG,IAAIG,CAAC,CACpC,CACA,WAAWA,EAA4B,CACrC,QAAWF,KAAQ,KAAK,QAAQ,OAAO,EACrCE,EAAEF,CAAI,CAEV,CACF,EAEMG,EAAQ,IAAIN,EAEZO,EAAN,MAAMC,CAAc,CAUV,YAA4BP,EAAkB,CAAlB,SAAAA,EAC9BA,EAAI,UAAU,SAAS,WAAW,GACpC,KAAK,MAAQ,EACb,KAAK,QAAU,QAAQ,QAAQ,CAAe,EAC9C,KAAK,KAAO,KAAK,QAAQ,IAEzB,KAAK,MAAQ,EACb,KAAK,KAAO,CAAE,KAAM,EAAG,GAEzBK,EAAM,IAAI,KAAK,KAAK,KAAM,IAAI,EAC9B,KAAK,UAAYG,EAAU,UAAU,MAAM,EAC3C,KAAK,cAAc,CACrB,CAhBA,OAAO,GAAGR,EAAiC,CACzC,OAAOK,EAAM,IAAIL,CAAG,GAAK,IAAIO,EAAcP,CAAG,CAChD,CAgBA,YAAYS,EAA0B,CACpC,KAAK,UAAU,KAAKA,CAAE,EACtB,KAAK,cAAc,CACrB,CAEQ,eAAgB,CAClB,KAAK,QAAU,IACnB,KAAK,UAAU,QAASA,GAAOA,EAAG,KAAK,GAAG,CAAC,EAC3C,KAAK,UAAU,OAAS,EAC1B,CAEQ,aAAaR,EAA8B,CACjD,OAAO,OAAO,aAAa,QAAQ,aAAaA,CAAI,EAAE,CACxD,CAEA,QAAQS,EAAsE,CAC5E,OAAQ,KAAK,MAAO,CAClB,IAAK,GACH,GAAI,CAAC,KAAK,QAAS,MAAM,IAAI,MAAM,WAAW,EAC9C,OAAO,KAAK,QAAQ,KAAMC,GACpBA,IAAU,EAAwB,KAAK,QAAQD,CAAI,EAChDC,CACR,EACH,IAAK,GACH,OAAO,QAAQ,QAAQ,CAAe,CAC1C,CACA,KAAK,MAAQ,EACb,IAAMC,EAAS,KAAK,IAAI,cAAc,QAAQ,EAC9CA,EAAO,UAAU,OAAO,MAAM,EAC9B,IAAMC,EAAYH,EAAK,WAAa,KAAK,aAAaA,EAAK,IAAI,GAAK,GACpE,YAAK,QAAU,KAAK,SAASG,CAAS,EAAE,KAAMF,IAC5C,KAAK,QAAU,OACf,KAAK,MAAQA,EACb,KAAK,cAAc,EACnBC,EAAO,UAAU,IAAI,MAAM,EACpBD,EACR,EACM,KAAK,OACd,CAEQ,SAAgB,CACtB,IAAMG,EAAsB,CAAC,EAC7B,QAAWZ,KAAQ,KAAK,IAAI,WAAY,CACtC,GAAIA,EAAK,WAAa,KAAK,UAAW,MACtCY,EAAK,KAAMZ,EAAc,IAAI,CAC/B,CACA,GAAM,CAACD,EAAMc,EAASC,EAAQC,CAAO,EAAIH,EAAK,KAAK,EAAE,EAAE,MAAM,GAAG,EAEhE,MAAO,CACL,KAAAb,EACA,QAASiB,EAAO,OAAOH,CAAO,EAC9B,OAAQG,EAAO,OAAOF,CAAM,EAC5B,QAASE,EAAO,OAAOD,CAAO,CAChC,CACF,CAEA,MAAc,SAASJ,EAA4C,CACjE,GAAM,CAAE,QAAAE,EAAS,OAAAC,EAAQ,QAAAC,CAAQ,EAAI,KAAK,KACpC,CAAE,IAAAjB,CAAI,EAAI,KAEVmB,EAAc,MAAMC,EAAW,eAAeP,CAAS,EACvDQ,EAAa,MAAMD,EAAW,cAAcD,EAAaJ,CAAO,EAChEO,EAAK,MAAMF,EAAW,MAAMD,EAAaH,CAAM,EAEjDO,EACEC,EAAY,CAChB,KAAM,UACN,GAAIF,CACN,EACA,GAAI,CACFC,EAAS,MAAMH,EAAW,OAAO,QAAQI,EAAWH,EAAYJ,EAAQ,MAAM,CAChF,OAASQ,EAAG,CACV,eAAQ,KAAKA,CAAC,EACP,CACT,CAGA,IAAMC,EADU,IAAI,YAAY,EACR,OAAOH,CAAM,EAGrC,OAAKG,EAAQ,WAAWN,EAAW,YAAY,GAI/CpB,EAAI,UAAU,OAAO,WAAW,EAChCA,EAAI,UAAY0B,EAAQ,MAAMN,EAAW,aAAa,MAAM,EACrD,GALE,CAMX,CAEA,UAAW,CACT,OAAQ,KAAK,MAAO,CAClB,IAAK,GACH,KAAK,UAAU,EACf,OACF,IAAK,GACH,GAAI,CAAC,KAAK,QAAS,MAAM,IAAI,MAAM,WAAW,EAC9C,KAAK,QAAQ,KAAK,IAAM,KAAK,SAAS,CAAC,EACvC,MACJ,CACF,CAEQ,WAAY,CAClB,GAAM,CAAE,IAAApB,CAAI,EAAI,KACV,CAAE,KAAAC,CAAK,EAAI,KAAK,KAChB0B,EAA2B3B,EAAI,cAAc,sBAAsB,EACnE4B,EAAU,MAAOC,GAAe,CACpCA,EAAI,eAAe,EACnB,IAAMhB,EAAYc,EAAO,MAEzB,GADc,MAAM,KAAK,QAAQ,CAAE,UAAAd,CAAU,CAAC,IAChC,EAAiB,CAC7B,MAAM,sBAAsB,EAC5B,MACF,CACA,aAAM,QAAQ,IAAIR,EAAM,QAAQJ,EAAOC,GAASA,EAAK,QAAQ,CAAE,UAAAW,CAAU,CAAC,CAAC,CAAC,EAC5E,OAAO,aAAa,QAAQ,aAAaZ,CAAI,GAAIY,CAAS,EACnD,EACT,EACAb,EAAI,cAAc,QAAQ,EAAG,iBAAiB,QAAS4B,CAAO,EAC9D5B,EAAI,cAAc,MAAM,EAAG,iBAAiB,SAAU4B,CAAO,EAE7D,IAAME,EAAY9B,EAAI,cAAc,eAAe,EAC7C+B,EAAU/B,EAAI,cAAc,aAAa,EACzCgC,EAAWF,EAAU,aAAa,WAAW,EACnDA,EAAU,iBAAiB,QAAS,IAAM,CACxCC,EAAQ,UAAY,SAAWC,CACjC,CAAC,CACH,CACF,EAEUxB,MAEKA,EAAA,UAA0B,CAAC,GAFhCA,IAAA,IAKV,OAAO,MAAQ,CACb,aAAaR,EAAkBC,EAAY,CACzCK,EAAc,GAAGN,CAAG,EAAE,QAAQ,CAAE,KAAAC,CAAK,CAAC,CACxC,EACA,YAAYQ,EAA0B,CACpCD,EAAU,UAAU,KAAKC,CAAE,EAC3BJ,EAAM,WAAYH,GAASA,EAAK,YAAYO,CAAE,CAAC,CACjD,CACF,EAEAwB,EAAS,IAAM,CACb,SACG,iBAAiB,mBAAmB,EACpC,QAASjC,GAAQM,EAAc,GAAGN,CAAkB,EAAE,SAAS,CAAC,CACrE,CAAC,EAED,IAAUkB,MAAV,CACE,IAAMgB,EAAU,oEAEhB,SAASC,EAAmBC,EAAe,CAEzC,OADaF,EAAQ,QAAQE,EAAM,OAAOA,EAAM,OAAS,CAAC,CAAC,GAC/C,GACHA,EAAM,UAAU,EAAGA,EAAM,OAAS,CAAC,EAErCA,CACT,CAEO,SAASC,EAAOD,EAAeE,EAAkC,KAAkB,CAExFF,EAAQD,EAAmBC,CAAK,EAChCA,EAAQD,EAAmBC,CAAK,EAChC,IAAMG,EAAQ,KAAK,MAAOH,EAAM,OAAS,EAAK,CAAC,EAE3CI,EACAC,EAAcC,EAAcC,EAC5BC,EAAcC,EAAcC,EAAcC,EAC1CC,EAAI,EACJC,EAAI,EAMR,IAJIX,EAAaE,EAAS,IAAI,WAAWF,CAAW,EAC/CE,EAAS,IAAI,WAAWD,CAAK,EAElCH,EAAQA,EAAM,QAAQ,mBAAoB,EAAE,EACvCY,EAAI,EAAGA,EAAIT,EAAOS,GAAK,EAE1BJ,EAAOV,EAAQ,QAAQE,EAAM,OAAOa,GAAG,CAAC,EACxCJ,EAAOX,EAAQ,QAAQE,EAAM,OAAOa,GAAG,CAAC,EACxCH,EAAOZ,EAAQ,QAAQE,EAAM,OAAOa,GAAG,CAAC,EACxCF,EAAOb,EAAQ,QAAQE,EAAM,OAAOa,GAAG,CAAC,EAExCR,EAAQG,GAAQ,EAAMC,GAAQ,EAC9BH,GAASG,EAAO,KAAO,EAAMC,GAAQ,EACrCH,GAASG,EAAO,IAAM,EAAKC,EAE3BP,EAAOQ,CAAC,EAAIP,EACRK,GAAQ,KAAIN,EAAOQ,EAAI,CAAC,EAAIN,GAC5BK,GAAQ,KAAIP,EAAOQ,EAAI,CAAC,EAAIL,GAGlC,OAAOH,CACT,CAjCOtB,EAAS,OAAAmB,IAXRnB,IAAA,IA+CV,IAAUE,MAAV,CACE,IAAM8B,EAAoB,OAAO,QAAU,OAAO,SACrC9B,EAAA,OAAS8B,EAAU,QAAUA,EAAU,aACvC9B,EAAA,aAAe,sDAErB,SAAS+B,EAAetC,EAAmB,CAChD,IAAMuC,EAAU,IAAI,YACpB,OAAOhC,EAAA,OAAO,UACZ,MACAgC,EAAQ,OAAOvC,CAAS,EACxB,CACE,KAAM,QACR,EACA,GACA,CAAC,YAAa,YAAY,CAC5B,CACF,CAXOO,EAAS,eAAA+B,EAaT,SAASE,EAAclC,EAAwBJ,EAAqB,CACzE,OAAOK,EAAA,OAAO,UACZ,CACE,KAAM,SACN,KAAM,UACN,KAAML,EAAQ,OACd,WAAY,IACd,EACAI,EACA,CACE,KAAM,UACN,OAAQ,GACV,EACA,GACA,CAAC,SAAS,CACZ,CACF,CAhBOC,EAAS,cAAAiC,EAkBT,SAASC,EAAMnC,EAAwBH,EAAoB,CAChE,OAAOI,EAAA,OAAO,WACZ,CACE,KAAM,SACN,KAAM,UACN,KAAMJ,EAAO,OACb,WAAY,GACd,EACAG,EACA,GAAK,CACP,CACF,CAXOC,EAAS,MAAAkC,IApCRlC,IAAA",
  "names": ["docReady", "body", "Nodes", "$el", "kind", "node", "arr", "f", "nodes", "EncryptedNode", "_EncryptedNode", "cleartext", "fn", "opts", "state", "$cover", "passphase", "meta", "keySalt", "ivSalt", "content", "Base64", "keyMaterial", "cryptoUtil", "decryptKey", "iv", "result", "algorithm", "e", "decoded", "$input", "handler", "evt", "$lgHeader", "$lgHint", "hintText", "docReady", "_keyStr", "removePaddingChars", "input", "decode", "arrayBuffer", "bytes", "uarray", "chr1", "chr2", "chr3", "enc1", "enc2", "enc3", "enc4", "i", "j", "cryptoObj", "getKeyMaterial", "encoder", "getDecryptKey", "getIv"]
}
