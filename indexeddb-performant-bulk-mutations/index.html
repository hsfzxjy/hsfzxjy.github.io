<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script>(()=>{let r="/cnfonts.js",n=document,e=n.createElement("link");e.rel="stylesheet",e.href="/fontchan/jBKCaHQX.css",e.blocking="render",e.onerror=()=>{var e=n.createElement("script");e.src=r,e.onload=()=>$fontchan.injectCss(),n.head.appendChild(e)},n.head.appendChild(e),"serviceWorker"in navigator&&navigator.serviceWorker.register(r,{scope:"/"}).then(e=>e.update())})()</script><title>Performant Bulk Mutations in IndexedDB</title><meta itemprop="title" content="Performant Bulk Mutations in IndexedDB - hsfzxjy 的博客"><meta itemprop="og:title" content="Performant Bulk Mutations in IndexedDB - hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="description" content="IndexedDB seems to be inefficient when working on bulk mu..."><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div lang="en" class="post post-page"><h1 lang="en" class="post__title">Performant Bulk Mutations in IndexedDB</h1><div class="post__meta font__ui">2021-05-30 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div class="post__content font__body"><p>IndexedDB seems to be inefficient when working on bulk mutations, such as dumping a huge list of items into an object store – at least I think so at the first sight on the MDN docs. It provides no explicit API for the job as SQL does <sup id="fnref:1"><a href="#fn:1">1</a></sup>, so all we can do is to loop from client side, which cannot benefit from database internal optimization (if there’s any). The mutation requests, in addition, appear to be spawned sequentially – the tutorial recommends a paradigm to raise a request within the <code>success</code> event callback of the previous request, which is in fact a sequential execution. Such code will be definitely slow.</p><p>We may conduct a quick benchmark on the above approach:</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line">;(<span class="hljs-keyword">async</span> () =&gt; {</span><br><span class="line">    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {</span><br><span class="line">        <span class="hljs-keyword">const</span> r = indexedDB.<span class="hljs-title function_">deleteDatabase</span>(<span class="hljs-string">&quot;test&quot;</span>)</span><br><span class="line">        r.<span class="hljs-property">onsuccess</span> = r.<span class="hljs-property">onerror</span> = resolve</span><br><span class="line">    })</span><br><span class="line">    <span class="hljs-keyword">const</span> items = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">100000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> ({ <span class="hljs-attr">id</span>: i }))</span><br><span class="line">    <span class="hljs-keyword">const</span> store = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {</span><br><span class="line">        indexedDB.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">1</span>).<span class="hljs-property">onupgradeneeded</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {</span><br><span class="line">            <span class="hljs-keyword">const</span> db = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span></span><br><span class="line">            <span class="hljs-keyword">const</span> store = db.<span class="hljs-title function_">createObjectStore</span>(<span class="hljs-string">&quot;store&quot;</span>, { <span class="hljs-attr">keyPath</span>: <span class="hljs-string">&quot;id&quot;</span> })</span><br><span class="line">            store.<span class="hljs-title function_">createIndex</span>(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>)</span><br><span class="line">            <span class="hljs-title function_">resolve</span>(store)</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;bulkAdd&quot;</span>)</span><br><span class="line">    <span class="hljs-keyword">await</span> <span class="hljs-title function_">bulkAdd</span>(store, items)</span><br><span class="line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;bulkAdd&quot;</span>)</span><br><span class="line">})()</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bulkAdd</span>(<span class="hljs-params">store, items</span>) {</span><br><span class="line">    <span class="hljs-keyword">const</span> failures = []</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {</span><br><span class="line">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_perform</span>(<span class="hljs-params">idx</span>) {</span><br><span class="line">            <span class="hljs-keyword">const</span> req = store.<span class="hljs-title function_">add</span>(items[idx])</span><br><span class="line">            req.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {</span><br><span class="line">                <span class="hljs-keyword">if</span> (idx === items.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) <span class="hljs-title function_">resolve</span>(failures)</span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-title function_">_perform</span>(idx + <span class="hljs-number">1</span>)</span><br><span class="line">            }</span><br><span class="line">            req.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {</span><br><span class="line">                failures.<span class="hljs-title function_">push</span>(items[idx].<span class="hljs-property">id</span>)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-title function_">_perform</span>(<span class="hljs-number">0</span>)</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></div></div><p class="par">Practically, we concern more about failed records than the ones inserted successfully. We thus take down only the indices of those records, which improves the efficiency at least a little bit.</p><p>The timing is rather unstable, but on average, it takes 30~40 seconds to insert 100k records or 2000~3000 records per second, which is not promising.</p><p>So why should the requests be aranged like this? I found a statement in the <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction/commit">MDN docs</a>:</p><blockquote><p class="noindent">Note that <code>commit()</code> doesn’t normally have to be called — a transaction will automatically commit when all outstanding requests have been satisfied and no new requests have been made. <code>commit()</code> can be used to start the commit process without waiting for events from outstanding requests to be dispatched.</p></blockquote><p class="par">Unlike many other databases, IndexedDB transaction implicitly commits changes, at the instant when <em>all callbacks of previous requests are invoked (and returned), and there’s no more new requests</em>. Hence a later request must be queued before the previous one completed or at the time of its <code>success</code> or <code>error</code> callbacks executing, otherwise the transaction will be closed. Raising new requests in callbacks is safe, but not very efficient.</p><p>Can we make it better? Absolutely. We can perform the mutations “concurrently”, that is, raising all requests at a time.</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bulkAdd</span>(<span class="hljs-params">store, items</span>) {</span><br><span class="line">    <span class="hljs-keyword">const</span> failures = []</span><br><span class="line">    <span class="hljs-keyword">const</span> promises = []</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> items) {</span><br><span class="line">        <span class="hljs-keyword">const</span> req = store.<span class="hljs-title function_">add</span>(item)</span><br><span class="line">        promises.<span class="hljs-title function_">push</span>(</span><br><span class="line">            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {</span><br><span class="line">                req.<span class="hljs-property">onsuccess</span> = resolve</span><br><span class="line">                req.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> {</span><br><span class="line">                    failures.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">id</span>)</span><br><span class="line">                    <span class="hljs-title function_">resolve</span>()</span><br><span class="line">                }</span><br><span class="line">            })</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> failures)</span><br><span class="line">}</span><br></pre></div></div><p class="par">The execution time is ~15 seconds now, around 2x faster than the first implementation.</p><p>But wait … is this implementation reliable? Is it possible that at some point all previous requests are completed, but there’s still new requests to be raised? The answer is yes, but the transaction won’t be closed for this, since <em>the callbacks have not yet been invoked</em>.</p><p>Recall that Javascript has a single-threaded execution model. All callbacks reside in a queue and are executed sequentially when the thread is idle. The mechanism ensures that mutation request callbacks won’t be executed before all requests raised, as the raising operations and callbacks are executed in the same thread. So even if some requests complete early, their <code>success</code> or <code>error</code> callbacks will still be scheduled after all requests are created. The implementation is definitely reliable.</p><p>Now we have reached a speed of ~6000 records per second. Can we make it even better? Of course yes!</p><p>If you read the code carefully, you may notice that <code>req.onsuccess</code> is doing something vain. A <code>resolve</code> function is passed as <code>success</code> callback, just to inform the timing of request completion. However, we are not interested about the timing of each request completion. Instead, only the timing of last completion is important.</p><p>We may expect the callbacks be executed in the order they are raised. They do actually. But weirdly, the MDN docs does not advertise such point, and we have to dive into the <a target="_blank" rel="noopener" href="https://www.w3.org/TR/IndexedDB-3/">IndexedDB Specification</a> to seek the clues. After struggling against the verbose documentation, I catch something at section <a target="_blank" rel="noopener" href="https://www.w3.org/TR/IndexedDB-3/#async-execute-request">Asynchronously executing a request</a>. Briefly speaking,</p><ul><li>A request won’t be processed before previous requests’ <code>processed</code> flags be set. <sup id="fnref:2"><a href="#fn:2">2</a></sup></li><li>A request will immediately queue a task after its <code>processed</code> flag set, within which the callbacks are invoked. <sup id="fnref:3"><a href="#fn:3">3</a></sup></li></ul><p class="par">which means, the tasks firing events will be ordered as their corresponding requests. Consequently, we might be able to know the timing of all completions, by only listening to the <code>success</code>/<code>error</code> events of the last request:</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bulkAdd</span>(<span class="hljs-params">store, items</span>) {</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {</span><br><span class="line">        <span class="hljs-keyword">const</span> failures = []</span><br><span class="line">        <span class="hljs-keyword">let</span> req, item</span><br><span class="line">        <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">of</span> items) {</span><br><span class="line">            req = store.<span class="hljs-title function_">add</span>(item)</span><br><span class="line">            req.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> failures.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">id</span>)</span><br><span class="line">        }</span><br><span class="line">        req.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(failures)</span><br><span class="line">        req.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> {</span><br><span class="line">            failures.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">id</span>)</span><br><span class="line">            <span class="hljs-title function_">resolve</span>(failures)</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></div></div><p class="par">This time we have a better running time of 10~12 seconds, which is 8000~10000 records per second, nearly 4x faster than the first implementation! The table below summarizes how the performance get improved along the way:</p><table><thead><tr><th>impl.</th><th>time(s)</th><th>speed(r/s)</th></tr></thead><tbody><tr><td>sequential</td><td>30~40</td><td>2000~3000</td></tr><tr><td>concurrent</td><td>~15</td><td>~6000</td></tr><tr><td>concurrent+less listeners</td><td>10~12</td><td>8000~10000</td></tr></tbody></table><p>The last implementation is also how <a target="_blank" rel="noopener" href="https://dexie.org/">Dexie.js</a> does for efficient bulk mutations. The library makes a statement on its homepage:</p><blockquote><p class="par">Its bulk operations utilize an often-overlooked feature in IndexedDB, ignoring success callbacks when possible.</p></blockquote><h2 id="references-6">References</h2><ul><li><a target="_blank" rel="noopener" href="https://www.w3.org/TR/IndexedDB-3/#async-execute-request">Indexed Database API 3.0 - 5.6: Asynchronously executing a request</a></li><li><a target="_blank" rel="noopener" href="https://github.com/dfahlander/Dexie.js/blob/76ab6ac4bd/src/dbcore/dbcore-indexeddb.ts#L118">Dexie.js/src/dbcore/dbcore-indexeddb.ts Line 118</a></li><li><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/52555073/3278171">StackOverflow - Optimized Bulk (Chunk) Upload Of Objects Into IndexedDB</a></li></ul><div class="footnotes"><ol><li class="footnote" id="fn:1">you may add as many records after the <code>INSERT INTO ... VALUES</code> clause</li><li class="footnote" id="fn:2">See <em>5.6.5.1 Wait until request is the first item in transaction’s request list that is not processed.</em></li><li class="footnote" id="fn:3">See <em>5.6.5.6: Queue a task to run these steps</em></li></ol></div><br><blockquote><p class="cc"><b>Author:</b> hsfzxjy.<br><b>Link:</b> <span class="cc-link"></span>.<br><b>License:</b> <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>.<br>All rights reserved by the author.<br>Commercial use of this post in any form is <b>NOT</b> permitted.<br>Non-commercial use of this post should be attributed with this block of text.</p></blockquote><script>!function(){var n=document.querySelector("span.cc-link");n&&(n.innerHTML='<a href="'+location.href+'">'+location.href+"</a>")}()</script></div><div class="post__tags"><a href="/tags/Web/">Web</a><a href="/tags/IndexedDB/">IndexedDB</a></div><div class="post-nav"><a href="/where-does-the-randomness-of-cuda-kernels-come-from/" class="pre">«Demystify the randomness in CUDA kernels</a><a href="/cython-auto-reload/" class="next">Auto Rebuild .pyx Files with pyximport»</a></div><div id="disqus_thread"><div id="no-comment"><h2>OOPS!</h2><span>A comment box should be right here...</span><span>But it was gone due to network issues :-(</span><span>If you want to leave comments, make sure you have access to&nbsp;<a target="_blank" rel="noopener" href="https://disqus.com">disqus.com</a>.</span></div><script>var disqus_shortname="hsfzxjy",disqus_identifier="indexeddb-performant-bulk-mutations/",disqus_title="Performant Bulk Mutations in IndexedDB",disqus_url="https://i.hsfzxjy.site/indexeddb-performant-bulk-mutations/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.defer=!0,e.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(e),e.onerror=function(){document.getElementById("no-comment").classList.add("show")}}()</script><script id="dsq-count-scr" src="//hsfzxjy.disqus.com/count.js" async defer></script></div></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"><div id="toc" lang="en" class="font__body"><div class="toc-toggler"></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#references-6"><span class="toc-number">1.</span> <span class="toc-text">References</span></a></li></ol></div></div></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>