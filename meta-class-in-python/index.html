<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><title>Python“黑魔法”之 Meta Classes</title><meta itemprop="title" content="Python“黑魔法”之 Meta Classes - hsfzxjy 的博客"><meta itemprop="og:title" content="Python“黑魔法”之 Meta Classes - hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="description" content="接触过 Django 的同学都应该十分熟悉它的 ORM 系统。对于 python 新手而言，这是一项几乎可以被称作..."><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div lang="zh" class="post post-page"><h1 lang="zh" class="post__title">Python“黑魔法”之 Meta Classes</h1><div class="post__meta font__ui">2016-02-10 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div class="post__content font__body"><p>接触过 Django 的同学都应该十分熟悉它的 ORM 系统。对于 python 新手而言，这是一项几乎可以被称作“黑科技”的特性：只要你在 <code>models.py</code> 中随便定义一个 <code>Model</code> 的子类，Django 便可以：</p><ul><li>获取它的字段定义，并转换成表结构</li><li>读取 <code>Meta</code> 内部类，并转化成相应的配置信息。对于特殊的 <code>Model</code>（如 <code>abstract</code>、<code>proxy</code>），还要进行相应的转换</li><li>为没有定义 <code>objects</code> 的 <code>Model</code> 加上一个默认的 <code>Manager</code></li></ul><p>开发之余，我也曾脑补过其背后的原理。曾经，我认为是这样的：</p><blockquote><p class="noindent">启动时，遍历<code>models.py</code>中的所有属性，找到<code>Model</code>的子类，并对其进行上述的修改。</p></blockquote><p>当初，我还以为自己触碰到了真理，并曾将其应用到实际生产中——为 SAE 的 KVDB 写了一个类 ORM 系统。然而在实现的过程中，我明显感受到了这种方法的丑陋，而且性能并不出色（因为要遍历所有的定义模块）。</p><p>那么事实上，Django 是怎么实现的呢？</p><blockquote><p>自古以来我们制造东西的方法都是“自上而下”的，是用切削、分割、组合的方法来制造。然而，生命是自下而上地，自发地建造起来的，这个过程极为低廉。 <cite>——王晋康《水星播种》</cite></p></blockquote><p>这句话揭示了生命的神奇所在：<strong>真正的生命都是由基本物质自发构成的，而非造物主流水线式的加工</strong>。</p><p>那么，如果 类 也有生命的话，对它自己的修饰就不应该由调用者来完成，而应该是<strong>自发的</strong>。</p><p>幸而，python 提供了造物主的接口——这便是 Meta Classes，或者称为“元类”。</p><h2 id="元类-是什么？">元类 是什么？</h2><p>简单说：元类就是<strong>类的类</strong>。</p><p>首先，要有一个概念：</p><h3 id="python-中，一切都是对象。">python 中，一切都是对象。</h3><p>没错，一切，包括 类 本身。</p><p>既然，类 是 对象，对象 是 类的实例，那么——类 也应该有 类 才对。</p><h3 id="类的类：type">类的类：type</h3><p>在 python 中，我们可以用<code>type</code>检测一个对象的类，如：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-built_in">print</span> <span class="hljs-built_in">type</span>(<span class="hljs-number">1</span>) <span class="hljs-comment"># &lt;type &#x27;int&#x27;&gt;</span></span><br></pre></div></div><p>如果对一个类操作呢？</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-built_in">print</span> <span class="hljs-built_in">type</span>(<span class="hljs-built_in">int</span>) <span class="hljs-comment"># &lt;type &#x27;type&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">print</span> <span class="hljs-built_in">type</span>(MyClass) <span class="hljs-comment"># &lt;type &#x27;type&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">print</span> <span class="hljs-built_in">type</span>(<span class="hljs-built_in">type</span>) <span class="hljs-comment"># &lt;type &#x27;type&#x27;&gt;</span></span><br></pre></div></div><p>这说明：<code>type</code>其实是一个类型，所有类——包括<code>type</code>自己——的类都是<code>type</code>。</p><h3 id="type-简介">type 简介</h3><p>从 <a target="_blank" rel="noopener" href="https://docs.python.org/2/library/functions.html#type">官方文档</a> 中，我们可以知道：</p><ul><li><p>和 <code>dict</code> 类似，<code>type</code> 也是一个工厂构造函数，调用其将返回 一个<code>type</code>类型的实例（即 类）。</p></li><li><p><code>type</code> 有两个重载版本：</p><ul><li><code>type(object)</code>，即我们最常用的版本。</li><li><code>type(name, bases, dict)</code>，一个更强大的版本。通过指定 类名称（<code>name</code>）、父类列表（<code>bases</code>）和 属性字典（<code>dict</code>）动态合成一个类。</li></ul><p>下面两个语句等价：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-title class_ inherited__">int</span>):</span><br><span class="line"></span><br><span class="line">   name = <span class="hljs-string">&#x27;my integer&#x27;</span></span><br><span class="line"></span><br><span class="line">   <span class="hljs-keyword">def</span> <span class="hljs-title function_">increase</span>(<span class="hljs-params">self, num</span>):</span><br><span class="line">       <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line"> <span class="hljs-comment"># -------------------</span></span><br><span class="line"></span><br><span class="line"> Integer = <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;Integer&#x27;</span>, (<span class="hljs-built_in">int</span>, ), {</span><br><span class="line">   <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;my integer&#x27;</span>,</span><br><span class="line">   <span class="hljs-string">&#x27;increase&#x27;</span>: <span class="hljs-keyword">lambda</span> self, num: \</span><br><span class="line">                   num + <span class="hljs-number">1</span>    <span class="hljs-comment"># 很酷的写法，不是么</span></span><br><span class="line"> })</span><br></pre></div></div></li></ul><p>也就是说：<strong>类的定义过程，其实是<code>type</code>类型实例化的过程</strong>。</p><p><strong>然而这和修饰一个已定义的类有什么关系呢？</strong></p><p>当然有啦～既然“类的定义”就是“<code>type</code>类型的初始化过程”，那其中必定会调用到<code>type</code>的构造函数 (<code>__new__()</code> 或 <code>__init__()</code>)。只要我们继承 <code>type</code>类 并修改其 <code>__new__</code>函数，在这里面动手脚就可以啦。</p><p>接下来我们将通过一个栗子感受 python 的黑魔法，不过在此之前，我们要先了解一个语法糖。</p><h3 id="__metaclass__-属性">__metaclass__ 属性</h3><p>有没觉得上面第二段示例有些鬼畜呢？它勒令程序员将类的成员写成一个字典，简直是反人类。如果我们真的是要通过修改 元类 来改变 类 的行为的话，似乎就必须采用这种方法了～～简直可怕～～</p><p>好在，<a target="_blank" rel="noopener" href="https://docs.python.org/2/reference/datamodel.html?#__metaclass__">python 2.2</a> 时引进了一个语法糖：<code>__metaclass__</code>。</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-title class_ inherited__">int</span>):</span><br><span class="line"></span><br><span class="line">    __metaclass__ = IntMeta</span><br></pre></div></div><p>现在将会等价于：</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line">Integer = IntMeta(<span class="hljs-string">&#x27;Integer&#x27;</span>, (<span class="hljs-built_in">int</span>, ), {})</span><br></pre></div></div><p>由此一来，我们在使用传统类定义的同时，也可以使用元类啦。</p><h2 id="栗子：子类净化器">栗子：子类净化器</h2><blockquote><h4 id="需求描述">需求描述</h4><p>你是一个有语言洁癖的开发者，平时容不得别人讲一句脏话，在开发时也是如此。现在，你写出了一个非常棒的框架，并马上要将它公之于众了。不过，你的强迫症又犯了：如果你的使用者在代码中写满了脏话，怎么办？岂不是玷污了自己的纯洁？</p></blockquote><p>假如你就是这个丧心病狂的开发者，你会怎么做？</p><p>在知道元类之前，你可能会无从下手。不过，这个问题你可以用 元类 轻松解决——只要在类定义时过滤掉不干净的字眼就好了（百度贴吧的干活～～）。</p><p>我们的元类看起来会是这样的：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line"></span><br><span class="line">sensitive_words_list = [<span class="hljs-string">&#x27;asshole&#x27;</span>, <span class="hljs-string">&#x27;fuck&#x27;</span>, <span class="hljs-string">&#x27;shit&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">detect_sensitive_words</span>(<span class="hljs-params">string</span>):</span><br><span class="line">    <span class="hljs-string">&#x27;&#x27;&#x27;检测敏感词汇&#x27;&#x27;&#x27;</span></span><br><span class="line">    words_detected = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> word: word <span class="hljs-keyword">in</span> string.lower(), sensitive_words_list)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> words_detected:</span><br><span class="line">        <span class="hljs-keyword">raise</span> NameError(<span class="hljs-string">&#x27;Sensitive words {0} detected in the string &quot;{1}&quot;.&#x27;</span> \</span><br><span class="line">            .<span class="hljs-built_in">format</span>(</span><br><span class="line">                <span class="hljs-string">&#x27;, &#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> s: <span class="hljs-string">&#x27;&quot;%s&quot;&#x27;</span> % s, words_detected)),</span><br><span class="line">                string</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CleanerMeta</span>(<span class="hljs-title class_ inherited__">type</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, class_name, bases, attrs</span>):</span><br><span class="line">        detect_sensitive_words(class_name) <span class="hljs-comment"># 检查类名</span></span><br><span class="line">        <span class="hljs-built_in">map</span>(detect_sensitive_words, attrs.iterkeys()) <span class="hljs-comment"># 检查属性名</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Well done! You are a polite coder!&quot;</span> <span class="hljs-comment"># 如无异常，输出祝贺消息</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(CleanerMeta, cls).__new__(cls, class_name, bases, attrs)</span><br><span class="line">        <span class="hljs-comment"># 重要！这行一定不能漏！！这回调用内建的类构造器来构造类，否则定义好的类将会变成 None</span></span><br><span class="line"></span><br></pre></div></div><p>现在，只需这样定义基类：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">APIBase</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    __metaclass__ = CleanerMeta</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># ...</span></span><br></pre></div></div><p>那么所有 <code>APIBase</code> 的派生类都会接受安全审查（奸笑～～）：</p><div class="gk-code hljs" data-gk-id="BLOCK8"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImAGoodBoy</span>(<span class="hljs-title class_ inherited__">APIBase</span>):</span><br><span class="line"></span><br><span class="line">    a_polite_attribute = <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># [Output] Well done! You are a polite coder!</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FuckMyBoss</span>(<span class="hljs-title class_ inherited__">APIBase</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># [Output] NameError: Sensitive words &quot;fuck&quot; detected in the string &quot;FuckMyBoss&quot;.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PretendToBePolite</span>(<span class="hljs-title class_ inherited__">APIBase</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__fuck_your_asshole</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># [Output] NameError: Sensitive words &quot;asshole&quot;, &quot;fuck&quot; detected in the string &quot;_PretendToBePolite__fuck_your_asshole&quot;.</span></span><br></pre></div></div><p>看，即使像最后一个例子中的私有属性也难逃审查，因为它们本质都是相同的。</p><p>甚至，你还可以对有问题的属性进行偷偷的修改，比如 让不文明的函数在调用时打出一行警告 等等，这里就不多说了。</p><h2 id="元类-在实际开发中的应用">元类 在实际开发中的应用</h2><p>日常开发时，元类 常用吗？</p><p>当然，Django 的 ORM 就是一个例子，大名鼎鼎的 SQLAlchemy 也用了这种黑魔法。</p><p>此外，在一些小型的库中，也有 元类 的身影。比如 <code>abc</code>（奇怪的名字～～）——这是 python 的一个内建库，用于模拟 抽象基类（Abstract Base Classes）。开发者可以使用 <code>abc.abstractmethod</code> 装饰器，将 指定了 <code>__metaclass__ = abc.ABCMeta</code> 的类的方法定义成 抽象方法，同时这个类也成了 抽象基类，抽象基类是不可实例化的。这便实现了对 抽象基类 的模拟。</p><p>倘若你也有需要动态修改类定义的需求，不妨也试试这种“黑魔法”。</p><h2 id="小结">小结</h2><ul><li>类 也是 对象，所有的类都是<code>type</code>的实例</li><li>元类（Meta Classes）是类的类</li><li><code>__metaclass__ = Meta</code> 是 <code>Meta(name, bases, dict)</code> 的 语法糖</li><li>可以通过重载元类的 <code>__new__</code> 方法，修改 类定义 的行为</li></ul><br><blockquote><p class="cc">作者：hsfzxjy<br>链接：<span class="cc-link"></span><br>许可：<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>.<br>著作权归作者所有。本文<b>不允许</b>被用作商业用途，非商业转载请注明出处。</p></blockquote><script>!function(){var n=document.querySelector("span.cc-link");n&&(n.innerHTML='<a href="'+location.href+'">'+location.href+"</a>")}()</script></div><div class="post__tags"><a href="/tags/Python/">Python</a><a href="/tags/Meta-Classes/">Meta Classes</a><a href="/tags/Magic/">Magic</a></div><div class="post-nav"><a href="/a-simple-javascript-template-language/" class="pre">«17 行代码实现的简易 Javascript 字符串模板</a><a href="/poems/" class="next">诗集»</a></div><div id="disqus_thread"><div id="no-comment"><h2>OOPS!</h2><span>A comment box should be right here...</span><span>But it was gone due to network issues :-(</span><span>If you want to leave comments, make sure you have access to&nbsp;<a target="_blank" rel="noopener" href="https://disqus.com">disqus.com</a>.</span></div><script>var disqus_shortname="hsfzxjy",disqus_identifier="meta-class-in-python/",disqus_title="Python“黑魔法”之 Meta Classes",disqus_url="https://i.hsfzxjy.site/meta-class-in-python/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.defer=!0,e.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(e),e.onerror=function(){document.getElementById("no-comment").classList.add("show")}}()</script><script id="dsq-count-scr" src="//hsfzxjy.disqus.com/count.js" async defer></script></div></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"><div id="toc" lang="zh" class="font__body"><div class="toc-toggler"></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B1%BB-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">元类 是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#python-%E4%B8%AD%EF%BC%8C%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-number">1.1.</span> <span class="toc-text">python 中，一切都是对象。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%B1%BB%EF%BC%9Atype"><span class="toc-number">1.2.</span> <span class="toc-text">类的类：type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.</span> <span class="toc-text">type 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#__metaclass__-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">__metaclass__ 属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%97%E5%AD%90%EF%BC%9A%E5%AD%90%E7%B1%BB%E5%87%80%E5%8C%96%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">栗子：子类净化器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.0.1.</span> <span class="toc-text">需求描述</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B1%BB-%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">元类 在实际开发中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></div></div></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>