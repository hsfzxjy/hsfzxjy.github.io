<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script>(()=>{let e="/cnfonts.js?rDuukLHQ",t=document,n=navigator.serviceWorker,r=!1;var a;(r=n&&(n.register(e,{scope:"/"}).then(e=>e.update()),a=n.controller)&&a.scriptURL.endsWith(e)&&"activated"===a.state?!0:r)?((a=t.createElement("link")).rel="stylesheet",a.href="/fontchan/rDuukLHQ.css",a.blocking="render",t.head.appendChild(a)):((a=t.createElement("script")).src=e,a.onload=()=>$fontchan.injectCss(),t.head.appendChild(a))})()</script><title>Dijkstra 算法的延伸</title><meta itemprop="title" content="Dijkstra 算法的延伸 - hsfzxjy 的博客"><meta itemprop="og:title" content="Dijkstra 算法的延伸 - hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="description" content="我们知道 Dijkstra 算法是一个高效的单源最短路径（SSSP）算法，本文将不再赘述他的细节。但同时，Dijk..."><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div lang="zh" class="post post-page"><h1 lang="zh" class="post__title">Dijkstra 算法的延伸</h1><div class="post__meta font__ui">2024-01-22 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div class="post__content font__body"><p>我们知道 Dijkstra 算法是一个高效的单源最短路径（SSSP）算法，本文将不再赘述他的细节。但同时，Dijkstra 也是一个动态规划算法。Dijkstra 算法的正确性源自无负边权图的若干性质。如果一个问题本身也满足这些性质，那么即使它不是一个图论最短路径问题，也可以使用 Dijkstra 算法解决。那么，这些性质是什么呢？</p><h2 id="sssp-问题的延伸">SSSP 问题的延伸</h2><p>我们可以从更加抽象的层次描述 SSSP 问题。设想有一个函数 $W: [n] \times [n] \times \mathbb{R}^+ \mapsto \bar{\mathbb{R}}$，对 $\forall g, g_1, g_2 \in \mathbb{R}^+, g_1 &lt; g_2, i, j \in [n], i \neq j$ 满足以下性质</p><p class="par">$$\begin{align} W(i, i, g) &amp;= 0, \\ W(i, j, g) &amp;\geq 0, \\ W(i, j, g_1) - W(i, j, g_2) &amp;\leq g_2 - g_1 \label{eq:bound} \end{align}$$</p><p class="par">$W$ 可以看成一个广义的权值函数，带有一个额外的自变量 $g$。在实际问题中 $g$ 可以是“已走过的距离”等额外参数。而 $\eqref{eq:bound}$ 约束了 $W$ 随着 $g$ 最多只能以线性速度衰减，这对后面的证明是十分必要的。注意 $W$ 的值域是扩充实数域，为了保持一致性，我们额外规定 $\infty - \infty = 0$。</p><p>另一方面，我们记 $[n]$ 中元素构成的子序列的集合为 $\mathcal{U}$</p><p class="par">$$\mathcal{U} = \{(a_1, a_2, \ldots, a_k)|k \in \mathbb{N}, a_1, \ldots, a_k \in [n]\}$$</p><p class="par">$\mathcal{U}$ 中元素我们用加粗小写字母 $\mathbf{a}, \mathbf{b}$ 表示，$|\mathbf{a}|$ 为 $\mathbf{a}$ 的长度，$a_i$ 为 $\mathbf{a}$ 的第 $i$ 个元素，$\mathbf{a}_{q}$ （如 $\mathbf{a}_{\leq k}$）为 $\mathbf{a}$ 中下标满足条件 $q$ 的元素构成的子序列。同时，我们还定义 $||$ 为序列拼接运算符。有了以上准备，现在我们定义路径长度函数 $L: \mathcal{U} \mapsto \bar{\mathbb{R}}$：</p><p>$$ \begin{align} L(\mathbf{a}) &amp;= W(1, a_1, 0), &amp;\text{if } |\mathbf{a}| = 1; \\ L(\mathbf{a}) &amp;= L(\mathbf{a}_{\leq k-1}) + W(a_{k-1}, a_k, L(\mathbf{a}_{\leq k-1})), &amp;\text{if } |\mathbf{a}| = k \geq 2. \end{align} $$</p><p class="par">现在我们要求解另一个函数 $D: [n] \mapsto \mathbb{R}$，其定义如下</p><p>$$ \begin{align} D(u) = \min_{\mathbf{a} \in \mathcal{U}, |\mathbf{a}| \leq n} L(\mathbf{a}||u) \label{eq:D} \end{align} $$</p><p class="par">上述这个问题可以用 Dijkstra 算法求解。在 SSSP 中，$W(i, j, g)$ 即为 $i$ 到 $j$ 的边权，$W(i, j, g)$ 是关于 $g$ 的常函数，$D(i)$ 则是 $i$ 到源点的最短路径。</p><h2 id="延伸问题的求解">延伸问题的求解</h2><p>和 Dijkstra 算法类似，我们维护一个试探性数组 $p: [n] \in \mathbb{R}$。初始时，$p(i) \geq D(i), \forall i$。同时我们维护一个“已求解”的集合 $S$，记其补集 $T = [n] - S$。我们将经过 $n$ 次迭代，逐渐将 $S$ 填满。而在每次迭代开始前，我们会通过某种“更新”机制使 $p$ 满足如下条件：</p><p>$$ \begin{align} p(i) &amp;= D(i), &amp;\forall i \in S; \\ p(i) &amp;= \min_{j \in S} \left(D(j) + W(j, i, D(j)\right)), &amp;\forall i \in [n].\label{eq:ST} \end{align} $$</p><p class="par">在每次迭代中，我们从 $T$ 中取出</p><p>$$\begin{align}u = \arg\min_{i \in T}d(i)\label{eq:u}\end{align}$$</p><p class="par">，并认为 $i$ 已经“求解完成”，将其加入 $S$。为什么可以这么做呢？我们可以用以上的条件证明其正确性。</p><p>利用反证法，如果说 $u$ “还未求解完成”，也就是此时 $p(u) &gt; D(u)$。由 $\eqref{eq:D}$ 中 $\mathbf{a}$ 的取值集合有限可知，$\exists \mathbf{a}, |\mathbf{a}|=k$，使得 $D(u) = L(\mathbf{a}||u)$。我们讨论两种情况：</p><p class="nomargin"><strong>第一种</strong>，如果 $\mathbf{a} \subset S$，</p><p>$$ \begin{align*} D(u) &amp;&lt; p(u) &amp; 利用 \eqref{eq:ST}\\ &amp;\leq D(a_k) + W(a_k, u, D(a_k)) &amp; 利用 D(a_k) \leq L(\mathbf{a}) 以及 \eqref{eq:bound}\\ &amp;\leq D(a_k) + W(a_k, u, L(\mathbf{a})) + L(\mathbf{a}) - D(a_k) \\ &amp;= W(a_k, u, L(\mathbf{a})) + L(\mathbf{a}) &amp; 利用 D(u) = L(\mathbf{a}||u)\\ &amp;= D(u) \end{align*} $$</p><p class="par">矛盾！</p><p class="nomargin"><strong>第二种</strong>，如果诸 $\mathbf{a}$ 中有不属于 $S$ 的元素，假设 $a_j \in T$ 是其中下标最小者。则有</p><p>$$ \begin{align*} p(u) &amp;&gt; D(u) \\ &amp;= L(\mathbf{a}_{&lt;j}||a_j||\mathbf{a}_{&gt;j}||u) \\ &amp;\geq L(\mathbf{a}_{&lt;j}||a_j) \\ &amp;= L(\mathbf{a}_{&lt;j}) + W(a_{j-1}, a_j, L(\mathbf{a}_{&lt;j})) &amp;利用 D(a_{j-1}) &lt; L(\mathbf{a}_{&lt;j})\\ &amp;= L(\mathbf{a}_{&lt;j}) + W(a_{j-1}, a_j, D(a_{j-1})) + D(a_{j-1}) - L(\mathbf{a}_{&lt;j}) \\ &amp;= W(a_{j-1}, a_j, D(a_{j-1})) + D(a_{j-1}) &amp; 利用 a_{j-1} \in S 及 \eqref{eq:ST}\\ &amp;\geq p(a_j) \end{align*} $$</p><p class="par">这与 $u$ 的选取矛盾！故综上，如此选出的 $u$ 一定是“已经求解完成的”。</p><p>选出了 $u$ 后，我们需要以 $u$ 为基点，更新 $Y$ 中其他元素的 $d$ 值。具体而言，对于 $\forall j \in T$，我们作如下更新</p><p>$$p(j) \gets \min(p(j), D(u) + W(u, j, D(u)))$$</p><p class="par">我们可以证明这样的更新方式符合 $\eqref{eq:ST}$ 的要求</p><p>$$ \begin{align*} &amp;\min\left\{p(j), D(u) + W(u, j, D(u))\right\} \\ = &amp;\min\left\{\min_{w \in S}\{D(w)+W(w, j, D(w))\}, D(u, W(u, j, D(u)))\right\} \\ = &amp;\min_{w \in S \cup \{u\}}\{D(w)+W(w, j, D(w))\} \end{align*} $$</p><p class="par">由此可知，Dijkstra 的改进算法可以解决这个延伸问题。</p><h2 id="应用-1">应用</h2><p>前面说过，SSSP 是延伸问题的一个特殊情况。此外，本文的算法还可以用来解决一些特殊的最短路径问题。比如在 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/description/">LeetCode 2577. Minimum Time to Visit a Cell In a Grid</a> 中，图的边权不是一个常数，而是随着当前已走的距离（或时间）增加而减少，而且减少的幅度不超过线性速度。可以验证，这道题的条件满足上面的约束，因此也可以用 Dijkstra 算法来解决。</p><br><blockquote><p class="cc">作者：hsfzxjy<br>链接：<span class="cc-link"></span><br>许可：<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>.<br>著作权归作者所有。本文<b>不允许</b>被用作商业用途，非商业转载请注明出处。</p></blockquote><script>!function(){var n=document.querySelector("span.cc-link");n&&(n.innerHTML='<a href="'+location.href+'">'+location.href+"</a>")}()</script></div><div class="post__tags"><a href="/tags/LeetCode/">LeetCode</a><a href="/tags/Dijkstra/">Dijkstra</a></div><script>window.__ams="ams"</script><div class="post-nav"><a href="/rust-lifetime-transmute-unsoundness/" class="pre">«Arbitary Lifetime Transmutation via Rust Unsoundness</a><a href="/Manacher-algorithm/" class="next">Manacher 回文计数算法»</a></div><div id="disqus_thread"><div id="no-comment"><h2>OOPS!</h2><span>A comment box should be right here...</span><span>But it was gone due to network issues :-(</span><span>If you want to leave comments, make sure you have access to&nbsp;<a target="_blank" rel="noopener" href="https://disqus.com">disqus.com</a>.</span></div><script>var disqus_shortname="hsfzxjy",disqus_identifier="more-thinking-on-dijkstra-algorithm/",disqus_title="Dijkstra 算法的延伸",disqus_url="https://i.hsfzxjy.site/more-thinking-on-dijkstra-algorithm/";!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.defer=!0,t.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(t),t.onerror=function(){document.getElementById("no-comment").classList.add("show")}}()</script><script id="dsq-count-scr" src="//hsfzxjy.disqus.com/count.js" async defer></script></div></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"><div id="toc" lang="zh" class="font__body"><div class="toc-toggler"></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#sssp-%E9%97%AE%E9%A2%98%E7%9A%84%E5%BB%B6%E4%BC%B8"><span class="toc-number">1.</span> <span class="toc-text">SSSP 问题的延伸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B8%E9%97%AE%E9%A2%98%E7%9A%84%E6%B1%82%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">延伸问题的求解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">3.</span> <span class="toc-text">应用</span></a></li></ol></div></div></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>