<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script>(()=>{let r="/cnfonts.js",n=document,e=n.createElement("link");e.rel="stylesheet",e.href="/fontchan/jBKCaHQX.css",e.blocking="render",e.onerror=()=>{var e=n.createElement("script");e.src=r,e.onload=()=>$fontchan.injectCss(),n.head.appendChild(e)},n.head.appendChild(e),"serviceWorker"in navigator&&navigator.serviceWorker.register(r,{scope:"/"}).then(e=>e.update())})()</script><title>hsfzxjy 的博客</title><meta itemprop="title" content="hsfzxjy 的博客"><meta itemprop="og:title" content="hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/">Home</a></div></nav><main class="mainContainer"><div class="post-list"><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-monad/">Haskell 笔记：Monad 引论</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-12-14 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="537b2cbde5b61b680103cbca69a47210a35ca2daf3600ebcbeeaa92efb8dac9b" class="post__content font__body noindent"><h2 id="动机">动机</h2><p>pure functions 看似完美，但却不能模拟现实世界中的诸多任务。这是由于 pure functions 是良定的映射，对于特定的输入值会返回唯一的输出。这种模式在面对如下任务时会显得苍白无力：</p><ul><li>有可能失败的任务。如大多数的 IO。</li><li>依赖外部状态的任务。如（伪）随机数生成器。</li><li>非确定性任务，即对于确定的输入可能有多个输出。这种在 IP 中较为少见。</li><li>对外界会造成影响的任务。如大多数的写入过程。</li></ul><p class="par">这些问题可以用数学中的<strong>域扩充技巧</strong>来解决。</p><h2 id="域扩充">域扩充</h2><p>在数学中，当定义问题的范畴不足以容纳问题的解时，我们通常会对相关的范畴进行扩充。类似的技巧同样也可以应用在这里。</p><p>假设一个不良定的函数 <code>f: A -&gt; B</code>：</p><ul><li>如果 <code>f</code> 有可能失败，我们可以将 <code>B</code> 扩充为 <code>Err(B) ∪ &#123; reasons of failures &#125;</code>，其中 <code>reasons of failures</code> 可能是对异常的描述，也可以是空值一类的东西。则 <code>f&#39;: A -&gt; Err(B)</code> 是良定的映射，且与 <code>f</code> 行为一致。事实上，这就是 Maybe Monad 和 Either Monad。</li><li>如果 <code>f</code> 依赖于外部状态，我们定义 <code>Pref(B)</code> 为 <strong>从外部状态空间到 B 的映射的全体</strong>，则 <code>f&#39;: A -&gt; Pref(B)</code> 为良定的映射，且行为和 <code>f</code> 一致。换言之，对于特定的输入 <code>a</code>，<code>f&#39;(a)</code> 返回一个函数，其中蕴含了已知 <code>a</code> 时如何从各种不同状态得到结果的逻辑。事实上，这就是 State Monad。</li><li>如果 <code>f</code> 具有非确定性，我们将 <code>B</code> 扩充为 <code>Power(B)</code>，即 <code>B</code> 的幂集。则 <code>f&#39;: A -&gt; Power(B)</code> 为良定的映射，且行为与 <code>f</code> 一致。事实上，这就是 List Monad。</li><li>如果 <code>f</code> 依赖于真实世界，我们将 <code>B</code> 扩充为 <code>IO(B)</code>，其中的元素为一些值域为 <code>B</code> 的<strong>伪函数</strong>，可能对真实世界有影响。这些伪函数已经脱离了 pure functions 的范畴，但将它们看成元素是没有问题的。如此一来 <code>f&#39;: A -&gt; IO(B)</code> 为良定的映射，且行为与 <code>f</code> 一致。事实上，这就是 IO Monad。</li></ul><p>以上操作都有一个共同点，即对一个不良定函数的值域做了扩充，使之变成良定函数。如果用 Haskell 语言描述，它们都有相似的型：<code>f :: a -&gt; m b</code>，其中 <code>m</code> 为扩充规则。</p><p>一个问题随之而来：这样的新函数该怎么结合？为此我们要对相关逻辑进行抽象。这就是 Monad。</p><h2 id="monad">Monad</h2><p>这里我们尝试从实际需求出发，导出一个 Type Constructor 成为 Monad 的必要条件。</p><p>约定两个名称：</p><ul><li>称 <code>a -&gt; m b</code> 型函数为 monadic function</li><li>称 <code>a -&gt; b</code> 型函数为 non-monadic function</li></ul><p>首先需要解决的是 monadic functions 如何结合的问题。这个问题具有重要的现实意义。monadic function 常常代表某种计算任务，它们之间的结合相当于把若干计算任务串行化，而后者是非常常见的需求。</p><p>我们希望有一种运算符有如下的类型 <code>(b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)</code>，在此记为 <code>&gt;=&gt;</code> （因其形状，常被叫做 fish operator）。一个自然的想法是，Monad <code>m</code> 需要某种平凡的拆箱操作 <code>extract&#39; :: m a -&gt; a</code>。所谓“平凡”，即 <code>extract&#39;</code> 不应该丢失参数的任何信息。但这往往不能实现，因为 <code>m a</code> 通常会比 <code>a</code> 包含更多的信息，导致 <code>extract&#39;</code> 无法构成良定的映射。例如 <code>Maybe a</code> 中的值 <code>Nothing</code> 就无法在 <code>a</code> 中找到对应的值。</p><p>而事实上，我们不需要条件这么强的拆箱操作。在 <code>m</code> 已是 Functor 的情况下，拆箱操作可以弱化为 <code>join :: m (m a) -&gt; m a</code>。我们尝试用 <code>fmap</code>、 <code>join</code> 合成 <code>&gt;=&gt;</code>。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">f</span> :: b -&gt; m c</span><br><span class="line"><span class="hljs-title">g</span> :: a -&gt; m b</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">fmap</span> f :: m b -&gt; m (m c)</span><br><span class="line">(fmap f) . g :: a -&gt; m (m c)</span><br><span class="line"><span class="hljs-title">join</span> . (fmap f) . g :: a -&gt; m c</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">-- i.e.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">f</span> &gt;=&gt; g = join . (fmap f) . g</span><br></pre></div></div><p>Functor 的假设是容易成立的。当然我们可以定义多个不同的 <code>fmap</code>，如此产生的 Monad 会有不同的语义。<code>join</code> 的假设也是容易成立的，<code>m (m a)</code> 通常和 <code>m a</code> 包含相同多的信息。故此做法是实际可行的。</p><p>我们再考虑 monadic function 和 non-monadic function 结合的问题。期望有如此一个运算：<code>&gt;.&gt; :: (b -&gt; c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)</code>。注意，此处返回值是 <code>a -&gt; m c</code> 而不是 <code>a -&gt; c</code>，因为我们不希望 <code>a -&gt; m b</code> 产生的额外信息有所丢失。自然地，我们希望有一个平凡的装箱操作，<code>return :: a -&gt; m a</code>。如此一来便可结合 <code>&gt;=&gt;</code> 完成上面的运算：</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">f</span> :: b -&gt; c</span><br><span class="line"><span class="hljs-title">g</span> :: a -&gt; m b</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">return</span> . f :: b -&gt; m c</span><br><span class="line">(return . f) &gt;=&gt; g :: a -&gt; m c</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">-- i.e.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">f</span> &gt;.&gt; g :: (return . f) &gt;=&gt; g</span><br></pre></div></div><p class="par">non-monadic function 和 monadic function 另一个方向的结合是平凡的。</p><p>综上我们可以得到成为 Monad 的基本条件：</p><ul><li>是 Functor，存在 <code>fmap :: (a -&gt; b) -&gt; m a -&gt; m b</code></li><li>有一个平凡的拆箱操作 <code>join :: m (m a) -&gt; m a</code></li><li>有一个平凡的装箱操作 <code>return :: a -&gt; m a</code></li></ul><p>为了描述平凡，我们要求三个函数必须满足如下公理（下面的 <code>f</code> 为 non-monadic function）：</p><ol><li><code>return . f == (fmap f) . return</code> （<code>return</code> 的平凡性）</li><li><code>join . fmap (fmap f) == (fmap f) . join</code> （<code>join</code> 的平凡性）</li></ol><blockquote><p>事实上在 Category Theory 中，还有另外两条公理：</p><ul><li><code>join . (fmap join) == join . join</code></li><li><code>join . fmap return == join . return == id</code></li></ul><p>以上四条公理描述了 <code>Id</code>（恒等 Functor）、<code>m</code>、<code>m^2</code>、<code>m^3</code> 之间的泛性质，并使图交换。</p></blockquote><h2 id="monad-typeclass">Monad Typeclass</h2><p>以下为 Prelude 中的定义：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> m =&gt; m a <span class="hljs-keyword">where</span></span></span><br><span class="line"></span><br><span class="line">    return :: a -&gt; m a</span><br><span class="line">    (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></div></div><p>此处没有出现 <code>join</code>，也没有 fish operator，而是使用了一个更常用的算符 <code>&gt;&gt;=</code> （通常称为 bind operator）。这是因为在实际中我们不直接将函数结合，而是使用 non-pointfree 的写法。</p><p>此外，还有 <code>&gt;&gt; :: m a -&gt; m b -&gt; m b</code> 运算符。<code>return</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;</code> 三者是构成 do-notation 的基础。此处不再赘述。</p><h2 id="references-2">References</h2><ul><li><a target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/Haskell/Category_theory">Haskell/Category Theory</a></li><li><a target="_blank" rel="noopener" href="https://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/">Why Do Monads Matter?</a></li></ul></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-monad/">READ MORE</a></div></article><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-applicative/">Haskell 笔记：Applicative</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2018-11-18 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="68187ada12eaa74a8a6ad75da7354a801a0adc68068719dbb4c4fe2d96e11fab" class="post__content font__body noindent"><h2 id="motivation">Motivation</h2><p><code>Functor</code> solves the problem of mapping regular single-parameter functions into a sub-category, but that’s not easy for functions with more than one parameter.</p><p>Let’s consider a function with two parameters <code>f :: a -&gt; b -&gt; c</code>, which can also read as <code>a -&gt; (b -&gt; c)</code>. Applying <code>fmap</code> on <code>f</code> will yield <code>fmap f :: m a -&gt; m (b -&gt; c)</code>. That’s still distant from what we expect: <code>f&#39; :: m a -&gt; m b -&gt; m c</code>. To get <code>f&#39;</code>, we need a transform from <code>m (b -&gt; c)</code> to <code>m b -&gt; m c</code>. Here we denote it as <code>&lt;*&gt; :: m （b -&gt; c) -&gt; m b -&gt; m c</code>. We will later show that such transform is universal for functions with more parameters.</p><p>Now consider a function with three parameters <code>f :: a -&gt; b -&gt; c -&gt; d</code>. We are going to transform it into a wrapped-value version, with the help of <code>fmap</code> and <code>&lt;*&gt;</code>.</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">f</span> :: a -&gt; b -&gt; c -&gt; d</span><br><span class="line"></span><br><span class="line">(fmap f) :: m a -&gt; m (b -&gt; (c -&gt; d))</span><br><span class="line"></span><br><span class="line">\a_ b_ -&gt; (fmap f a_) &lt;*&gt; b_</span><br><span class="line">    :: m a -&gt; m b -&gt; m (c -&gt; d)</span><br><span class="line"></span><br><span class="line">\a_ b_ c_ -&gt; ((fmap f a_) &lt;*&gt; b_) &lt;*&gt; c_</span><br><span class="line">    :: m a -&gt; m b -&gt; m c -&gt; (m d)</span><br></pre></div></div><p class="par">Here <code>\a_ b_ c_ -&gt; ((fmap f a_) &lt;*&gt; b_) &lt;*&gt; c_</code> is in the desired type. For most of the time, applying parameters directly is actually what we want, instead of the function itself, so the code could simply be written as <code>((fmap f a) &lt;*&gt; b) &lt;*&gt; c</code>, where <code>a</code>, <code>b</code> and <code>c</code> are wrapped values. Parenthesis could be omitted if precedences are set properly, which leads to a neat and easy-to-read form:</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">f</span> `fmap` a &lt;*&gt; b &lt;*&gt; c</span><br></pre></div></div><p class="par">In haskell, <code>fmap</code> has an infix name <code>&lt;$&gt;</code>. So finally we get: <code>f &lt;$&gt; a &lt;*&gt; b &lt;*&gt; c</code>.</p><h2 id="applicative">Applicative</h2><p>Haskell pre-defines a type class <code>Applicative</code>, which captures the pattern of <code>&lt;*&gt;</code>. Any type that implements <code>Applicative</code> works well with <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code>.</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> f =&gt; <span class="hljs-type">Applicative</span> (<span class="hljs-title">f</span> :: * -&gt; *) <span class="hljs-keyword">where</span></span></span><br><span class="line">  pure :: a -&gt; f a</span><br><span class="line">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">  <span class="hljs-type">GHC</span>.<span class="hljs-type">Base</span>.liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</span><br><span class="line">  (*&gt;) :: f a -&gt; f b -&gt; f b</span><br><span class="line">  (&lt;*) :: f a -&gt; f b -&gt; f a</span><br></pre></div></div><p class="par">Note that an <code>Applicative</code> is also a <code>Functor</code>. Apart from <code>&lt;*&gt;</code>, there are some other helper functions or operators in <code>Applicative</code>.</p><p><code>pure</code> is equivalent to the default value constructor of <code>f</code>, e.g. <code>(:[])</code> for <code>List</code> or <code>Just</code> for <code>Maybe</code>. This may be handful when lifting an unwrapped value to a wrapped one.</p><p><code>liftA2</code> transforms a binary operator to the corresponding version. The function exists as binary operators would be frequently passed among high-order functions.</p><p><code>*&gt;</code> takes two wrapped parameters and simply returns the second one, which sequence up two wrapped values. This is quite useful for <code>Applicative</code> with action semantics, such as <code>IO</code>. In fact, it’s so useful that Haskell introduces a syntax sugar for it, known as the <code>do-notation</code>. Particularly:</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">do</span></span><br><span class="line">    putStrLn <span class="hljs-string">&quot;1&quot;</span></span><br><span class="line">    putStrLn <span class="hljs-string">&quot;2&quot;</span></span><br></pre></div></div><p class="par">is equivalent to</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">putStrLn</span> <span class="hljs-string">&quot;1&quot;</span> *&gt; putStrLn <span class="hljs-string">&quot;2&quot;</span></span><br></pre></div></div><p class="par"><code>&lt;*</code> is similar. Both will be reviewed while studying Monad.</p></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-applicative/">READ MORE</a></div></article><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-category-theory-and-functor/">Haskell 笔记：Category Theory and Functor</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2018-11-18 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="30e6fe9f86787a349f7447182720b783e5cf2d22dc85544c23b6a3fecb11939f" class="post__content font__body noindent"><h2 id="category-theory">Category Theory</h2><p>A category consists of three parts:</p><ul><li>A collection of objects.</li><li>A collection of morphisms, each of which map one object to another.</li><li>A composition operator of these morphisms, i.e. morphisms can be composed. If <code>f: A -&gt; B</code> and <code>g: B -&gt; C</code> are morphisms, <code>f.g</code> generates a new morphism <code>A -&gt; C</code>.</li></ul><p class="par">Note that a morphism has no specific semantics of mapping, but simply links two objects together. Morphisms are also called <strong>Arrows</strong>.</p><h3 id="examples">Examples</h3><h4 id="set-category-set">Set Category: Set</h4><p>All sets and standard functions form a category. Functions need not to be surjective, since morphisms have no mapping semantics.</p><h4 id="group-category-grp">Group Category: Grp</h4><p>All groups and homomorphisms between groups form a category. A group has specific algebaric structure, which morphisms should preserve.</p><h3 id="laws">Laws</h3><p>Three laws that a category should obey:</p><ul><li>Composition should be associative.</li><li>Composition operation should be enclosed in the category, i.e. if <code>f: A -&gt; B</code> and <code>g: B -&gt; C</code>, there must be a <code>h: A -&gt; C</code> satisfying <code>h = f . g</code>.</li><li>For each object <code>A</code>, there should exist an identity morphism <code>id(A): A -&gt; A</code> s.t. for every <code>f: A -&gt; B</code>, <code>f = id(A) . f = f . id(B)</code>.</li></ul><p class="par">Note that:</p><ul><li>There may exist serveral morphisms between <code>A</code> and <code>B</code>.</li><li>An identity has type <code>A -&gt; A</code>, but a morphism with such type needs not to be an identity.</li></ul><h3 id="functors-in-category-theory">Functors in Category Theory</h3><p>A functor maps a category to another category. It should contains two mappings for objects and for morphisms, with composition operation and category laws preserved.</p><p>There’s a trivial functor from Grp to Set, which maps groups to their underlying sets, and group morphisms to functions with same behavior but defined on sets instead of groups.</p><h2 id="paramateric-types-in-haskell">Paramateric Types in Haskell</h2><p>It’s common to create new types that hold values of other types. <code>List[a]</code> type constructor creates types that holds sequential values of same type; <code>Maybe[a]</code> creates types that hold operation states (failure, or success with returned values).</p><p>Usually we expect derived types to inherit functions from types being wrapped. For example, <code>List[Int]</code> should have element-wise addition as <code>Int</code> does, and <code>Maybe[Int]</code> should have similar operations with no burden of re-wrapping and unwrapping. <strong>Such ‘inheritance’ should be done automatically if possible, since it is only concerned with the structure of types instead of specific functions.</strong></p><h2 id="hask-category">Hask Category</h2><p>Haskell language itself forms a category, with <strong>all types</strong> being objects, and functions being morphisms. Such category is called Hask.</p><h2 id="hask-functors">Hask Functors</h2><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> m <span class="hljs-keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; m a -&gt; m b</span><br></pre></div></div><p class="par">A parameteric type implementing class <code>Functor</code> is a category functor, mapping Hask to one of its sub-category, where types <code>m a</code> are the object collection. The type constructor <code>m</code> maps objects, and specific <code>fmap</code> defined on <code>m</code> maps corresponding functions.</p><p>It’s worth noted that <code>(a -&gt; b) -&gt; m a -&gt; m b</code> can also read as <code>(a -&gt; b) -&gt; (m a -&gt; m b)</code>, as <code>-&gt;</code> is right-associative. This may provide a clearer view of <code>fmap</code>, which takes a regular function in Hask and returns the corresponding function in sub-category.</p><p>Examples:</p><p><code>fmap (+) :: List[Int] -&gt; List[Int]</code> generates element-wise addition in <code>List[Int]</code>.</p><p class="par"><code>fmap (+) :: Maybe Int -&gt; Maybe Int</code> generates such function:</p><p class="noindent"></p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">maybePlus</span> :: <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span></span><br><span class="line"><span class="hljs-title">maybePlus</span> _        <span class="hljs-type">Nothing</span>  = <span class="hljs-type">Nothing</span></span><br><span class="line"><span class="hljs-title">maybePlus</span> <span class="hljs-type">Nothing</span>  _        = <span class="hljs-type">Nothing</span></span><br><span class="line"><span class="hljs-title">maybePlut</span> (<span class="hljs-type">Just</span> x) (<span class="hljs-type">Just</span> y) = <span class="hljs-type">Maybe</span> (x + y)</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-category-theory-and-functor/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-data-type-newtype/">Haskell 笔记：data, type, newtype</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-11-16 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="5e5abb7e66ed613bc75b7c17b952c2b029070d903208bd622a481c19025d3b8b" class="post__content font__body noindent"><p>新类型有自己的 data constructor（literals 可以看成特殊的 data constructor），由这一点来区分是否创建了新类型。</p><ul><li><code>data</code> 创建了新类型，可以有多个 data constructor。</li><li><code>newtype</code> 创建了新类型，只能有一个 data constructor，同时新类型的内存布局与原来的类型相同。</li><li><code>type</code> 没有创建新类型，只是建立了 alias，没有新的 data constructor。</li></ul><h2 id="type">type</h2><p>常用于语义化类型，是业务逻辑层的概念。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ID</span> = <span class="hljs-type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">a</span> = <span class="hljs-number">1</span> :: <span class="hljs-type">ID</span></span><br><span class="line"><span class="hljs-title">b</span> = a + <span class="hljs-number">2</span> <span class="hljs-comment">-- legal</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">showID</span> :: <span class="hljs-type">ID</span> -&gt; <span class="hljs-type">IO</span> ()</span><br><span class="line"><span class="hljs-title">showID</span> x = print x <span class="hljs-comment">-- legal, since Int has already been an instance of class Show</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">-- illegal, since Int has already been instantiated</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Show</span> <span class="hljs-type">ID</span> <span class="hljs-keyword">where</span></span></span><br><span class="line">    <span class="hljs-comment">-- ...</span></span><br></pre></div></div><h2 id="newtype">newtype</h2><p>在编译期创建新类型，但差异在运行期被抹去。带有一个构造器。</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">ID&#x27;</span> = <span class="hljs-type">ID&#x27;</span> <span class="hljs-type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">a</span> = <span class="hljs-type">ID&#x27;</span> <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-title">b</span> = a + <span class="hljs-number">2</span> <span class="hljs-comment">-- illegal, since Int and ID&#x27; are totally different types</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">showID&#x27;</span> :: <span class="hljs-type">ID&#x27;</span> -&gt; <span class="hljs-type">IO</span> ()</span><br><span class="line"><span class="hljs-title">showID&#x27;</span> x = print x <span class="hljs-comment">-- illegal, since ID&#x27; is not an instance of Show</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">-- either</span></span><br><span class="line"><span class="hljs-title">showID&#x27;</span> (<span class="hljs-type">ID&#x27;</span> x) = print x</span><br><span class="line"><span class="hljs-comment">-- or</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Show</span> <span class="hljs-type">ID&#x27;</span> <span class="hljs-keyword">where</span></span></span><br><span class="line">    show (<span class="hljs-type">ID&#x27;</span> x) = show x</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-data-type-newtype/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-fold/">Haskell 笔记：folds</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-11-10 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="85c1cc954e75087d4f4e7b89dcf43cf688e894b9ea979c5e7a2df31bdac64398" class="post__content font__body noindent"><h2 id="preludefoldl">Prelude.foldl</h2><p><code>foldl</code> 为 left-associative folding。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl</span> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="hljs-title">foldl</span> f acc [] = acc</span><br><span class="line"><span class="hljs-title">foldl</span> f acc (x:xs) = foldl f (f acc x) xs</span><br></pre></div></div><p class="par"><code>foldl (+) 0 [1..3]</code> 等价于 <code>(((0 + 1) + 2) + 3)</code>。</p><ul><li>尾递归，因此有 strict 版本 <code>foldl&#39;</code></li><li>求值时必须先到达栈底，遍历完列表，因此无法处理无穷列表</li></ul><h2 id="datalistfoldl">Data.List.foldl’</h2><p><code>foldl&#39;</code> 为 <code>foldl</code> 的 TRO 版本。</p><h2 id="preludefoldr">Prelude.foldr</h2><p><code>foldr</code> 为 right-associative folding。</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldr</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="hljs-title">foldr</span> f acc [] = acc</span><br><span class="line"><span class="hljs-title">foldr</span> f acc (x:xs) = f x (foldr f acc xs)</span><br></pre></div></div><p class="par"><code>foldr (+) 0 [1..3]</code> 等价于 <code>(0 + (1 + (2 + 3)))</code></p><ul><li>没有尾递归，有爆栈的危险。</li><li>有向右展开的特点，而 Haskell 中许多数据结构都有向右递归的特点（如 Cons），因此可以很好地处理无穷递归的数据，从而更加通用。</li></ul><h2 id="preludefoldl1--preludefoldr1">Prelude.foldl1 &amp;&amp; Prelude.foldr1</h2><p>Helper functions。将 operator 限制为同一种类型，同时约去 accumulator。</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl1</span> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</span><br><span class="line"><span class="hljs-title">foldl1</span> f (x:xs) = foldl f x xs</span><br><span class="line"><span class="hljs-title">foldl1</span> _ [] = error</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">foldr1</span> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</span><br><span class="line"><span class="hljs-title">foldr1</span> f (x:xs) = foldr f x xs</span><br><span class="line"><span class="hljs-title">foldr1</span> _ [] = error</span><br></pre></div></div><p class="par">即，<code>foldr1</code> 将列表的第一个值作为 accumulator，将剩余部分作为 list，传给 <code>foldr</code>。<code>foldl</code> 同理。</p><h2 id="实践">实践</h2><h3 id="用-folds-实现-reverse">用 folds 实现 <code>reverse</code></h3><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">reversel</span>, reverser :: [a] -&gt; [a]</span><br><span class="line"><span class="hljs-title">reversel</span> list = foldl (\acc x -&gt; x : acc) [] list</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">reverser</span> list = foldr (\x acc -&gt; acc ++ [x]) [] list</span><br></pre></div></div><h3 id="用-foldr-实现-foldl">用 foldr 实现 foldl</h3><p>先归纳出 <code>foldr</code> 的泛性质。如果一个函数 <code>g</code> s.t.</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">g</span> [] = v</span><br><span class="line"><span class="hljs-title">g</span> (x:xs) = f x (g xs)</span><br></pre></div></div><p class="par">则 <code>g list === foldr f v list</code>.</p><p>再看 <code>foldl</code> 的定义：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl</span> f v [] = v</span><br><span class="line"><span class="hljs-title">foldl</span> f v (x:xs) = foldl f (f v x) xs</span><br><span class="line"></span><br><span class="line">===&gt;</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">foldl</span> f v list = g list v</span><br><span class="line">    <span class="hljs-keyword">where</span></span><br><span class="line">        g [] v = v</span><br><span class="line">        g (x:xs) v = g xs (f v x)</span><br><span class="line">        <span class="hljs-comment">-- 从左到右依次更新 v</span></span><br><span class="line"></span><br><span class="line">===&gt;</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">foldl</span> f v list = g list v</span><br><span class="line">    <span class="hljs-keyword">where</span></span><br><span class="line">        g [] = id</span><br><span class="line">        g (x:xs) = \v -&gt; g xs (f v x)</span><br></pre></div></div><p class="par">应有 <code>g (x:xs) === k x (g xs)</code>，我们计算 <code>k</code>：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">g</span> (x:xs)       === k x (g xs)</span><br><span class="line"><span class="hljs-title">g</span> (x:xs) v     === k x (g xs) v</span><br><span class="line"><span class="hljs-title">g</span> xs (f v x)   === k x (g xs) v</span><br><span class="line">(g xs) (f v x) === k x (g xs) v</span><br><span class="line"><span class="hljs-title">g&#x27;</span> (f v x)     === k x g&#x27; v</span><br><span class="line"><span class="hljs-title">k</span>              === \x g&#x27; v -&gt; g&#x27; (f v x)</span><br></pre></div></div><p class="par">所以</p><div class="gk-code hljs" data-gk-id="BLOCK8"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl</span> f v xs =</span><br><span class="line">    (foldr</span><br><span class="line">        (\x g&#x27; v -&gt; g&#x27; (f v x))</span><br><span class="line">        id</span><br><span class="line">        xs</span><br><span class="line">    ) v</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-fold/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/download-in-ubuntu-with-aria/">使用 Aria2 在 Ubuntu 中下载百度云资源</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-06-11 | <span class="post__meta-categories"><a href="/categories/Memo/">Memo</a></span></div><div data-post-id="3877350f3156db84289f4b57bb811f88c1063a8c82e99b2ccd4f0678740bb7a2" class="post__content font__body noindent"><p>可以实现满带宽下载。</p><h1 id="配置-aria2">配置 Aria2</h1><p>从 <a target="_blank" rel="noopener" href="https://github.com/aria2/aria2/releases">Github</a> 下载源码 <code>./configure &amp;&amp; make -j8 &amp;&amp; sudo make install</code>。</p><h1 id="配置-chrome-插件">配置 Chrome 插件</h1><p>clone <code>https://github.com/acgotaku/BaiduExporter</code>。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">cd</span> ariac</span><br><span class="line">$ <span class="hljs-built_in">cat</span> &gt; start.sh</span><br><span class="line">&gt; <span class="hljs-comment">#!/bin/bash</span></span><br><span class="line">&gt; aria2c --conf=aria2.conf</span><br><span class="line">&gt; ^D</span><br><span class="line">$ <span class="hljs-built_in">chmod</span> +x start.sh</span><br><span class="line">$ ./start.sh</span><br></pre></div></div><h1 id="安装-chrome-插件">安装 Chrome 插件</h1><p>打开 <code>chrome://extensions</code>，<code>Load Unpacked</code> 选择 <code>chrome/release</code>。</p><p>完成后在百度云页面上会有 <code>导出下载</code> 按钮。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/download-in-ubuntu-with-aria/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/python-gil-and-threads/">从伪并行的 Python 多线程说起</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-03-10 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="992b305387932c90bb5758e418d5ca8ff16320adc853d7dd4d35440c20edf3b6" class="post__content font__body noindent"><h2 id="写在前面-7">写在前面</h2><ul><li>作者电脑 CPU 为 4 核，因此使用 4 个线程测试是合理的</li><li>本文使用的 <code>cpython</code> 版本为 <code>3.6.4</code></li><li>本文使用的 <code>pypy</code> 版本为 <code>5.9.0-beta0</code>，兼容 Python 3.5 语法</li><li>本文使用的 <code>jython</code> 版本为 <code>2.7.0</code>，兼容 Python 2.7 语法</li><li>若无特殊说明，作语言解时，<code>python</code> 指 Python 语言；作解释器解时，<code>python</code> 指 <code>cpython</code></li></ul></div><div lang="zh" class="post__readmore font__ui"><a href="/python-gil-and-threads/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/caveats-for-signal-handler-in-python/">一个 Reentrant Error 引发的对 Python 信号机制的探索和思考</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2017-08-17 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="a9c9a79948df76fb6d5f5dbd58139f2567b56e6819570413788f4863a8db5cf8" class="post__content font__body noindent"><h2 id="写在前面-5">写在前面</h2><p>前几天工作时遇到了一个匪夷所思的问题。经过几次尝试后问题得以解决，但问题产生的原因却仍令人费解。查找 SO 无果，我决定翻看 Python 的源码。断断续续地研究了几天，终于恍然大悟。撰此文以记。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/caveats-for-signal-handler-in-python/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/linux-file-permissions/">Linux 文件权限</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2017-07-03 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="24fc576ed77be4d8f7865ed343bebae2bbfce9cbf2aa63184447ca513fefc457" class="post__content font__body noindent"><h1 id="概念">概念</h1><p>Linux 中的每一个文件都有其 <strong>所属用户</strong> 及 <strong>所属用户组</strong>，根据这两个属性可将文件访问者分为三类：<strong>所属用户自己</strong>、<strong>所属用户组中的用户</strong> 和 <strong>其他用户</strong>，我们可以针对不同的访问者设置不同的用户权限。</p><p>“访问”可分为三类：<strong>读</strong>、<strong>写</strong> 与 <strong>执行</strong>。我们可以用 <code>ls -l</code> 命令查看一个文件的权限：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">touch</span> <span class="hljs-built_in">test</span></span><br><span class="line">$ <span class="hljs-built_in">ls</span> -l <span class="hljs-built_in">test</span></span><br><span class="line">-rw-rw-r-- 1 hsfzxjy hsfzxjy 0 Jul  3 23:44 <span class="hljs-built_in">test</span></span><br></pre></div></div><p class="par">首部的 <code>-rw-rw-r--</code> 即为文件的权限位。权限应该分为四部分来看：<code>-/rw-/rw-/r--</code>。第一部分标志文件的类型，如 普通文件（<code>-</code>）、目录（<code>d</code>）、UNIX 套接字（<code>s</code>）、符号链接（<code>l</code>）、块设备（<code>b</code>）等等。接下来的三个部分依次代表 <strong>所属用户</strong>、<strong>所属用户组</strong>、<strong>其他用户</strong> 的权限，每部分由三个标志位组成：<strong>读标志位</strong>、<strong>写标志位</strong>、<strong>执行标志位</strong>。</p><h1 id="目录的权限">目录的权限</h1><p>目录是一种特殊的文件，因此也拥有文件权限的概念，但权限的语义与普通文件稍有差异：</p><ul><li>读：读取目录下文件列表，相关命令如 <code>ls</code></li><li>写：创建、删除目录下的文件，相关命令如 <code>touch</code>（当文件不存在时）、<code>rm</code> 等</li><li>执行：进入目录，相关命令如 <code>cd</code></li></ul><h1 id="特殊权限">特殊权限</h1><p>出于某些特殊目的，Linux 中存在两个特殊的权限位：粘滞位（<code>t</code>）、Set Id（<code>s</code>）。这两个权限可以 <strong>叠加</strong> 在执行权限位上，其中 Set Id 可以置于 <strong>所属用户</strong> 和 <strong>所属用户组</strong> 的权限组上，而 粘滞位 只能置于 <strong>其他用户</strong> 权限组上。当特殊权限被设置时，执行权限位上即会显示 <code>s/t</code> （已有 <code>x</code> 权限）或 <code>S/T</code> （尚未有 <code>x</code> 权限）。</p><h2 id="粘滞位">粘滞位</h2><p>粘滞位的作用是 <strong>防止他人误删自己的文件</strong>。当某个目录的其他用户权限组有 <code>w</code> 权限时，系统中的其他用户即可随意删除目录中的文件。而一旦叠加上 <code>t</code> 权限，只有文件的所有者方能删除文件。一个经典的例子是 <code>/tmp</code>：</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">ls</span> -l /</span><br><span class="line">drwxrwxrwt  13 root root 12288 Jul  4 00:15 tmp/</span><br></pre></div></div><h2 id="set-id">Set Id</h2><p>Linux 中的进程也有自己所属用户与用户组。一般而言，进程的所属用户即为其发起者，但这会引起一些麻烦。一个例子是 <code>passwd</code> 命令，该命令需要修改属于 <code>root</code> 用户的系统文件以保存密码，倘若进程所属用户即为所属者，此功能则无法实现。</p><p>Set Id 权限的作用是：在文件被执行时，将其有效用户/用户组设置为文件的用户/用户组，而不是当前执行者。下面是一个演示：</p><p>设当前用户为 <code>hsfzxjy</code>，我们在 <code>/tmp</code> 下创建一个 <code>test</code> 文件，并删去其他用户的 <code>r</code> 权限：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">cd</span> /tmp</span><br><span class="line">$ <span class="hljs-built_in">echo</span> <span class="hljs-built_in">test</span> text &gt; <span class="hljs-built_in">test</span></span><br><span class="line">$ <span class="hljs-built_in">chmod</span> o-r <span class="hljs-built_in">test</span></span><br><span class="line">$ ll <span class="hljs-built_in">test</span></span><br><span class="line">-rw-rw---- 1 hsfzxjy hsfzxjy 0 Jul  4 00:28 <span class="hljs-built_in">test</span></span><br></pre></div></div><p class="par">由于 <code>test</code> 文件的所属用户是 <code>hsfzxjy</code>，其他用户没有权限读取其中的内容：</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line">$ sudo -u mysql <span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span></span><br><span class="line"><span class="hljs-built_in">cat</span>: <span class="hljs-built_in">test</span>: Permission denied</span><br></pre></div></div><p class="par">现在我们修改一下 <code>cat</code> 命令的权限，为了不影响系统文件，我们拷贝一份 <code>cat</code> 副本至当前目录：</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">cp</span> /bin/cat .</span><br><span class="line">$ <span class="hljs-built_in">chmod</span> u+s <span class="hljs-built_in">cat</span></span><br><span class="line">$ ll <span class="hljs-built_in">cat</span></span><br><span class="line">-rwsr-xr-x 1 hsfzxjy hsfzxjy 52080 Jul  4 00:34 <span class="hljs-built_in">cat</span>*</span><br></pre></div></div><p class="par">再以 <code>mysql</code> 的身份执行命令：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line">$ sudo -u mysql ./cat <span class="hljs-built_in">test</span></span><br><span class="line"><span class="hljs-built_in">test</span> text</span><br></pre></div></div><p class="par">可见 <code>./cat</code> 在执行时所属用户是 <code>hsfzxjy</code>。我们可以使用 <code>ps</code> 命令更清楚地看到这点：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line">$ sudo -u mysql <span class="hljs-built_in">cat</span></span><br><span class="line"><span class="hljs-comment"># 在另一个终端中</span></span><br><span class="line">$ ps -eo euser,ruser,<span class="hljs-built_in">comm</span> | grep <span class="hljs-built_in">cat</span></span><br><span class="line">mysql    mysql    <span class="hljs-built_in">cat</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -----------</span></span><br><span class="line"></span><br><span class="line">$ sudo -u mysql ./cat</span><br><span class="line"><span class="hljs-comment"># 在另一个终端中</span></span><br><span class="line">$ ps -eo euser,ruser,<span class="hljs-built_in">comm</span> | grep <span class="hljs-built_in">cat</span></span><br><span class="line">hsfzxjy  mysql    <span class="hljs-built_in">cat</span></span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/linux-file-permissions/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/HSFZMUN-4.0-configuration/">HSFZMUN 4.0 部署小记</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2017-02-25 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="6bc9dac75b60f8c50025ec857da1106ba093a8cb99336ac380bdce50416ed054" class="post__content font__body noindent"><blockquote><p>技术流水账一篇，记录踩过的坑</p></blockquote><h2 id="channels-异构-1">Channels 异构</h2><p>Django Channels 官方文档宣称 channels 的最佳配置是使用其自带的服务器组件 Daphne，但在开发中我发现 daphne 处理普通请求比在 WSGI 架构下慢了好几倍，更何况使用 daphne 派发静态文件是十分不切实际的。于是我将 <code>http.request</code> 和 <code>websocket.*</code> 两个 channel 解耦，前者使用 nginx 配合 uwsgi 处理，后者使用 nginx 反向代理至 daphne 处理。这样一来便可充分利用两种架构的优势。</p><p><strong>旧架构：</strong></p><p><img loading="lazy" src="/assets/django-channels-configuration/old-arch.png" alt=""></p><p><strong>新架构：</strong></p><p><img loading="lazy" src="/assets/django-channels-configuration/new-arch.png" alt=""></p></div><div lang="zh" class="post__readmore font__ui"><a href="/HSFZMUN-4.0-configuration/">READ MORE</a></div></article></div><div lang="zh" class="page-navigator font__ui"><span class="page__button"><a href="/page/7/" class="pre">PREV</a></span><span class="page__button"><a href="/page/9/" class="next">NEXT</a></span></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon current"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item current"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>