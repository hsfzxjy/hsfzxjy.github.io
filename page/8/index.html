<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><title>hsfzxjy 的博客</title><meta itemprop="title" content="hsfzxjy 的博客"><meta itemprop="og:title" content="hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/">Home</a></div></nav><main class="mainContainer"><div class="post-list"><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-applicative/">Haskell 笔记：Applicative</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2018-11-18 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="68187ada12eaa74a8a6ad75da7354a801a0adc68068719dbb4c4fe2d96e11fab" class="post__content font__body noindent"><h2 id="motivation">Motivation</h2><p><code>Functor</code> solves the problem of mapping regular single-parameter functions into a sub-category, but that’s not easy for functions with more than one parameter.</p><p>Let’s consider a function with two parameters <code>f :: a -&gt; b -&gt; c</code>, which can also read as <code>a -&gt; (b -&gt; c)</code>. Applying <code>fmap</code> on <code>f</code> will yield <code>fmap f :: m a -&gt; m (b -&gt; c)</code>. That’s still distant from what we expect: <code>f&#39; :: m a -&gt; m b -&gt; m c</code>. To get <code>f&#39;</code>, we need a transform from <code>m (b -&gt; c)</code> to <code>m b -&gt; m c</code>. Here we denote it as <code>&lt;*&gt; :: m （b -&gt; c) -&gt; m b -&gt; m c</code>. We will later show that such transform is universal for functions with more parameters.</p><p>Now consider a function with three parameters <code>f :: a -&gt; b -&gt; c -&gt; d</code>. We are going to transform it into a wrapped-value version, with the help of <code>fmap</code> and <code>&lt;*&gt;</code>.</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">f</span> :: a -&gt; b -&gt; c -&gt; d</span><br><span class="line"></span><br><span class="line">(fmap f) :: m a -&gt; m (b -&gt; (c -&gt; d))</span><br><span class="line"></span><br><span class="line">\a_ b_ -&gt; (fmap f a_) &lt;*&gt; b_</span><br><span class="line">    :: m a -&gt; m b -&gt; m (c -&gt; d)</span><br><span class="line"></span><br><span class="line">\a_ b_ c_ -&gt; ((fmap f a_) &lt;*&gt; b_) &lt;*&gt; c_</span><br><span class="line">    :: m a -&gt; m b -&gt; m c -&gt; (m d)</span><br></pre></div></div><p class="par">Here <code>\a_ b_ c_ -&gt; ((fmap f a_) &lt;*&gt; b_) &lt;*&gt; c_</code> is in the desired type. For most of the time, applying parameters directly is actually what we want, instead of the function itself, so the code could simply be written as <code>((fmap f a) &lt;*&gt; b) &lt;*&gt; c</code>, where <code>a</code>, <code>b</code> and <code>c</code> are wrapped values. Parenthesis could be omitted if precedences are set properly, which leads to a neat and easy-to-read form:</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">f</span> `fmap` a &lt;*&gt; b &lt;*&gt; c</span><br></pre></div></div><p class="par">In haskell, <code>fmap</code> has an infix name <code>&lt;$&gt;</code>. So finally we get: <code>f &lt;$&gt; a &lt;*&gt; b &lt;*&gt; c</code>.</p><h2 id="applicative">Applicative</h2><p>Haskell pre-defines a type class <code>Applicative</code>, which captures the pattern of <code>&lt;*&gt;</code>. Any type that implements <code>Applicative</code> works well with <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code>.</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> f =&gt; <span class="hljs-type">Applicative</span> (<span class="hljs-title">f</span> :: * -&gt; *) <span class="hljs-keyword">where</span></span></span><br><span class="line">  pure :: a -&gt; f a</span><br><span class="line">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">  <span class="hljs-type">GHC</span>.<span class="hljs-type">Base</span>.liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</span><br><span class="line">  (*&gt;) :: f a -&gt; f b -&gt; f b</span><br><span class="line">  (&lt;*) :: f a -&gt; f b -&gt; f a</span><br></pre></div></div><p class="par">Note that an <code>Applicative</code> is also a <code>Functor</code>. Apart from <code>&lt;*&gt;</code>, there are some other helper functions or operators in <code>Applicative</code>.</p><p><code>pure</code> is equivalent to the default value constructor of <code>f</code>, e.g. <code>(:[])</code> for <code>List</code> or <code>Just</code> for <code>Maybe</code>. This may be handful when lifting an unwrapped value to a wrapped one.</p><p><code>liftA2</code> transforms a binary operator to the corresponding version. The function exists as binary operators would be frequently passed among high-order functions.</p><p><code>*&gt;</code> takes two wrapped parameters and simply returns the second one, which sequence up two wrapped values. This is quite useful for <code>Applicative</code> with action semantics, such as <code>IO</code>. In fact, it’s so useful that Haskell introduces a syntax sugar for it, known as the <code>do-notation</code>. Particularly:</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">do</span></span><br><span class="line">    putStrLn <span class="hljs-string">&quot;1&quot;</span></span><br><span class="line">    putStrLn <span class="hljs-string">&quot;2&quot;</span></span><br></pre></div></div><p class="par">is equivalent to</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">putStrLn</span> <span class="hljs-string">&quot;1&quot;</span> *&gt; putStrLn <span class="hljs-string">&quot;2&quot;</span></span><br></pre></div></div><p class="par"><code>&lt;*</code> is similar. Both will be reviewed while studying Monad.</p></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-applicative/">READ MORE</a></div></article><article lang="en" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-category-theory-and-functor/">Haskell 笔记：Category Theory and Functor</a></h1><span class="post__lang-tag font__ui">en</span></div><div lang="zh" class="post__meta font__ui">2018-11-18 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="30e6fe9f86787a349f7447182720b783e5cf2d22dc85544c23b6a3fecb11939f" class="post__content font__body noindent"><h2 id="category-theory">Category Theory</h2><p>A category consists of three parts:</p><ul><li>A collection of objects.</li><li>A collection of morphisms, each of which map one object to another.</li><li>A composition operator of these morphisms, i.e. morphisms can be composed. If <code>f: A -&gt; B</code> and <code>g: B -&gt; C</code> are morphisms, <code>f.g</code> generates a new morphism <code>A -&gt; C</code>.</li></ul><p class="par">Note that a morphism has no specific semantics of mapping, but simply links two objects together. Morphisms are also called <strong>Arrows</strong>.</p><h3 id="examples">Examples</h3><h4 id="set-category-set">Set Category: Set</h4><p>All sets and standard functions form a category. Functions need not to be surjective, since morphisms have no mapping semantics.</p><h4 id="group-category-grp">Group Category: Grp</h4><p>All groups and homomorphisms between groups form a category. A group has specific algebaric structure, which morphisms should preserve.</p><h3 id="laws">Laws</h3><p>Three laws that a category should obey:</p><ul><li>Composition should be associative.</li><li>Composition operation should be enclosed in the category, i.e. if <code>f: A -&gt; B</code> and <code>g: B -&gt; C</code>, there must be a <code>h: A -&gt; C</code> satisfying <code>h = f . g</code>.</li><li>For each object <code>A</code>, there should exist an identity morphism <code>id(A): A -&gt; A</code> s.t. for every <code>f: A -&gt; B</code>, <code>f = id(A) . f = f . id(B)</code>.</li></ul><p class="par">Note that:</p><ul><li>There may exist serveral morphisms between <code>A</code> and <code>B</code>.</li><li>An identity has type <code>A -&gt; A</code>, but a morphism with such type needs not to be an identity.</li></ul><h3 id="functors-in-category-theory">Functors in Category Theory</h3><p>A functor maps a category to another category. It should contains two mappings for objects and for morphisms, with composition operation and category laws preserved.</p><p>There’s a trivial functor from Grp to Set, which maps groups to their underlying sets, and group morphisms to functions with same behavior but defined on sets instead of groups.</p><h2 id="paramateric-types-in-haskell">Paramateric Types in Haskell</h2><p>It’s common to create new types that hold values of other types. <code>List[a]</code> type constructor creates types that holds sequential values of same type; <code>Maybe[a]</code> creates types that hold operation states (failure, or success with returned values).</p><p>Usually we expect derived types to inherit functions from types being wrapped. For example, <code>List[Int]</code> should have element-wise addition as <code>Int</code> does, and <code>Maybe[Int]</code> should have similar operations with no burden of re-wrapping and unwrapping. <strong>Such ‘inheritance’ should be done automatically if possible, since it is only concerned with the structure of types instead of specific functions.</strong></p><h2 id="hask-category">Hask Category</h2><p>Haskell language itself forms a category, with <strong>all types</strong> being objects, and functions being morphisms. Such category is called Hask.</p><h2 id="hask-functors">Hask Functors</h2><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> m <span class="hljs-keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; m a -&gt; m b</span><br></pre></div></div><p class="par">A parameteric type implementing class <code>Functor</code> is a category functor, mapping Hask to one of its sub-category, where types <code>m a</code> are the object collection. The type constructor <code>m</code> maps objects, and specific <code>fmap</code> defined on <code>m</code> maps corresponding functions.</p><p>It’s worth noted that <code>(a -&gt; b) -&gt; m a -&gt; m b</code> can also read as <code>(a -&gt; b) -&gt; (m a -&gt; m b)</code>, as <code>-&gt;</code> is right-associative. This may provide a clearer view of <code>fmap</code>, which takes a regular function in Hask and returns the corresponding function in sub-category.</p><p>Examples:</p><p><code>fmap (+) :: List[Int] -&gt; List[Int]</code> generates element-wise addition in <code>List[Int]</code>.</p><p class="par"><code>fmap (+) :: Maybe Int -&gt; Maybe Int</code> generates such function:</p><p class="noindent"></p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">maybePlus</span> :: <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span></span><br><span class="line"><span class="hljs-title">maybePlus</span> _        <span class="hljs-type">Nothing</span>  = <span class="hljs-type">Nothing</span></span><br><span class="line"><span class="hljs-title">maybePlus</span> <span class="hljs-type">Nothing</span>  _        = <span class="hljs-type">Nothing</span></span><br><span class="line"><span class="hljs-title">maybePlut</span> (<span class="hljs-type">Just</span> x) (<span class="hljs-type">Just</span> y) = <span class="hljs-type">Maybe</span> (x + y)</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-category-theory-and-functor/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-data-type-newtype/">Haskell 笔记：data, type, newtype</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-11-16 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="5e5abb7e66ed613bc75b7c17b952c2b029070d903208bd622a481c19025d3b8b" class="post__content font__body noindent"><p>新类型有自己的 data constructor（literals 可以看成特殊的 data constructor），由这一点来区分是否创建了新类型。</p><ul><li><code>data</code> 创建了新类型，可以有多个 data constructor。</li><li><code>newtype</code> 创建了新类型，只能有一个 data constructor，同时新类型的内存布局与原来的类型相同。</li><li><code>type</code> 没有创建新类型，只是建立了 alias，没有新的 data constructor。</li></ul><h2 id="type">type</h2><p>常用于语义化类型，是业务逻辑层的概念。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ID</span> = <span class="hljs-type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">a</span> = <span class="hljs-number">1</span> :: <span class="hljs-type">ID</span></span><br><span class="line"><span class="hljs-title">b</span> = a + <span class="hljs-number">2</span> <span class="hljs-comment">-- legal</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">showID</span> :: <span class="hljs-type">ID</span> -&gt; <span class="hljs-type">IO</span> ()</span><br><span class="line"><span class="hljs-title">showID</span> x = print x <span class="hljs-comment">-- legal, since Int has already been an instance of class Show</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">-- illegal, since Int has already been instantiated</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Show</span> <span class="hljs-type">ID</span> <span class="hljs-keyword">where</span></span></span><br><span class="line">    <span class="hljs-comment">-- ...</span></span><br></pre></div></div><h2 id="newtype">newtype</h2><p>在编译期创建新类型，但差异在运行期被抹去。带有一个构造器。</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">ID&#x27;</span> = <span class="hljs-type">ID&#x27;</span> <span class="hljs-type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">a</span> = <span class="hljs-type">ID&#x27;</span> <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-title">b</span> = a + <span class="hljs-number">2</span> <span class="hljs-comment">-- illegal, since Int and ID&#x27; are totally different types</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-title">showID&#x27;</span> :: <span class="hljs-type">ID&#x27;</span> -&gt; <span class="hljs-type">IO</span> ()</span><br><span class="line"><span class="hljs-title">showID&#x27;</span> x = print x <span class="hljs-comment">-- illegal, since ID&#x27; is not an instance of Show</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">-- either</span></span><br><span class="line"><span class="hljs-title">showID&#x27;</span> (<span class="hljs-type">ID&#x27;</span> x) = print x</span><br><span class="line"><span class="hljs-comment">-- or</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Show</span> <span class="hljs-type">ID&#x27;</span> <span class="hljs-keyword">where</span></span></span><br><span class="line">    show (<span class="hljs-type">ID&#x27;</span> x) = show x</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-data-type-newtype/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/haskell-fold/">Haskell 笔记：folds</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-11-10 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="85c1cc954e75087d4f4e7b89dcf43cf688e894b9ea979c5e7a2df31bdac64398" class="post__content font__body noindent"><h2 id="preludefoldl">Prelude.foldl</h2><p><code>foldl</code> 为 left-associative folding。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl</span> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="hljs-title">foldl</span> f acc [] = acc</span><br><span class="line"><span class="hljs-title">foldl</span> f acc (x:xs) = foldl f (f acc x) xs</span><br></pre></div></div><p class="par"><code>foldl (+) 0 [1..3]</code> 等价于 <code>(((0 + 1) + 2) + 3)</code>。</p><ul><li>尾递归，因此有 strict 版本 <code>foldl&#39;</code></li><li>求值时必须先到达栈底，遍历完列表，因此无法处理无穷列表</li></ul><h2 id="datalistfoldl">Data.List.foldl’</h2><p><code>foldl&#39;</code> 为 <code>foldl</code> 的 TRO 版本。</p><h2 id="preludefoldr">Prelude.foldr</h2><p><code>foldr</code> 为 right-associative folding。</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldr</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="hljs-title">foldr</span> f acc [] = acc</span><br><span class="line"><span class="hljs-title">foldr</span> f acc (x:xs) = f x (foldr f acc xs)</span><br></pre></div></div><p class="par"><code>foldr (+) 0 [1..3]</code> 等价于 <code>(0 + (1 + (2 + 3)))</code></p><ul><li>没有尾递归，有爆栈的危险。</li><li>有向右展开的特点，而 Haskell 中许多数据结构都有向右递归的特点（如 Cons），因此可以很好地处理无穷递归的数据，从而更加通用。</li></ul><h2 id="preludefoldl1--preludefoldr1">Prelude.foldl1 &amp;&amp; Prelude.foldr1</h2><p>Helper functions。将 operator 限制为同一种类型，同时约去 accumulator。</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl1</span> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</span><br><span class="line"><span class="hljs-title">foldl1</span> f (x:xs) = foldl f x xs</span><br><span class="line"><span class="hljs-title">foldl1</span> _ [] = error</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">foldr1</span> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</span><br><span class="line"><span class="hljs-title">foldr1</span> f (x:xs) = foldr f x xs</span><br><span class="line"><span class="hljs-title">foldr1</span> _ [] = error</span><br></pre></div></div><p class="par">即，<code>foldr1</code> 将列表的第一个值作为 accumulator，将剩余部分作为 list，传给 <code>foldr</code>。<code>foldl</code> 同理。</p><h2 id="实践">实践</h2><h3 id="用-folds-实现-reverse">用 folds 实现 <code>reverse</code></h3><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">reversel</span>, reverser :: [a] -&gt; [a]</span><br><span class="line"><span class="hljs-title">reversel</span> list = foldl (\acc x -&gt; x : acc) [] list</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">reverser</span> list = foldr (\x acc -&gt; acc ++ [x]) [] list</span><br></pre></div></div><h3 id="用-foldr-实现-foldl">用 foldr 实现 foldl</h3><p>先归纳出 <code>foldr</code> 的泛性质。如果一个函数 <code>g</code> s.t.</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">g</span> [] = v</span><br><span class="line"><span class="hljs-title">g</span> (x:xs) = f x (g xs)</span><br></pre></div></div><p class="par">则 <code>g list === foldr f v list</code>.</p><p>再看 <code>foldl</code> 的定义：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl</span> f v [] = v</span><br><span class="line"><span class="hljs-title">foldl</span> f v (x:xs) = foldl f (f v x) xs</span><br><span class="line"></span><br><span class="line">===&gt;</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">foldl</span> f v list = g list v</span><br><span class="line">    <span class="hljs-keyword">where</span></span><br><span class="line">        g [] v = v</span><br><span class="line">        g (x:xs) v = g xs (f v x)</span><br><span class="line">        <span class="hljs-comment">-- 从左到右依次更新 v</span></span><br><span class="line"></span><br><span class="line">===&gt;</span><br><span class="line"></span><br><span class="line"><span class="hljs-title">foldl</span> f v list = g list v</span><br><span class="line">    <span class="hljs-keyword">where</span></span><br><span class="line">        g [] = id</span><br><span class="line">        g (x:xs) = \v -&gt; g xs (f v x)</span><br></pre></div></div><p class="par">应有 <code>g (x:xs) === k x (g xs)</code>，我们计算 <code>k</code>：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">g</span> (x:xs)       === k x (g xs)</span><br><span class="line"><span class="hljs-title">g</span> (x:xs) v     === k x (g xs) v</span><br><span class="line"><span class="hljs-title">g</span> xs (f v x)   === k x (g xs) v</span><br><span class="line">(g xs) (f v x) === k x (g xs) v</span><br><span class="line"><span class="hljs-title">g&#x27;</span> (f v x)     === k x g&#x27; v</span><br><span class="line"><span class="hljs-title">k</span>              === \x g&#x27; v -&gt; g&#x27; (f v x)</span><br></pre></div></div><p class="par">所以</p><div class="gk-code hljs" data-gk-id="BLOCK8"><div class="gk-code-display"><pre><span class="line"><span class="hljs-title">foldl</span> f v xs =</span><br><span class="line">    (foldr</span><br><span class="line">        (\x g&#x27; v -&gt; g&#x27; (f v x))</span><br><span class="line">        id</span><br><span class="line">        xs</span><br><span class="line">    ) v</span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/haskell-fold/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/download-in-ubuntu-with-aria/">使用 Aria2 在 Ubuntu 中下载百度云资源</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-06-11 | <span class="post__meta-categories"><a href="/categories/Memo/">Memo</a></span></div><div data-post-id="3877350f3156db84289f4b57bb811f88c1063a8c82e99b2ccd4f0678740bb7a2" class="post__content font__body noindent"><p>可以实现满带宽下载。</p><h1 id="配置-aria2">配置 Aria2</h1><p>从 <a target="_blank" rel="noopener" href="https://github.com/aria2/aria2/releases">Github</a> 下载源码 <code>./configure &amp;&amp; make -j8 &amp;&amp; sudo make install</code>。</p><h1 id="配置-chrome-插件">配置 Chrome 插件</h1><p>clone <code>https://github.com/acgotaku/BaiduExporter</code>。</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">cd</span> ariac</span><br><span class="line">$ <span class="hljs-built_in">cat</span> &gt; start.sh</span><br><span class="line">&gt; <span class="hljs-comment">#!/bin/bash</span></span><br><span class="line">&gt; aria2c --conf=aria2.conf</span><br><span class="line">&gt; ^D</span><br><span class="line">$ <span class="hljs-built_in">chmod</span> +x start.sh</span><br><span class="line">$ ./start.sh</span><br></pre></div></div><h1 id="安装-chrome-插件">安装 Chrome 插件</h1><p>打开 <code>chrome://extensions</code>，<code>Load Unpacked</code> 选择 <code>chrome/release</code>。</p><p>完成后在百度云页面上会有 <code>导出下载</code> 按钮。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/download-in-ubuntu-with-aria/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/python-gil-and-threads/">从伪并行的 Python 多线程说起</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2018-03-10 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="992b305387932c90bb5758e418d5ca8ff16320adc853d7dd4d35440c20edf3b6" class="post__content font__body noindent"><h2 id="写在前面-7">写在前面</h2><ul><li>作者电脑 CPU 为 4 核，因此使用 4 个线程测试是合理的</li><li>本文使用的 <code>cpython</code> 版本为 <code>3.6.4</code></li><li>本文使用的 <code>pypy</code> 版本为 <code>5.9.0-beta0</code>，兼容 Python 3.5 语法</li><li>本文使用的 <code>jython</code> 版本为 <code>2.7.0</code>，兼容 Python 2.7 语法</li><li>若无特殊说明，作语言解时，<code>python</code> 指 Python 语言；作解释器解时，<code>python</code> 指 <code>cpython</code></li></ul></div><div lang="zh" class="post__readmore font__ui"><a href="/python-gil-and-threads/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/caveats-for-signal-handler-in-python/">一个 Reentrant Error 引发的对 Python 信号机制的探索和思考</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2017-08-17 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="a9c9a79948df76fb6d5f5dbd58139f2567b56e6819570413788f4863a8db5cf8" class="post__content font__body noindent"><h2 id="写在前面-5">写在前面</h2><p>前几天工作时遇到了一个匪夷所思的问题。经过几次尝试后问题得以解决，但问题产生的原因却仍令人费解。查找 SO 无果，我决定翻看 Python 的源码。断断续续地研究了几天，终于恍然大悟。撰此文以记。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/caveats-for-signal-handler-in-python/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/linux-file-permissions/">Linux 文件权限</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2017-07-03 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="24fc576ed77be4d8f7865ed343bebae2bbfce9cbf2aa63184447ca513fefc457" class="post__content font__body noindent"><h1 id="概念">概念</h1><p>Linux 中的每一个文件都有其 <strong>所属用户</strong> 及 <strong>所属用户组</strong>，根据这两个属性可将文件访问者分为三类：<strong>所属用户自己</strong>、<strong>所属用户组中的用户</strong> 和 <strong>其他用户</strong>，我们可以针对不同的访问者设置不同的用户权限。</p><p>“访问”可分为三类：<strong>读</strong>、<strong>写</strong> 与 <strong>执行</strong>。我们可以用 <code>ls -l</code> 命令查看一个文件的权限：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">touch</span> <span class="hljs-built_in">test</span></span><br><span class="line">$ <span class="hljs-built_in">ls</span> -l <span class="hljs-built_in">test</span></span><br><span class="line">-rw-rw-r-- 1 hsfzxjy hsfzxjy 0 Jul  3 23:44 <span class="hljs-built_in">test</span></span><br></pre></div></div><p class="par">首部的 <code>-rw-rw-r--</code> 即为文件的权限位。权限应该分为四部分来看：<code>-/rw-/rw-/r--</code>。第一部分标志文件的类型，如 普通文件（<code>-</code>）、目录（<code>d</code>）、UNIX 套接字（<code>s</code>）、符号链接（<code>l</code>）、块设备（<code>b</code>）等等。接下来的三个部分依次代表 <strong>所属用户</strong>、<strong>所属用户组</strong>、<strong>其他用户</strong> 的权限，每部分由三个标志位组成：<strong>读标志位</strong>、<strong>写标志位</strong>、<strong>执行标志位</strong>。</p><h1 id="目录的权限">目录的权限</h1><p>目录是一种特殊的文件，因此也拥有文件权限的概念，但权限的语义与普通文件稍有差异：</p><ul><li>读：读取目录下文件列表，相关命令如 <code>ls</code></li><li>写：创建、删除目录下的文件，相关命令如 <code>touch</code>（当文件不存在时）、<code>rm</code> 等</li><li>执行：进入目录，相关命令如 <code>cd</code></li></ul><h1 id="特殊权限">特殊权限</h1><p>出于某些特殊目的，Linux 中存在两个特殊的权限位：粘滞位（<code>t</code>）、Set Id（<code>s</code>）。这两个权限可以 <strong>叠加</strong> 在执行权限位上，其中 Set Id 可以置于 <strong>所属用户</strong> 和 <strong>所属用户组</strong> 的权限组上，而 粘滞位 只能置于 <strong>其他用户</strong> 权限组上。当特殊权限被设置时，执行权限位上即会显示 <code>s/t</code> （已有 <code>x</code> 权限）或 <code>S/T</code> （尚未有 <code>x</code> 权限）。</p><h2 id="粘滞位">粘滞位</h2><p>粘滞位的作用是 <strong>防止他人误删自己的文件</strong>。当某个目录的其他用户权限组有 <code>w</code> 权限时，系统中的其他用户即可随意删除目录中的文件。而一旦叠加上 <code>t</code> 权限，只有文件的所有者方能删除文件。一个经典的例子是 <code>/tmp</code>：</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">ls</span> -l /</span><br><span class="line">drwxrwxrwt  13 root root 12288 Jul  4 00:15 tmp/</span><br></pre></div></div><h2 id="set-id">Set Id</h2><p>Linux 中的进程也有自己所属用户与用户组。一般而言，进程的所属用户即为其发起者，但这会引起一些麻烦。一个例子是 <code>passwd</code> 命令，该命令需要修改属于 <code>root</code> 用户的系统文件以保存密码，倘若进程所属用户即为所属者，此功能则无法实现。</p><p>Set Id 权限的作用是：在文件被执行时，将其有效用户/用户组设置为文件的用户/用户组，而不是当前执行者。下面是一个演示：</p><p>设当前用户为 <code>hsfzxjy</code>，我们在 <code>/tmp</code> 下创建一个 <code>test</code> 文件，并删去其他用户的 <code>r</code> 权限：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">cd</span> /tmp</span><br><span class="line">$ <span class="hljs-built_in">echo</span> <span class="hljs-built_in">test</span> text &gt; <span class="hljs-built_in">test</span></span><br><span class="line">$ <span class="hljs-built_in">chmod</span> o-r <span class="hljs-built_in">test</span></span><br><span class="line">$ ll <span class="hljs-built_in">test</span></span><br><span class="line">-rw-rw---- 1 hsfzxjy hsfzxjy 0 Jul  4 00:28 <span class="hljs-built_in">test</span></span><br></pre></div></div><p class="par">由于 <code>test</code> 文件的所属用户是 <code>hsfzxjy</code>，其他用户没有权限读取其中的内容：</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line">$ sudo -u mysql <span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span></span><br><span class="line"><span class="hljs-built_in">cat</span>: <span class="hljs-built_in">test</span>: Permission denied</span><br></pre></div></div><p class="par">现在我们修改一下 <code>cat</code> 命令的权限，为了不影响系统文件，我们拷贝一份 <code>cat</code> 副本至当前目录：</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line">$ <span class="hljs-built_in">cp</span> /bin/cat .</span><br><span class="line">$ <span class="hljs-built_in">chmod</span> u+s <span class="hljs-built_in">cat</span></span><br><span class="line">$ ll <span class="hljs-built_in">cat</span></span><br><span class="line">-rwsr-xr-x 1 hsfzxjy hsfzxjy 52080 Jul  4 00:34 <span class="hljs-built_in">cat</span>*</span><br></pre></div></div><p class="par">再以 <code>mysql</code> 的身份执行命令：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line">$ sudo -u mysql ./cat <span class="hljs-built_in">test</span></span><br><span class="line"><span class="hljs-built_in">test</span> text</span><br></pre></div></div><p class="par">可见 <code>./cat</code> 在执行时所属用户是 <code>hsfzxjy</code>。我们可以使用 <code>ps</code> 命令更清楚地看到这点：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line">$ sudo -u mysql <span class="hljs-built_in">cat</span></span><br><span class="line"><span class="hljs-comment"># 在另一个终端中</span></span><br><span class="line">$ ps -eo euser,ruser,<span class="hljs-built_in">comm</span> | grep <span class="hljs-built_in">cat</span></span><br><span class="line">mysql    mysql    <span class="hljs-built_in">cat</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -----------</span></span><br><span class="line"></span><br><span class="line">$ sudo -u mysql ./cat</span><br><span class="line"><span class="hljs-comment"># 在另一个终端中</span></span><br><span class="line">$ ps -eo euser,ruser,<span class="hljs-built_in">comm</span> | grep <span class="hljs-built_in">cat</span></span><br><span class="line">hsfzxjy  mysql    <span class="hljs-built_in">cat</span></span><br></pre></div></div></div><div lang="zh" class="post__readmore font__ui"><a href="/linux-file-permissions/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/HSFZMUN-4.0-configuration/">HSFZMUN 4.0 部署小记</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2017-02-25 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="6bc9dac75b60f8c50025ec857da1106ba093a8cb99336ac380bdce50416ed054" class="post__content font__body noindent"><blockquote><p>技术流水账一篇，记录踩过的坑</p></blockquote><h2 id="channels-异构-1">Channels 异构</h2><p>Django Channels 官方文档宣称 channels 的最佳配置是使用其自带的服务器组件 Daphne，但在开发中我发现 daphne 处理普通请求比在 WSGI 架构下慢了好几倍，更何况使用 daphne 派发静态文件是十分不切实际的。于是我将 <code>http.request</code> 和 <code>websocket.*</code> 两个 channel 解耦，前者使用 nginx 配合 uwsgi 处理，后者使用 nginx 反向代理至 daphne 处理。这样一来便可充分利用两种架构的优势。</p><p><strong>旧架构：</strong></p><p><img loading="lazy" src="/assets/django-channels-configuration/old-arch.png" alt=""></p><p><strong>新架构：</strong></p><p><img loading="lazy" src="/assets/django-channels-configuration/new-arch.png" alt=""></p></div><div lang="zh" class="post__readmore font__ui"><a href="/HSFZMUN-4.0-configuration/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/raining-in-ustc/">午后雨·科大</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-08-22 | <span class="post__meta-categories"><a href="/categories/Life/">Life</a></span></div><div data-post-id="2ae23517fa08b5c5a03bce738d2b613651b035860c0357ab38446ba0bce5de3e" class="post__content font__body"><p>从昏睡中惊醒——现在是下午，屋内却很昏暗。屋外，隐约有一阵持续的背景噪音，我拉开窗帘，只见白茫茫的一片。</p><p>下雨了，而且是大暴雨。</p><p>打开窗，一股辛辣扑面而至——雨和着尘土的气息，再熟悉不过了。伴随着辛辣，一种沁人心脾的清凉涌入屋内，稀释着绿军衣挥发的氨味，一同驱走的，还有午后应有的烦躁。</p><p>八月的这里，原来可以不那么热。</p><p>一直以为，旱和热是这里夏天的常态。走出机场时，第一感受，也是几天来唯一的感受，便是热——无风的热，黏人；无云的热，灼人。想到将在这样的地方生活，心中顿生怯意——</p><p>但现在看来，似乎并不那么糟。</p><p>合上窗，雨声再次成为背景音。白色的水汽慢慢爬上玻璃，模糊了摇曳的树，漫水的街，雨中的整个世界。</p><p>这一幕似乎很熟悉。</p><p>没错，在更早些的时候，当我还在另一个校园时。那是个多雨的城市，雨大而急。记忆中，不知有多少次，也是透过模糊的窗，看着屋外湿透的一切。</p><p>面对暴雨，心中有过埋怨，有过恐惧，有过敬畏——但此时，我却体会到了偶遇老友般的亲切。</p><p>在陌生的校园，我又遇到了熟悉的雨。</p><p>我开始喜欢这里了。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/raining-in-ustc/">READ MORE</a></div></article></div><div lang="zh" class="page-navigator font__ui"><span class="page__button"><a href="/page/7/" class="pre">PREV</a></span><span class="page__button"><a href="/page/9/" class="next">NEXT</a></span></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon current"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item current"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>