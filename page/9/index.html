<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><title>hsfzxjy 的博客</title><meta itemprop="title" content="hsfzxjy 的博客"><meta itemprop="og:title" content="hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/">Home</a></div></nav><main class="mainContainer"><div class="post-list"><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/leaving-guangzhou/">最后的雨夜·广州</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-08-18 | <span class="post__meta-categories"><a href="/categories/Life/">Life</a></span></div><div data-post-id="1f748e925bb384dc4a9ff37a8c781823e8842ab76fed422e3a3be06239d78cda" class="post__content font__body"><p>明天就要走了。</p><p>我贪婪地呼吸着这座城市，想要记住一切。</p><p>这是一个雨夜。雨不大，淅淅沥沥的，一反八月羊城的狂暴。雨丝划过夜空，拂去了暑气，夹带着一丝清冽；雨点打在地上，泛起一阵辛辣，这是雨的独特气息。昔日湿热而令人厌烦的南方雨，此刻却如此亲近。</p><p>步入校园，城市的灯光隐去了，笼下来的是夜的静谧。走在林荫道，可以闻到空中漫着的甘甜——这是芒果花的香气。</p><p>记忆中，最为深刻的花香便是芒果花。这种热带的植物，在羊城开得到处都是——在童年的大院里，在中学的校道里，在这邻近的大学里，在记忆中的每一个角落。游子最难以忘怀的，当属这南国的果香。</p><p>出了大学的门，转过街角，城市的灯又亮了。这是学校后门的一条食街，寄存了我六年的回忆。</p><p>那股诱人的酸菜味，来自一家无名的东北菜馆。“15 块吃到饱”。豪爽的东北大叔，曾在那个三月给予我信心。</p><p>空中那悠扬的，是全家的迎客铃。数不清有多少个早晨，因匆忙而在此买饭团。一口咬下，让柴鱼的美味充盈鼻腔，让翻腾的蒸汽吹走清晨的倦意。</p><p>远处是那家熟悉的 M 记。24 小时永不停歇。在这里，我度过了高三的每个周末，一份板烧一杯咖啡，一小时的免费 wifi，抹去一上午的沮丧，换来下午持续的好心情。</p><p>再往前便是学校。此时正值军训，校园里却一片静寂——也许是太晚了。六年前，梦从这里开始；六年后，我又将梦重新埋在这里。</p><p>雨下大了，我却不急——毕竟，我将去往一个少雨的城市，这里的雨，我要细细记忆。</p><p>这是一座现代化的都市。雨中的光光影影，雨中 BRT 的笛鸣，雨中泛着的柏油气息，都是这座城市的印记。</p><p>这是一座古老的城市。人们仍执念于古老的语言，过着悠然的生活。饱经沧桑，却历久弥新。</p><p>天一亮，我就将去往一个陌生的城市。那里少雨，泛着中原常见的普通。我将在那里度过四年，甚至更久。</p><p>而在此之前，一个恋家的动物，要努力带走所有的回忆。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/leaving-guangzhou/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/uncover-the-secret-of-fast-inverse-square-root-algorithm/">揭秘·变态的平方根倒数算法</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-08-03 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="4beeb2727e641d28d36b99057bf1a0a2e83ff8c06ee3e538b41e2388cba39143" class="post__content font__body noindent"><blockquote><p>神的时代已离去 神的故事却化为传说 流落凡间 供凡人传颂、膜拜</p></blockquote><h2 id="这是什么-1">这是什么</h2><p>在上世纪 90 年代，出现过一款不可思议的游戏——雷神之锤（Quake series）。除了优秀的情节设定和精美的画面，最让人称道的莫过于它的运行效率——要知道在那个计算机配置低下的时代，一段小动画都是一个奇迹，但 Quake 却能流畅地运行于各种配置的电脑上。</p><p>直至 2005 年，当 Quake Engine 开源时，Quake 系列的秘密才被揭开。在代码库中，人们发现了许多堪称神来之笔的算法。它们以极其变态的高效率，压榨着计算机的性能，进而才支撑起了 90 年代 3D 游戏的传奇。其中的某些算法，甚至比系统原生的实现还要快！</p><p>我们今天的主角——快速平方根倒数算法（Fast Inverse Square Root）就是其中一个。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/uncover-the-secret-of-fast-inverse-square-root-algorithm/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/recursively-calling-when-decorating-a-python-class/">神坑·Python 装饰类无限递归</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-07-30 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="e90efe4b28286f6a54ae00756688cef183df7bb91dd54f10e4ec212427095f24" class="post__content font__body noindent"><blockquote><p>《神坑》系列将会不定期更新一些可遇而不可求的坑 防止他人入坑，也防止自己再次入坑</p></blockquote><h2 id="简化版问题">简化版问题</h2><p>现有两个 <code>View</code> 类：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-comment"># Do something...</span></span><br><span class="line">        <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildView</span>(<span class="hljs-title class_ inherited__">View</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-comment"># Do something else ...</span></span><br><span class="line">        <span class="hljs-built_in">super</span>(ChildView, self).method()</span><br></pre></div></div><p>以及一个用于修饰该类的装饰器函数 <code>register</code>——用于装饰类的装饰器很常见（如 <code>django.contrib.admin</code> 的 <code>register</code>），通常可极大地减少定义相似类时的工作量：</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mixin</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">cls</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(</span><br><span class="line">        <span class="hljs-string">&#x27;DecoratedView&#x27;</span>,</span><br><span class="line">        (Mixin, cls),</span><br><span class="line">        {}</span><br><span class="line">    )</span><br></pre></div></div><p>这个装饰器为被装饰类附加上一个额外的父类 <code>Mixin</code>，以增添自定义的功能。</p><p>完整的代码如下：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mixin</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">cls</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(</span><br><span class="line">        cls.__name__,</span><br><span class="line">        (Mixin, cls),</span><br><span class="line">        {}</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-comment"># Do something...</span></span><br><span class="line">        <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@register</span></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildView</span>(<span class="hljs-title class_ inherited__">View</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-comment"># Do something else ...</span></span><br><span class="line">        <span class="hljs-built_in">super</span>(ChildView, self).method()</span><br></pre></div></div><p>看上去似乎没什么问题。然而一旦调用 <code>View().method()</code>，却会报出诡异的 无限递归 错误：</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-comment"># ...</span></span><br><span class="line">File <span class="hljs-string">&quot;test.py&quot;</span>, line <span class="hljs-number">23</span>, <span class="hljs-keyword">in</span> method</span><br><span class="line">  <span class="hljs-built_in">super</span>(ChildView, self).method()</span><br><span class="line">File <span class="hljs-string">&quot;test.py&quot;</span>, line <span class="hljs-number">23</span>, <span class="hljs-keyword">in</span> method</span><br><span class="line">  <span class="hljs-built_in">super</span>(ChildView, self).method()</span><br><span class="line">File <span class="hljs-string">&quot;test.py&quot;</span>, line <span class="hljs-number">23</span>, <span class="hljs-keyword">in</span> method</span><br><span class="line">  <span class="hljs-built_in">super</span>(ChildView, self).method()</span><br><span class="line">RuntimeError: maximum recursion depth exceeded <span class="hljs-keyword">while</span> calling a Python <span class="hljs-built_in">object</span></span><br></pre></div></div><p>【一脸懵逼】</p><h2 id="猜想--验证">猜想 &amp; 验证</h2><p>从 Traceback 中可以发现：是 <code>super(ChildView, self).method()</code> 在不停地调用自己——这着实让我吃了一惊，因为 <strong>按理说 <code>super</code> 应该沿着继承链查找父类</strong>，可为什么在这里 <code>super</code> 神秘地失效了呢？</p><p>为了验证 <code>super(...).method</code> 的指向，可以尝试将该语句改为 <code>print(super(ChildView, self).method)</code>，并观察结果：</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line">&lt;bound method ChildView.method of &lt;__main__.ChildView <span class="hljs-built_in">object</span> at <span class="hljs-number">0xb70fec6c</span>&gt;&gt;</span><br></pre></div></div><p>输出表明： <strong><code>method</code> 的指向确实有误</strong>，此处本应为 <code>View.method</code>。</p><p><code>super</code> 是 python 内置方法，肯定不会出错。那，会不会是 <code>super</code> 的参数有误呢？</p><p><code>super</code> 的签名为 <code>super(cls, instance)</code>，宏观效果为 <strong>遍历 <code>cls</code> 的继承链查找父类方法，并以 <code>instance</code> 作为 <code>self</code> 进行调用</strong>。如今查找结果有误，说明 <strong>继承链是错误的</strong>，因而极有可能是 <code>cls</code> 出错。</p><p>因此，有必要探测一下 <code>ChildView</code> 的指向。在 <code>method</code> 中加上一句： <code>print(ChildView)</code>：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line">&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.DecoratedView&#x27;</span>&gt;</span><br></pre></div></div><p>原来，作用域中的 <code>ChildView</code> 已经被改变了。</p><h2 id="真相">真相</h2><p>一切都源于装饰器语法糖。我们回忆一下装饰器的等价语法：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line"><span class="hljs-meta">@decorator</span></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span>:</span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br></pre></div></div><p>等价于</p><div class="gk-code hljs" data-gk-id="BLOCK8"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span>:</span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line">Class = decorator(Class)</span><br></pre></div></div><p>这说明：<strong>装饰器会更改该作用域内被装饰名称的指向</strong>。</p><p>这本来没什么，但和 <code>super</code> 一起使用时却会出问题。通常情况下我们会将本类的名称传给 <code>super</code>（在这里为 <code>ChildView</code>），而本类名称和装饰器语法存在于同一作用域中，从而在装饰时被一同修改了（在本例中指向了子类 <code>DecoratedView</code>），进而使 <code>super(...).method</code> 指向了 <code>DecoratedView</code> 的最近祖先也就是 <code>ChildView</code> 自身的 <code>method</code> 方法，导致递归调用。</p><h2 id="解决方案">解决方案</h2><p>找到了病因，就不难想到解决方法了。核心思路就是：<strong>不要更改被装饰名称的引用</strong>。</p><p>如果你只是想在内部使用装饰后的新类，可以在装饰器方法中使用 <code>DecoratedView</code>，而在装饰器返回时 <code>return cls</code>，以保持引用不变：</p><div class="gk-code hljs" data-gk-id="BLOCK9"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">cls</span>):</span><br><span class="line"></span><br><span class="line">    decorated = <span class="hljs-built_in">type</span>(</span><br><span class="line">        <span class="hljs-string">&#x27;DecoratedView&#x27;</span>,</span><br><span class="line">        (Mixin, cls),</span><br><span class="line">        {}</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># Do something with decorated</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> cls</span><br></pre></div></div><p>这种方法的缺点是：从外部无法使用 <code>ChildView.another_method</code> 调用 <code>Mixin</code> 上的方法。可如果真的有这样的需求，可以采用另一个解决方案：</p><div class="gk-code hljs" data-gk-id="BLOCK10"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">cls</span>):</span><br><span class="line"></span><br><span class="line">    cls.another_method = Mixin.another_method</span><br><span class="line">    <span class="hljs-keyword">return</span> cls</span><br></pre></div></div><p>即通过赋值的方式为 <code>cls</code> 添加 <code>Mixin</code> 上的新方法，缺点是较为繁琐。</p><p>两种方法各有利弊，要根据实际场景权衡使用。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/recursively-calling-when-decorating-a-python-class/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/python-encoding-and-decoding/">Python“黑魔法”之 Encoding &amp; Decoding</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-07-21 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="151c383b4228a9a284d0f025a8bd6040be3559a0a3f370fb64c61fe8f11d33ad" class="post__content font__body noindent"><h2 id="写在前面-3">写在前面</h2><blockquote><ul><li>本文为科普文</li><li>本文中的例子在 Ubuntu 14.04 / Python 2.7.11 下运行成功，Python 3+ 的接口有些许不同，需要读者自行转换</li></ul></blockquote><h2 id="引子-4">引子</h2><p>先看一段代码：</p><p><code>example.py</code>：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"># -*- conding=yi -*-</span><br><span class="line"></span><br><span class="line">从 math 导入 sin, pi</span><br><span class="line"></span><br><span class="line">打印 &#x27;sin(pi) =&#x27;, sin(pi)</span><br></pre></div></div><p>这是什么？！是 Python 吗？可以运行吗？——想必你会问。</p><p>我可以明确告诉你：这不是 Python，<strong>但它可以用 Python 解释器运行</strong>。当然，如果你愿意，可以叫它“Yython” （易语言 + Python）。</p><p><img loading="lazy" src="//sf.gg/img/bVzuHw" alt=""></p><p>怎么做到的？也许你已经注意到第一行的奇怪注释——没错，秘密全在这里。</p><p>这种黑魔法，还要从 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0263/">PEP 263</a> 说起。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/python-encoding-and-decoding/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/alternative-key-maps-under-ubuntu/">Ubuntu 重新映射键盘布局</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-06-05 | <span class="post__meta-categories"><a href="/categories/Memo/">Memo</a></span></div><div data-post-id="145b4c12caa5c49d3933f6b1b495e31edc6e3afc2b296dda630a0731ae7555f0" class="post__content font__body noindent"><p>键盘持续失灵，已经到了让我忍无可忍的地步了。</p><p>刚开始只是方向键失灵，好在可以用小键盘替代；后来右 Ctrl 和 Alt 也失灵了，好在可以用左边的替代；直到最近 Fn 键也失灵了，终于逼疯了我——因为这意味着 F1 ～ F12 都将不能使用。</p><p>我曾试图寻找方法将 CapsLock 键映射为 Fn 键映射，但失败了——Fn 键消息是由 BIOS 拦截的，无法被操作系统捕获。</p><p>但今天我找到了一个更好的替代方案：</p><ul><li>交换 Fn 和 Ctrl。这是唯一一种能让 Fn 键移位的方式，在所有的 BIOS 中都可以设置。</li><li>将 CapsLock 映射为 Ctrl。反正 CapsLock 闲着也是闲着，不如用它代替坏了的键。</li></ul><p>ubuntu 下需要执行：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line">setxkbmap -layout us -option ctrl:nocaps</span><br></pre></div></div><p class="par">参考： <a target="_blank" rel="noopener" href="http://askubuntu.com/questions/462021/how-do-i-turn-caps-lock-into-an-extra-control-key">How do I turn Caps Lock into an extra Control key? - Ask Ubuntu</a></p></div><div lang="zh" class="post__readmore font__ui"><a href="/alternative-key-maps-under-ubuntu/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/why-I-choose-to-climb-over-the-wall/">为什么我要翻墙</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-04-09 | <span class="post__meta-categories"><a href="/categories/Soliloquy/">Soliloquy</a></span></div><div data-post-id="5e4d7d3419d83190f02fb8d05b05f9844e7247b1f46804498bcfc5873a4c5d63" class="post__content font__body"><p>很多人不解为什么我要翻墙。他们认为，国家明令禁止的东西就不应该去做——而更何况，墙内的世界已经足够精彩，异世界的天空也不一定令人神往。</p><p>在中国大陆，能上网的人被分为两类：翻墙的 与 不翻墙的。这里说的“翻墙”不是“有能力翻墙”，而是“有意愿翻墙”。这两类人奇怪地构成了一个鄙视环。翻墙的 看不起 不翻墙的，认为后者甘于“虚假”的现状。其中不乏有狂热的传教者，不遗余力地宣传墙外的世界，并对不接受者嗤之以鼻；同时，不翻墙的 又鄙视 翻墙的，认为后者崇洋媚外，被国外反华势力蛊惑，以致对 翻墙 产生如信仰宗教般的虔诚。</p><p>对于不理解我的人，我表示理解。如果我也以你们的身份生活在你们的环境，墙内的世界的确很大、很精彩，的确足够了。再者，翻墙 很麻烦、很不稳定，牺牲流畅性与易用性去浏览一些无趣的内容，确实不值得。</p><p>但我想说的是：墙内的世界对于某些人而言，贫乏得可伶。</p><p>我喜欢编程。与写作不同的是，编程不仅要靠思考，更需要一些外部工具的辅助。思维是编程工作的灵魂，但思维仅仅提供了一个脉络，在思维的引领下，我需要组合使用各种工具来解决问题。工具的数量很多，细节很复杂，我不可能记住，也不应该都记住。因此，我需要搜索它们的使用说明。一个好的搜索引擎是编程时必备的利器，而我选择了 Google。不是因为我崇洋媚外，而是 它 <strong>的确</strong> 能高效地让我找到答案，解决我的问题。</p><p>我要翻墙，因为我想要的工具在墙内不存在。同时，有一些我想要的答案也在墙外（如 Wikipedia）或部分在墙外（如 引用了 Google CDN 的 StackOverflow）或时不时在墙外（如 Github）。当你的合理需求无法满足时，理智的人都会想方设法地去满足——这很自然，就像吃完了一片草地的羊群会自动迁徙至另一片草地一样。</p><p>是的，我翻墙，只是因为我有翻墙的需求。对于某些翻墙发烧友所推荐的某些“真相”，我不感兴趣。隐匿的东西之所以被隐匿，总有它的理由；而被揭露的东西之所以被揭露，也总有他们的目的。</p><p>百度作的恶，不能原谅。但抛开这一点，我并不排斥百度。百度不如 Google 科学，但它更适合中国。西方人更注重逻辑思维，同时他们也有更高的受教育程度，科学的 Google 是他们所需要的。而在中国，真正需要科学的只有很少一部分人，更多的人需要的只是科普，一个浅显的答案，只要结论正确，甚至不需要完全严密的推理，足够了。更何况，中国的网络是一个娱乐至上的环境，一个八卦的搜索引擎也许会比一个严谨刻板的搜索引擎更受国人青睐。</p><p>对于 GFW，即 墙 本身，我也不怨恨。起初接触到这样一个存在时，我很惊讶，感叹国家还有这样的一面。这个无形的庞然大物产生于旧世纪末，有其特定的时代背景，被人诟病的同时却也有着它的合理性。有人认为，思想自由是人权的一部分，GFW 的存在是反人类的。有段时间我信以为然，并传播这样的思想。但当我真实地接触到那些“被禁锢的人”时，我却犹豫了。前段时间的“诺贝尔哥”事件就是一个很好的样例。<strong>游荡在网络中的许多中国人是不理智的</strong>——尽管他们也受过教育，但接受的只是知识，而不是思维。他们甚至不知逻辑为何物。这些人看起来是无害的，可一旦他们接触到所谓的“真相”，或说是一些人想让我们接触到的“真相”时，感性会使他们意气用事，造成社会的不稳定。诚然，人权至上，但社会稳定更重要，人权在乱世只是一纸空话。历史的对错，国家自己知道。民众应该知道历史，但如果真相会对现实产生不可预测的坏影响，倒不如让它烂在土里。</p><p>我不嘲笑 不翻墙 的人，他们扮演着自己的角色，有着自己的需求与选择；我也会继续 翻墙，因为我有这样的需要。</p><p>驱使一切的，只是需求而已。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/why-I-choose-to-climb-over-the-wall/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/python-generator-coroutine/">Python“黑魔法”之 Generator Coroutines</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-04-02 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="827734dab0d26b6be6c4a7f510d58190898036968bd09ec6036ea7f282cc0950" class="post__content font__body"><h2 id="写在前面-1">写在前面</h2><blockquote><ul><li>本文默认读者对 Python 生成器 有一定的了解，不了解者请移步至<a target="_blank" rel="noopener" href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000">生成器 - 廖雪峰的官方网站</a>。</li><li>本文基于 Python 3.5.1，文中所有的例子都可在 <a target="_blank" rel="noopener" href="https://github.com/hsfzxjy/python-generator-coroutine-examples">Github</a> 上获得。</li></ul></blockquote><p>学过 Python 的都知道，Python 里有一个很厉害的概念叫做 生成器（Generators）。一个生成器就像是一个微小的线程，可以随处暂停，也可以随时恢复执行，还可以和代码块外部进行数据交换。恰当使用生成器，可以极大地简化代码逻辑。</p><p>也许，你可以熟练地使用生成器完成一些看似不可能的任务，如“无穷斐波那契数列”，并引以为豪，认为所谓的生成器也不过如此——那我可要告诉你：这些都太小儿科了，下面我所要介绍的绝对会让你大开眼界。</p><p><strong>生成器 可以实现 协程，你相信吗？</strong></p></div><div lang="zh" class="post__readmore font__ui"><a href="/python-generator-coroutine/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/the-simplest-way-to-find-out-if-two-segments-are-intersected/">数学美 之 判断线段相交的最简方法</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-02-19 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="0c005884f1c7662efc088db3dc922e5a566dfb69588ce49404ac177ef4d3dea9" class="post__content font__body"><blockquote><p class="par">解析几何的巅峰 是 向量 那无关过程的狂妄与简洁 映射着大自然无与伦比的美</p></blockquote><h2 id="引子-2">引子</h2><p>如何判断两条直线是否相交？</p><p>这很容易。平面直线，无非就是两种关系：相交 或 平行。因此，只需判断它们是否平行即可。而直线平行，等价于它们的斜率相等，只需分别计算出它们的斜率，即可做出判断。</p><p>但倘若我把“直线”换成“线段”呢——如何判断两条线段是否相交？</p><p>这就有些难度了。和 直线 不同，线段 是有固定长度的，即使它们所属的两条直线相交，这两条线段也不一定相交。</p><p>也许你会说：分情况讨论不就行了嘛：</p><ul><li>先计算两条线段的斜率，判断是否平行。若平行，则一定不相交。</li><li>若不平行，求出两条线段的直线方程，联立之，解出交点坐标。</li><li>运用定比分点公式，判断交点是否在两条线段上。</li></ul><p>的确，从理论上这是一个可行的办法，这也是人们手动计算时普遍采用的方法。</p><p>然而，这个方法并不怎么适用于计算机。原因如下：</p><ul><li>计算中出现了除法（斜率计算、定比分点），因此每次计算前都要判断除数是否为 0（或接近 0）。这很麻烦，严重干扰逻辑的表达。</li><li>浮点精度丢失带来的误差。人类计算时可以采用分数，但计算机不行。计算机在储存浮点数时会有精度丢失的现象。一旦算法的计算量大起来，误差会被急剧放大，影响结果准确性。</li><li>效率低下。浮点乘除会十分耗时，不适用于对实时性要求较高的生产环境（如 游戏）。</li></ul><p class="noindent">那么，有更好的方法？</p><p class="noindent">当然有。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/the-simplest-way-to-find-out-if-two-segments-are-intersected/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/thinking-in-the-day-before-lunar-new-year-of-2016/">除夕杂感</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-02-13 | <span class="post__meta-categories"><a href="/categories/Life/">Life</a></span></div><div data-post-id="1dd54f0a0bda69b1c2ebb94ef3857031a4153ad5fd693a77916ad92bfb24be5a" class="post__content font__body"><p>直到下午四点，供桌才摆上。</p><p>冒着热气的鸡，整只；两尾鱼，张着嘴卧在盘中；一摞柑，愣是叠成了宝塔的形状；此外，还有一包包花花绿绿的零食。一米见方的桌子被塞得满满的，全是贡品。</p><p>母亲忙得团团转。本来是不想拜天公的，但转念一想，不是太好，便摆上了。阳光下，热气一直往上冒，往上冒，直到看不见的地方——那里，想必就住着那位神。</p><p>看来，这位神一定是个重要人物了——不然，母亲怎会遗忘了其他的几位，而只供奉他一个？</p><p>搬家之前，家里可还是住着许多神的：门口有一个，阳台上有一个，厨房有一个，抽屉下有一个，就连洗衣机上也有一个。听母亲说：每一家都有，每一位神，都在守卫着这个家。</p><p>神们也不是白干活，也是要吃饭的。不只是过年，每个月中总有那么几天，神们会一起来要吃的。每到这时，母亲便会忙活起来，为他们张罗吃的。好在他们并不挑剔——生的，熟的，速食的，神们都默默地收下了。当然，贡品在屋子里转了一圈，自然又都进到了我们的肚子里。</p><p>每换一个地方，母亲便上一炷香，虔诚地跪下来，轻轻地拜两拜，口中念念有词。</p><p>接着，她又拉我一起来。</p><p>我不懂，她便教我——想着自己想要的事就好了。</p><p>我学着样子跪下来，胡乱说了几句，装模作样地拜了两拜，余光却仍盯着那食物。</p><p>听母亲说，这是老家带来的习俗。对神的敬畏，在那个古老的地方，说着那古老语言的人们，已经沿袭了很久很久了。</p><p>人终是怕神的——以前是，现在也是；中国是，外国也是。神像一群喜欢偷窥的人，在这里，也在那里，在每个角落偷窥着你。你受欺负时，神会给你庇护；你做坏事时，神会予你惩罚。因此，怕神的人，多是善良的。</p><p>说是怕神，倒不如说是怕天，敬畏变幻莫测的未知。活物总是怀着对死亡的恐惧，人类也不例外。未知中蕴藏着杀机，使愚昧的人类感到不安，转而求助于那假象中的造物主，那超能力者，那个开着全局视角看戏的“人”，这便成了“神”。神为人类抵挡着未知，人类也因此安分守己，深怕触犯了神，再次被暴露于未知的荒野中。</p><p>然而，神正在离去，因为未知正在散去。</p><p>但藏在那未知背后的是什么，谁又知道呢？未知的背后仍是未知，现实可以是虚幻，真理也可以是谬误，时间洪流夹带着未知，使任何人都只能屏息，任何人，都不可以妄自尊大。</p><p>好在，还有神——尽管神正在离去。</p><p>但终究，怕神的人是善良的。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/thinking-in-the-day-before-lunar-new-year-of-2016/">READ MORE</a></div></article><article lang="zh" class="post"><div class="post__title-block"><h1 class="post__title"><a href="/a-simple-javascript-template-language/">17 行代码实现的简易 Javascript 字符串模板</a></h1><span class="post__lang-tag font__ui">zh</span></div><div lang="zh" class="post__meta font__ui">2016-02-12 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div data-post-id="5cae892c4eb9dd89519af38046461ab0f876f1b4bef2c8f313c887c0f5ad3567" class="post__content font__body"><p>这是源于两年前，当我在做人生中第一个真正意义上的网站时遇到的一个问题。该网站采用前后端分离的方式，由后端的 REST 接口返回 JSON 数据，再由前端渲染到页面上。</p><p>同许多初学 Javascript 的菜鸟一样，起初，我也是采用拼接字符串的形式，将 JSON 数据嵌入 HTML 中。开始时代码量较少，暂时还可以接受。但当页面结构复杂起来后，其弱点开始变得无法忍受起来：</p><ul><li><strong>书写不连贯</strong>。每写一个变量就要断一下，插入一个 <code>+</code> 和 <code>&quot;</code>。十分容易出错。</li><li><strong>无法重用</strong>。HTML 片段都是离散化的数据，难以对其中重复的部分进行提取。</li><li><strong>无法很好地利用 <code>&lt;template&gt;</code> 标签</strong>。这是 HTML5 中新增的一个标签，标准极力推荐将 HTML 模板放入 <code>&lt;template&gt;</code> 标签中，使代码更简洁。</li></ul><p>为了解决这个问题，我暂时放下了手上的项目，花了半个小时实现一个极简易的字符串模板。</p></div><div lang="zh" class="post__readmore font__ui"><a href="/a-simple-javascript-template-language/">READ MORE</a></div></article></div><div lang="zh" class="page-navigator font__ui"><span class="page__button"><a href="/page/8/" class="pre">PREV</a></span><span class="page__button"><a href="/page/10/" class="next">NEXT</a></span></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon current"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item current"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>