<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script>(()=>{let e="/cnfonts.js?rDuukLHQ",t=document,n=navigator.serviceWorker,r=!1;var a;(r=n&&(n.register(e,{scope:"/"}).then(e=>e.update()),a=n.controller)&&a.scriptURL.endsWith(e)&&"activated"===a.state?!0:r)?((a=t.createElement("link")).rel="stylesheet",a.href="/fontchan/rDuukLHQ.css",a.blocking="render",t.head.appendChild(a)):((a=t.createElement("script")).src=e,a.onload=()=>$fontchan.injectCss(),t.head.appendChild(a))})()</script><title>Python“黑魔法”之 Generator Coroutines</title><meta itemprop="title" content="Python“黑魔法”之 Generator Coroutines - hsfzxjy 的博客"><meta itemprop="og:title" content="Python“黑魔法”之 Generator Coroutines - hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="description" content="写在前面


本文默认读者对 Python 生成器 有一定的了解，不了解者请移步至生成器 - 廖雪峰的官方网站。
..."><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div lang="zh" class="post post-page"><h1 lang="zh" class="post__title">Python“黑魔法”之 Generator Coroutines</h1><div class="post__meta font__ui">2016-04-02 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div class="post__content font__body"><h2 id="写在前面">写在前面</h2><blockquote><ul><li>本文默认读者对 Python 生成器 有一定的了解，不了解者请移步至<a target="_blank" rel="noopener" href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000">生成器 - 廖雪峰的官方网站</a>。</li><li>本文基于 Python 3.5.1，文中所有的例子都可在 <a target="_blank" rel="noopener" href="https://github.com/hsfzxjy/python-generator-coroutine-examples">Github</a> 上获得。</li></ul></blockquote><p>学过 Python 的都知道，Python 里有一个很厉害的概念叫做 生成器（Generators）。一个生成器就像是一个微小的线程，可以随处暂停，也可以随时恢复执行，还可以和代码块外部进行数据交换。恰当使用生成器，可以极大地简化代码逻辑。</p><p>也许，你可以熟练地使用生成器完成一些看似不可能的任务，如“无穷斐波那契数列”，并引以为豪，认为所谓的生成器也不过如此——那我可要告诉你：这些都太小儿科了，下面我所要介绍的绝对会让你大开眼界。</p><p><strong>生成器 可以实现 协程，你相信吗？</strong></p><h2 id="什么是协程">什么是协程</h2><p>在异步编程盛行的今天，也许你已经对 协程（coroutines）早有耳闻，但却不一定了解它。我们先来看看 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Coroutine">Wikipedia</a> 的定义：</p><blockquote><p>Coroutines are computer program components that generalize subroutines for nonpreemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations.</p></blockquote><p>也就是说：协程是一种 <strong>允许在特定位置暂停或恢复的子程序</strong>——这一点和 生成器 相似。但和 生成器 不同的是，协程 可以控制子程序暂停之后代码的走向，而 生成器 仅能被动地将控制权交还给调用者。</p><p>协程 是一种很实用的技术。和 多进程 与 多线程 相比，协程 可以只利用一个线程更加轻便地实现 多任务，将任务切换的开销降至最低。和 回调 等其他异步技术相比，协程 维持了正常的代码流程，在保证代码可读性的同时最大化地利用了 阻塞 IO 的空闲时间。它的高效与简洁赢得了开发者们的拥戴。</p><h2 id="python-中的协程">Python 中的协程</h2><p>早先 Python 是没有原生协程支持的，因此在 协程 这个领域出现了百家争鸣的现象。主流的实现由以下两种：</p><ul><li>用 C 实现协程调度。这一派以 gevent 为代表，在底层实现了协程调度，并将大部分的 阻塞 IO 重写为异步。</li><li>用 生成器模拟。这一派以 Tornado 为代表。Tornado 是一个老牌的异步 Web 框架，涵盖了五花八门的异步编程方式，其中包括 协程。本文部分代码借鉴于 Tornado。</li></ul><p>直至 Python 3.4，Python 第一次将异步编程纳入标准库中（参见 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-3156/">PEP 3156</a>），其中包括了用生成器模拟的 协程。而在 Python 3.5 中，Guido 总算在语法层面上实现了 协程（参见 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0492/">PEP 0492</a>）。比起 <code>yield</code> 关键字，新关键字 <code>async</code> 和 <code>await</code> 具有更好的可读性。在不久的将来，新的实现将会慢慢统一混乱已久的协程领域。</p><p>尽管 生成器协程 已成为了过去时，但它曾经的辉煌却不可磨灭。下面，让我们一起来探索其中的魔法。</p><h2 id="一个简单的例子">一个简单的例子</h2><p>假设有两个子程序 <code>main</code> 和 <code>printer</code>。<code>printer</code> 是一个死循环，等待输入、加工并输出结果。<code>main</code> 作为主程序，不时地向 <code>printer</code> 发送数据。</p><p>这应该怎么实现呢？</p><p>传统方式中，这几乎不可能在一个线程中实现，因为死循环会阻塞。而协程却能很好地解决这个问题：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printer</span>():</span><br><span class="line"></span><br><span class="line">    counter = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">        string = (<span class="hljs-keyword">yield</span>)</span><br><span class="line">        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[{0}] {1}&#x27;</span>.<span class="hljs-built_in">format</span>(counter, string))</span><br><span class="line">        counter += <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = printer()</span><br><span class="line">    <span class="hljs-built_in">next</span>(p)</span><br><span class="line">    p.send(<span class="hljs-string">&#x27;Hi&#x27;</span>)</span><br><span class="line">    p.send(<span class="hljs-string">&#x27;My name is hsfzxjy.&#x27;</span>)</span><br><span class="line">    p.send(<span class="hljs-string">&#x27;Bye!&#x27;</span>)</span><br><span class="line"></span><br></pre></div></div><p>输出：</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line">[0] Hi</span><br><span class="line">[1] My name is hsfzxjy.</span><br><span class="line">[2] Bye!</span><br></pre></div></div><p>这其实就是最简单的协程。程序由两个分支组成。主程序通过 <code>send</code> 唤起子程序并传入数据，子程序处理完后，用 <code>yield</code> 将自己挂起，并返回主程序，如此交替进行。</p><h2 id="协程调度">协程调度</h2><p>有时，你的手头上会有多个任务，每个任务耗时很长，而你又不想同步处理，而是希望能像多线程一样交替执行。这时，你就需要一个调度器来协调流程了。</p><p>作为例子，我们假设有这么一个任务：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">name, times</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(times):</span><br><span class="line">        <span class="hljs-built_in">print</span>(name, i)</span><br></pre></div></div><p>如果你直接执行 <code>task</code>，那它会在遍历 <code>times</code> 次之后才会返回。为了实现我们的目的，我们需要将 <code>task</code> 人为地切割成若干块，以便并行处理：</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">name, times</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(times):</span><br><span class="line">        <span class="hljs-keyword">yield</span></span><br><span class="line">        <span class="hljs-built_in">print</span>(name, i)</span><br></pre></div></div><p>这里的 <code>yield</code> 没有逻辑意义，仅是作为暂停的标志点。程序流可以在此暂停，也可以在此恢复。而通过实现一个调度器，我们可以完成多个任务的并行处理：</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Runner</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, tasks</span>):</span><br><span class="line">        self.tasks = deque(tasks)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-keyword">return</span> self.tasks.pop()</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(self.tasks):</span><br><span class="line">            task = self.<span class="hljs-built_in">next</span>()</span><br><span class="line">            <span class="hljs-keyword">try</span>:</span><br><span class="line">                <span class="hljs-built_in">next</span>(task)</span><br><span class="line">            <span class="hljs-keyword">except</span> StopIteration:</span><br><span class="line">                <span class="hljs-keyword">pass</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                self.tasks.appendleft(task)</span><br></pre></div></div><p>这里我们用一个队列（deque）储存任务列表。其中的 <code>run</code> 是一个重要的方法： <strong>它通过轮转队列依次唤起任务，并将已经完成的任务清出队列</strong>，简洁地模拟了任务调度的过程。</p><p>而现在，我们只需调用：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line">Runner([</span><br><span class="line">    task(<span class="hljs-string">&#x27;hsfzxjy&#x27;</span>, <span class="hljs-number">5</span>),</span><br><span class="line">    task(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">4</span>),</span><br><span class="line">    task(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">6</span>)</span><br><span class="line">]).run()</span><br></pre></div></div><p>就可以得到预想中的效果了：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line">Bob 0</span><br><span class="line">Jack 0</span><br><span class="line">hsfzxjy 0</span><br><span class="line">Bob 1</span><br><span class="line">Jack 1</span><br><span class="line">hsfzxjy 1</span><br><span class="line">Bob 2</span><br><span class="line">Jack 2</span><br><span class="line">hsfzxjy 2</span><br><span class="line">Bob 3</span><br><span class="line">Jack 3</span><br><span class="line">hsfzxjy 3</span><br><span class="line">Bob 4</span><br><span class="line">hsfzxjy 4</span><br><span class="line">Bob 5</span><br></pre></div></div><p>简直完美！答案和丑陋的多线程别无二样，代码却简单了不止一个数量级。</p><h2 id="异步-io-模拟">异步 IO 模拟</h2><p>你绝对有过这样的烦恼：程序常常被时滞严重的 IO 操作（数据库查询、大文件读取、越过长城拿数据）阻塞，在等待 IO 返回期间，线程就像死了一样，空耗着时间。为此，你不得不用多线程甚至是多进程来解决问题。</p><p>而事实上，在等待 IO 的时候，你完全可以做一些与数据无关的操作，最大化地利用时间。Node.js 在这点做得不错——它将一切异步化，压榨性能。只可惜它的异步是基于事件回调机制的，稍有不慎，你就有可能陷入 Callback Hell 的深渊。</p><p>而协程并不使用回调，相比之下可读性会好很多。其思路大致如下：</p><ul><li>维护一个消息队列，用于储存 IO 记录。</li><li>协程函数 IO 时，自身挂起，同时向消息队列插入一个记录。</li><li>通过轮询或是 epoll 等事件框架，捕获 IO 返回的事件。</li><li>从消息队列中取出记录，恢复协程函数。</li></ul><p>现在假设有这么一个耗时任务：</p><div class="gk-code hljs" data-gk-id="BLOCK8"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">name</span>):</span><br><span class="line">    <span class="hljs-built_in">print</span>(name, <span class="hljs-number">1</span>)</span><br><span class="line">    sleep(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-built_in">print</span>(name, <span class="hljs-number">2</span>)</span><br><span class="line">    sleep(<span class="hljs-number">2</span>)</span><br><span class="line">    <span class="hljs-built_in">print</span>(name, <span class="hljs-number">3</span>)</span><br></pre></div></div><p>正常情况下，这个任务执行完需要 3 秒，倘若多个同步任务同步执行，执行时间会成倍增长。而如果利用协程，我们就可以在接近 3 秒的时间内完成多个任务。</p><p>首先我们要实现消息队列：</p><div class="gk-code hljs" data-gk-id="BLOCK9"><div class="gk-code-display"><pre><span class="line">events_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br><span class="line">        self.callback = <span class="hljs-keyword">lambda</span>: <span class="hljs-literal">None</span></span><br><span class="line">        events_list.append(self)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_callback</span>(<span class="hljs-params">self, callback</span>):</span><br><span class="line">        self.callback = callback</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_ready</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        result = self._is_ready()</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> result:</span><br><span class="line">            self.callback()</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> result</span><br></pre></div></div><p><code>Event</code> 是消息的基类，其在初始化时会将自己放入消息队列 <code>events_list</code> 中。<code>Event</code> 和 调度器 使用回调进行交互。</p><p>接着我们要 hack 掉 <code>sleep</code> 函数，这是因为原生的 <code>time.sleep()</code> 会阻塞线程。通过自定义 <code>sleep</code> 我们可以模拟异步延时操作：</p><div class="gk-code hljs" data-gk-id="BLOCK10"><div class="gk-code-display"><pre><span class="line"><span class="hljs-comment"># sleep.py</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> event <span class="hljs-keyword">import</span> Event</span><br><span class="line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SleepEvent</span>(<span class="hljs-title class_ inherited__">Event</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, timeout</span>):</span><br><span class="line">        <span class="hljs-built_in">super</span>(SleepEvent, self).__init__(timeout)</span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.start_time = time()</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_is_ready</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-keyword">return</span> time() - self.start_time &gt;= self.timeout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">timeout</span>):</span><br><span class="line">    <span class="hljs-keyword">return</span> SleepEvent(timeout)</span><br></pre></div></div><p>可以看出：<code>sleep</code> 在调用后就会立即返回，同时一个 <code>SleepEvent</code> 对象会被放入消息队列，经过<code>timeout</code> 秒后执行回调。</p><p>再接下来便是协程调度了：</p><div class="gk-code hljs" data-gk-id="BLOCK11"><div class="gk-code-display"><pre><span class="line"><span class="hljs-comment"># runner.py</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> event <span class="hljs-keyword">import</span> events_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">tasks</span>):</span><br><span class="line">    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:</span><br><span class="line">        _<span class="hljs-built_in">next</span>(task)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(events_list):</span><br><span class="line">        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> events_list:</span><br><span class="line">            <span class="hljs-keyword">if</span> event.is_ready():</span><br><span class="line">                events_list.remove(event)</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_next</span>(<span class="hljs-params">task</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">try</span>:</span><br><span class="line">        event = <span class="hljs-built_in">next</span>(task)</span><br><span class="line">        event.set_callback(<span class="hljs-keyword">lambda</span>: _<span class="hljs-built_in">next</span>(task)) <span class="hljs-comment"># 1</span></span><br><span class="line">    <span class="hljs-keyword">except</span> StopIteration:</span><br><span class="line">        <span class="hljs-keyword">pass</span></span><br></pre></div></div><p><code>run</code> 启动了所有的子程序，并开始消息循环。每遇到一处挂起，调度器自动设置回调，并在回调中重新恢复代码流。“1”处巧妙地利用闭包保存状态。</p><p>最后是主代码：</p><div class="gk-code hljs" data-gk-id="BLOCK12"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">from</span> sleep <span class="hljs-keyword">import</span> sleep</span><br><span class="line"><span class="hljs-keyword">import</span> runner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">name</span>):</span><br><span class="line">    <span class="hljs-built_in">print</span>(name, <span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">yield</span> sleep(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-built_in">print</span>(name, <span class="hljs-number">2</span>)</span><br><span class="line">    <span class="hljs-keyword">yield</span> sleep(<span class="hljs-number">2</span>)</span><br><span class="line">    <span class="hljs-built_in">print</span>(name, <span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    runner.run((task(<span class="hljs-string">&#x27;hsfzxjy&#x27;</span>), task(<span class="hljs-string">&#x27;Jack&#x27;</span>)))</span><br></pre></div></div><p>输出：</p><div class="gk-code hljs" data-gk-id="BLOCK13"><div class="gk-code-display"><pre><span class="line">hsfzxjy 1</span><br><span class="line">Jack 1</span><br><span class="line">hsfzxjy 2</span><br><span class="line">Jack 2</span><br><span class="line">hsfzxjy 3</span><br><span class="line">Jack 3</span><br><span class="line"># [Finished in 3.0s]</span><br></pre></div></div><h2 id="协程函数的层级调用">协程函数的层级调用</h2><p>上面的代码有一个不足之处，即协程函数返回的是一个 <code>Event</code> 对象。然而事实上只有直接操纵 IO 的协程函数才有可能接触到这个对象。那么，对于调用了 IO 的函数的调用者，它们应该如何实现呢？</p><p>设想如下任务：</p><div class="gk-code hljs" data-gk-id="BLOCK14"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">long_add</span>(<span class="hljs-params">x, y, duration=<span class="hljs-number">1</span></span>):</span><br><span class="line">    <span class="hljs-keyword">yield</span> sleep(duration)</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">duration</span>):</span><br><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start:&#x27;</span>, time())</span><br><span class="line">    <span class="hljs-built_in">print</span>((<span class="hljs-keyword">yield</span> long_add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, duration)))</span><br><span class="line">    <span class="hljs-built_in">print</span>((<span class="hljs-keyword">yield</span> long_add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, duration)))</span><br></pre></div></div><p><code>long_add</code> 是 IO 的一级调用者，<code>task</code> 调用 <code>long_add</code>，并利用其返回值进行后续操作。</p><p>简而言之，我们遇到的问题是：<strong>一个被唤起的协程函数如何唤起它的调用者？</strong></p><p>正如在上个例子中，协程函数通过 <code>Event</code> 的回调与调度器交互。同理，我们也可以使用一个类似的对象，在这里我们称其为 <code>Future</code>。</p><p><code>Future</code> 保存在被调用者的闭包中，并由被调用者返回。而调用者通过在其上面设置回调函数，实现两个协程函数之间的交互。</p><p><code>Future</code> 的代码如下，看起来有点像 <code>Event</code>：</p><div class="gk-code hljs" data-gk-id="BLOCK15"><div class="gk-code-display"><pre><span class="line"><span class="hljs-comment"># future.py</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Future</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-built_in">super</span>(Future, self).__init__()</span><br><span class="line">        self.callback = <span class="hljs-keyword">lambda</span> *args: <span class="hljs-literal">None</span></span><br><span class="line">        self._done = <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_callback</span>(<span class="hljs-params">self, callback</span>):</span><br><span class="line">        self.callback = callback</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">done</span>(<span class="hljs-params">self, value=<span class="hljs-literal">None</span></span>):</span><br><span class="line">        self._done = <span class="hljs-literal">True</span></span><br><span class="line">        self.callback(value)</span><br></pre></div></div><p><code>Future</code> 的回调函数允许接受一个参数作为返回值，以尽可能地模拟一般函数。</p><p>但这样一来，协程函数就会有些复杂了。它们不仅要负责唤醒被调用者，还要负责与调用者之间的交互。这会产生许多重复代码。为了 D.R.Y，我们用装饰器封装这一逻辑：</p><div class="gk-code hljs" data-gk-id="BLOCK16"><div class="gk-code-display"><pre><span class="line"><span class="hljs-comment"># co.py</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps</span><br><span class="line"><span class="hljs-keyword">from</span> future <span class="hljs-keyword">import</span> Future</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_next</span>(<span class="hljs-params">gen, future, value=<span class="hljs-literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">try</span>:</span><br><span class="line">        <span class="hljs-keyword">try</span>:</span><br><span class="line">            yielded_future = gen.send(value)</span><br><span class="line">        <span class="hljs-keyword">except</span> TypeError:</span><br><span class="line">            yielded_future = <span class="hljs-built_in">next</span>(gen)</span><br><span class="line"></span><br><span class="line">        yielded_future.set_callback(<span class="hljs-keyword">lambda</span> value: _<span class="hljs-built_in">next</span>(gen, future, value))</span><br><span class="line">    <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> e:</span><br><span class="line">        future.done(e.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">coroutine</span>(<span class="hljs-params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span><br><span class="line">        future = Future()</span><br><span class="line"></span><br><span class="line">        gen = func(*args, **kwargs)</span><br><span class="line">        _<span class="hljs-built_in">next</span>(gen, future)</span><br><span class="line">        <span class="hljs-keyword">return</span> future</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> wrapper</span><br></pre></div></div><p>被 <code>coroutine</code> 包装过的生成器成为了一个普通函数，返回一个 <code>Future</code> 对象。<code>_next</code> 为唤醒的核心逻辑，通过一个类似递归的回调设置简洁地实现自我唤醒。当自己执行完时，会将自己闭包内的<code>Future</code>对象标记为<code>done</code>，从而唤醒调用者。</p><p>为了适应新变化，<code>sleep</code> 也要做相应的更改：</p><div class="gk-code hljs" data-gk-id="BLOCK17"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">from</span> event <span class="hljs-keyword">import</span> Event</span><br><span class="line"><span class="hljs-keyword">from</span> future <span class="hljs-keyword">import</span> Future</span><br><span class="line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SleepEvent</span>(<span class="hljs-title class_ inherited__">Event</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, timeout</span>):</span><br><span class="line">        <span class="hljs-built_in">super</span>(SleepEvent, self).__init__()</span><br><span class="line">        self.start_time = time()</span><br><span class="line">        self.timeout = timeout</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_is_ready</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-keyword">return</span> time() - self.start_time &gt;= self.timeout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">timeout</span>):</span><br><span class="line">    future = Future()</span><br><span class="line">    event = SleepEvent(timeout)</span><br><span class="line">    event.set_callback(<span class="hljs-keyword">lambda</span>: future.done())</span><br><span class="line">    <span class="hljs-keyword">return</span> future</span><br></pre></div></div><p><code>sleep</code> 不再返回 <code>Event</code> 对象，而是一致地返回 <code>Future</code>，并作为 <code>Event</code> 和 <code>Future</code> 之间的代理者。</p><p>基于以上更改，调度器可以更加简洁——这是因为协程函数能够自我唤醒：</p><div class="gk-code hljs" data-gk-id="BLOCK18"><div class="gk-code-display"><pre><span class="line"><span class="hljs-comment"># runner.py</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> event <span class="hljs-keyword">import</span> events_list</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>():</span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(events_list):</span><br><span class="line">        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> events_list:</span><br><span class="line">            <span class="hljs-keyword">if</span> event.is_ready():</span><br><span class="line">                events_list.remove(event)</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br></pre></div></div><p>主程序：</p><div class="gk-code hljs" data-gk-id="BLOCK19"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">from</span> co <span class="hljs-keyword">import</span> coroutine</span><br><span class="line"><span class="hljs-keyword">from</span> sleep <span class="hljs-keyword">import</span> sleep</span><br><span class="line"><span class="hljs-keyword">import</span> runner</span><br><span class="line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@coroutine</span></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">long_add</span>(<span class="hljs-params">x, y, duration=<span class="hljs-number">1</span></span>):</span><br><span class="line">    <span class="hljs-keyword">yield</span> sleep(duration)</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@coroutine</span></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">duration</span>):</span><br><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start:&#x27;</span>, time())</span><br><span class="line">    <span class="hljs-built_in">print</span>((<span class="hljs-keyword">yield</span> long_add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, duration)), time())</span><br><span class="line">    <span class="hljs-built_in">print</span>((<span class="hljs-keyword">yield</span> long_add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, duration)), time())</span><br><span class="line"></span><br><span class="line">task(<span class="hljs-number">2</span>)</span><br><span class="line">task(<span class="hljs-number">1</span>)</span><br><span class="line">runner.run()</span><br></pre></div></div><p>由于我们使用了一个糟糕的事件轮询机制，密集的计算会阻塞通往 <code>stdout</code> 的输出，因而看起来所有的结果都是一起打印出来的。为此，我在打印时特地加上了时间戳，以演示协程的效果。输出如下：</p><div class="gk-code hljs" data-gk-id="BLOCK20"><div class="gk-code-display"><pre><span class="line">start: 1459609512.263156</span><br><span class="line">start: 1459609512.263212</span><br><span class="line">3 1459609513.2632613</span><br><span class="line">3 1459609514.2632234</span><br><span class="line">7 1459609514.263319</span><br><span class="line">7 1459609516.2633028</span><br></pre></div></div><p>这事实上是 <code>tornado.gen.coroutine</code> 的简化版本，为了叙述方便我略去了许多细节，如异常处理以及调度优化，目的是让大家能较清晰地了解 生成器协程 背后的机制。因此，<strong>这段代码并不能用于实际生产中</strong>。</p><h2 id="小结-1">小结</h2><ul><li>这，才叫精通生成器。</li><li>学习编程，不仅要知其然，亦要知其所以然。</li><li>Python 是有魔法的，只有想不到，没有做不到。</li></ul><h2 id="references">References</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/tornadoweb/tornado/blob/master/tornado/gen.py#L245">tornado.gen.coroutine</a></li></ul><br><blockquote><p class="cc">作者：hsfzxjy<br>链接：<span class="cc-link"></span><br>许可：<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>.<br>著作权归作者所有。本文<b>不允许</b>被用作商业用途，非商业转载请注明出处。</p></blockquote><script>!function(){var n=document.querySelector("span.cc-link");n&&(n.innerHTML='<a href="'+location.href+'">'+location.href+"</a>")}()</script></div><div class="post__tags"><a href="/tags/Python/">Python</a><a href="/tags/Generator/">Generator</a><a href="/tags/Coroutine/">Coroutine</a></div><div class="post-nav"><a href="/why-I-choose-to-climb-over-the-wall/" class="pre">«为什么我要翻墙</a><a href="/the-simplest-way-to-find-out-if-two-segments-are-intersected/" class="next">数学美 之 判断线段相交的最简方法»</a></div><div id="disqus_thread"><div id="no-comment"><h2>OOPS!</h2><span>A comment box should be right here...</span><span>But it was gone due to network issues :-(</span><span>If you want to leave comments, make sure you have access to&nbsp;<a target="_blank" rel="noopener" href="https://disqus.com">disqus.com</a>.</span></div><script>var disqus_shortname="hsfzxjy",disqus_identifier="python-generator-coroutine/",disqus_title="Python“黑魔法”之 Generator Coroutines",disqus_url="https://i.hsfzxjy.site/python-generator-coroutine/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.defer=!0,e.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(e),e.onerror=function(){document.getElementById("no-comment").classList.add("show")}}()</script><script id="dsq-count-scr" src="//hsfzxjy.disqus.com/count.js" async defer></script></div></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"><div id="toc" lang="zh" class="font__body"><div class="toc-toggler"></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">什么是协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python-%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">Python 中的协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">4.</span> <span class="toc-text">一个简单的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">5.</span> <span class="toc-text">协程调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-io-%E6%A8%A1%E6%8B%9F"><span class="toc-number">6.</span> <span class="toc-text">异步 IO 模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%87%BD%E6%95%B0%E7%9A%84%E5%B1%82%E7%BA%A7%E8%B0%83%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">协程函数的层级调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">8.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#references"><span class="toc-number">9.</span> <span class="toc-text">References</span></a></li></ol></div></div></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>