<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script>(()=>{let e="/cnfonts.js?rDuukLHQ",t=document,n=navigator.serviceWorker,r=!1;var a;(r=n&&(n.register(e,{scope:"/"}).then(e=>e.update()),a=n.controller)&&a.scriptURL.endsWith(e)&&"activated"===a.state?!0:r)?((a=t.createElement("link")).rel="stylesheet",a.href="/fontchan/rDuukLHQ.css",a.blocking="render",t.head.appendChild(a)):((a=t.createElement("script")).src=e,a.onload=()=>$fontchan.injectCss(),t.head.appendChild(a))})()</script><title>从伪并行的 Python 多线程说起</title><meta itemprop="title" content="从伪并行的 Python 多线程说起 - hsfzxjy 的博客"><meta itemprop="og:title" content="从伪并行的 Python 多线程说起 - hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="description" content="写在前面

作者电脑 CPU 为 4 核，因此使用 4 个线程测试是合理的
本文使用的 cpython 版本为 3..."><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div lang="zh" class="post post-page"><h1 lang="zh" class="post__title">从伪并行的 Python 多线程说起</h1><div class="post__meta font__ui">2018-03-10 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div class="post__content font__body noindent"><h2 id="写在前面-6">写在前面</h2><ul><li>作者电脑 CPU 为 4 核，因此使用 4 个线程测试是合理的</li><li>本文使用的 <code>cpython</code> 版本为 <code>3.6.4</code></li><li>本文使用的 <code>pypy</code> 版本为 <code>5.9.0-beta0</code>，兼容 Python 3.5 语法</li><li>本文使用的 <code>jython</code> 版本为 <code>2.7.0</code>，兼容 Python 2.7 语法</li><li>若无特殊说明，作语言解时，<code>python</code> 指 Python 语言；作解释器解时，<code>python</code> 指 <code>cpython</code></li></ul><p>本文使用的测速函数代码如下：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> sys</span><br><span class="line">PY2 = sys.version_info[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 因为 Jython 不兼容 Python 3 语法，此处必须 hack 掉 range 以保证都是迭代器版本</span></span><br><span class="line"><span class="hljs-keyword">if</span> PY2:</span><br><span class="line">    <span class="hljs-built_in">range</span> = xrange  <span class="hljs-comment"># noqa</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time</span><br><span class="line"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">spawn_n_threads</span>(<span class="hljs-params">n, target</span>):</span><br><span class="line">    <span class="hljs-string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="hljs-string">    启动 n 个线程并行执行 target 函数</span></span><br><span class="line"><span class="hljs-string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    threads = []</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):</span><br><span class="line">        thread = Thread(target=target)</span><br><span class="line">        thread.start()</span><br><span class="line">        threads.append(thread)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">target, number=<span class="hljs-number">10</span>, spawner=spawn_n_threads</span>):</span><br><span class="line">    <span class="hljs-string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="hljs-string">    分别启动 1, 2, 3, 4 个控制流，重复 number 次，计算运行耗时</span></span><br><span class="line"><span class="hljs-string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, ):</span><br><span class="line"></span><br><span class="line">        start_time = time()</span><br><span class="line">        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(number):  <span class="hljs-comment"># 执行 number 次以减少偶然误差</span></span><br><span class="line">            spawner(n, target)</span><br><span class="line">        end_time = time()</span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Time elapsed with {} branch(es): {:.6f} sec(s)&#x27;</span>.<span class="hljs-built_in">format</span>(n, end_time - start_time))</span><br></pre></div></div><h2 id="并行？伪并行？">并行？伪并行？</h2><p>学过操作系统的同学都知道，线程是现代操作系统底层一种轻量级的多任务机制。一个进程空间中可以存在多个线程，每个线程代表一条控制流，共享全局进程空间的变量，又有自己私有的内存空间。</p><p>多个线程可以同时执行。此处的“同时”，在较早的单核架构中表现为“伪并行”，即让线程以极短的时间间隔交替执行，从人的感觉上看它们就像在同时执行一样。但由于仅有一个运算单元，当线程皆执行计算密集型任务时，多线程可能会出现 1 + 1 &gt; 2 的反效果。</p><p>而“真正的并行”只能在多核架构上实现。对于计算密集型任务，巧妙地使用多线程或多进程将其分配至多个 CPU 上，通常可以成倍地缩短运算时间。</p><p>作为一门优秀的语言，python 为我们提供了操纵线程的库 <code>threading</code>。使用 <code>threading</code>，我们可以很方便地进行并行编程。但下面的例子可能会让你对“并行”的真实性产生怀疑。</p><p>假设我们有一个计算斐波那契数列的函数：</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>():</span><br><span class="line"></span><br><span class="line">    a = b = <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):</span><br><span class="line">        a, b = b, a + b</span><br></pre></div></div><p class="par">此处我们不记录其结果，只是为了让它产生一定的计算量，使运算时间开销远大于线程创建、切换的时间开销。现在我们执行 <code>test(fib)</code>，尝试在不同数量的线程中执行这个函数。如果线程是“真并行”，时间开销应该不会随线程数大幅上涨。但执行结果却让我们大跌眼镜：</p><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line"># CPython，fib</span><br><span class="line">Time elapsed with 1 branch(es): 1.246095 sec(s)</span><br><span class="line">Time elapsed with 2 branch(es): 2.535884 sec(s)</span><br><span class="line">Time elapsed with 3 branch(es): 3.837506 sec(s)</span><br><span class="line">Time elapsed with 4 branch(es): 5.107638 sec(s)</span><br></pre></div></div><p class="par">从结果中可以发现：时间开销几乎是正比于线程数的！这明显和多核架构的“真并行”相矛盾。这是为什么呢？</p><p>一切的罪魁祸首都是一个叫 GIL 的东西。</p><h2 id="gil">GIL</h2><h3 id="gil-是什么">GIL 是什么</h3><p>GIL 的全名是 the Global Interpreter Lock（全局解释锁），是常规 python 解释器（当然，有些解释器没有）的核心部件。我们看看官方的解释：</p><blockquote><p>The Python interpreter is not fully thread-safe. In order to support multi-threaded Python programs, there’s a global lock, called <strong>the global interpreter lock</strong> or <strong>GIL</strong>, that must be held by the current thread before it can safely access Python objects.</p><p>– via <a target="_blank" rel="noopener" href="https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock">Python 3.6.4 Documentation</a></p></blockquote><p class="par">可见，这是一个用于保护 Python 内部对象的全局锁（在进程空间中唯一），保障了解释器的线程安全。</p><p>这里用一个形象的例子来说明 GIL 的必要性（对资源抢占问题非常熟悉的可以跳过不看）：</p><blockquote><p>我们把整个进程空间看做一个车间，把线程看成是多条不相交的流水线，把线程控制流中的字节码看作是流水线上待处理的物品。Python 解释器是工人，整个车间仅此一名。操作系统是一只上帝之手，会随时把工人从一条流水线调到另一条——这种“随时”是不由分说的，即不管处理完当前物品与否。</p><p>若没有 GIL。假设工人正在流水线 A 处理 A1 物品，根据 A1 的需要将房间温度（一个全局对象）调到了 20 度。这时上帝之手发动了，工人被调到流水线 B 处理 B1 物品，根据 B1 的需要又将房间温度调到了 50 度。这时上帝之手又发动了，工人又调回 A 继续处理 A1。但此时 A1 暴露在了 50 度的环境中，安全问题就此产生了。</p><p>而 GIL 相当于一条锁链，一旦工人开始处理某条流水线上的物品，GIL 便会将工人和该流水线锁在一起。而被锁住的工人只会处理该流水线上的物品。就算突然被调到另一条流水线，他也不会干活，而是干等至重新调回原来的流水线。这样每个物品在被处理的过程中便总是能保证全局环境不会突变。</p></blockquote><p class="par">GIL 保证了线程安全性，但很显然也带来了一个问题：每个时刻只有一条线程在执行，即使在多核架构中也是如此——毕竟，解释器只有一个。如此一来，单进程的 Python 程序便无法利用到多核的优势了。</p><h3 id="验证">验证</h3><p>为了验证确实是 GIL 搞的鬼，我们可以用不同的解释器再执行一次。这里使用 pypy（有 GIL）和 jython（无 GIL）作测试：</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"># PyPy, fib</span><br><span class="line">Time elapsed with 1 branch(es): 0.868052 sec(s)</span><br><span class="line">Time elapsed with 2 branch(es): 1.706454 sec(s)</span><br><span class="line">Time elapsed with 3 branch(es): 2.594260 sec(s)</span><br><span class="line">Time elapsed with 4 branch(es): 3.449946 sec(s)</span><br></pre></div></div><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line"># Jython, fib</span><br><span class="line">Time elapsed with 1 branch(es): 2.984000 sec(s)</span><br><span class="line">Time elapsed with 2 branch(es): 3.058000 sec(s)</span><br><span class="line">Time elapsed with 3 branch(es): 4.404000 sec(s)</span><br><span class="line">Time elapsed with 4 branch(es): 5.357000 sec(s)</span><br></pre></div></div><p class="par">从结果可以看出，用 pypy 执行时，时间开销和线程数也是几乎成正比的；而 jython 的时间开销则是以较为缓慢的速度增长的。jython 由于下面还有一层 JVM，单线程的执行速度很慢，但在线程数达到 4 时，时间开销只有单线程的两倍不到，仅仅稍逊于 cpython 的 4 线程运行结果（5.10 secs）。由此可见，<strong>GIL 确实是造成伪并行现象的主要因素</strong>。</p><h2 id="如何解决？">如何解决？</h2><p>GIL 是 Python 解释器正确运行的保证，Python 语言本身没有提供任何机制访问它。但在特定场合，我们仍有办法降低它对效率的影响。</p><h3 id="使用多进程">使用多进程</h3><p>线程间会竞争资源是因为它们共享同一个进程空间，但进程的内存空间是独立的，自然也就没有必要使用解释锁了。</p><p>许多人非常忌讳使用多进程，理由是进程操作（创建、切换）的时间开销太大了，而且会占用更多的内存。这种担心其实没有必要——除非是对并发量要求很高的应用（如服务器），多进程增加的时空开销其实都在可以接受的范围中。更何况，我们可以使用进程池减少频繁创建进程带来的开销。</p><p>下面新建一个 <code>spawner</code>，以演示多进程带来的性能提升：</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">spawn_n_processes</span>(<span class="hljs-params">n, target</span>):</span><br><span class="line"></span><br><span class="line">    threads = []</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):</span><br><span class="line">        thread = Process(target=target)</span><br><span class="line">        thread.start()</span><br><span class="line">        threads.append(thread)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br></pre></div></div><p class="par">使用 cpython 执行 <code>test(fib, spawner=spawn_n_processes)</code>，结果如下：</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line"># CPython, fib, multi-processing</span><br><span class="line">Time elapsed with 1 branch(es): 1.260981 sec(s)</span><br><span class="line">Time elapsed with 2 branch(es): 1.343570 sec(s)</span><br><span class="line">Time elapsed with 3 branch(es): 2.183770 sec(s)</span><br><span class="line">Time elapsed with 4 branch(es): 2.732911 sec(s)</span><br></pre></div></div><p class="par">可见这里出现了“真正的并行”，程序效率得到了提升。</p><h3 id="使用-c-扩展">使用 C 扩展</h3><p>GIL 并不是完全的黑箱，CPython 在解释器层提供了控制 GIL 的开关——这就是 <code>Py_BEGIN_ALLOW_THREADS</code> 和 <code>Py_END_ALLOW_THREADS</code> 宏。这一对宏允许你在自定义的 C 扩展中释放 GIL，从而可以重新利用多核的优势。</p><p>沿用上面的例子，自定义的 C 扩展函数好比是流水线上一个特殊的物品。这个物品承诺自己不依赖全局环境，同时也不会要求工人去改变全局环境。同时它带有 <code>Py_BEGIN_ALLOW_THREADS</code> 和 <code>Py_END_ALLOW_THREADS</code> 两个机关，前者能砍断 GIL 锁链，这样工人被调度走后不需要干等，而是可以直接干活；后者则将锁链重新锁上，保证操作的一致性。</p><p>这里同样用一个 C 扩展做演示。由于 C 实现的斐波那契数列计算过快，此处采用另一个计算 PI 的函数：</p><div class="gk-code hljs" data-gk-id="BLOCK8"><div class="gk-code-display"><pre><span class="line"><span class="hljs-comment">// cfib.c</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;python3.6m/Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-type">static</span> PyObject* <span class="hljs-title function_">fib</span><span class="hljs-params">(PyObject* self, PyObject* args)</span></span><br><span class="line">{</span><br><span class="line">    Py_BEGIN_ALLOW_THREADS</span><br><span class="line">    <span class="hljs-type">double</span> n = <span class="hljs-number">90000000</span>, i;</span><br><span class="line">    <span class="hljs-type">double</span> s = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-type">double</span> pi = <span class="hljs-number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= n * <span class="hljs-number">2</span>; i += <span class="hljs-number">2</span>) {</span><br><span class="line">        pi = pi + s * (<span class="hljs-number">4</span> / (i * (i + <span class="hljs-number">1</span>) * (i + <span class="hljs-number">2</span>)));</span><br><span class="line">        s = -s;</span><br><span class="line">    }</span><br><span class="line">    Py_END_ALLOW_THREADS</span><br><span class="line">    <span class="hljs-keyword">return</span> Py_None;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 模块初始化代码略去</span></span><br></pre></div></div><p class="par">使用 cpython 执行 <code>test(cfib.fib)</code>，结果如下：</p><div class="gk-code hljs" data-gk-id="BLOCK9"><div class="gk-code-display"><pre><span class="line"># CPython, cfib, non-GIL</span><br><span class="line">Time elapsed with 1 branch(es): 1.334247 sec(s)</span><br><span class="line">Time elapsed with 2 branch(es): 1.439759 sec(s)</span><br><span class="line">Time elapsed with 3 branch(es): 1.603779 sec(s)</span><br><span class="line">Time elapsed with 4 branch(es): 1.689330 sec(s)</span><br></pre></div></div><p class="par">若注释掉以上两个宏，则结果如下：</p><div class="gk-code hljs" data-gk-id="BLOCK10"><div class="gk-code-display"><pre><span class="line"># CPython, cfib, with-GIL</span><br><span class="line">Time elapsed with 1 branch(es): 1.331415 sec(s)</span><br><span class="line">Time elapsed with 2 branch(es): 2.671651 sec(s)</span><br><span class="line">Time elapsed with 3 branch(es): 4.022696 sec(s)</span><br><span class="line">Time elapsed with 4 branch(es): 5.337917 sec(s)</span><br></pre></div></div><p class="par">可见其中的性能差异。因此当你想做一些计算密集型任务时，不妨尝试用 C 实现，以此规避 GIL。</p><p>值得注意的是，一些著名的科学计算库（如 <code>numpy</code>）为了提升性能，其底层也是用 C 实现的，并且会在做一些线程安全操作（如 <code>numpy</code> 的数组操作）时释放 GIL。因此对于这些库，我们可以放心地使用多线程。以下是一个例子：</p><div class="gk-code hljs" data-gk-id="BLOCK11"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">np_example</span>():</span><br><span class="line">    ones = numpy.ones(<span class="hljs-number">10000000</span>)</span><br><span class="line">    numpy.exp(ones)</span><br></pre></div></div><p class="par">用 CPython 执行 <code>test(np_example)</code> 结果如下：</p><div class="gk-code hljs" data-gk-id="BLOCK12"><div class="gk-code-display"><pre><span class="line"># CPython, np_example</span><br><span class="line">Time elapsed with 1 branch(es): 3.708392 sec(s)</span><br><span class="line">Time elapsed with 2 branch(es): 2.462703 sec(s)</span><br><span class="line">Time elapsed with 3 branch(es): 3.578331 sec(s)</span><br><span class="line">Time elapsed with 4 branch(es): 4.276800 sec(s)</span><br></pre></div></div><h3 id="让线程做该做的事">让线程做该做的事</h3><p>读到这，有同学可能会奇怪了：我在使用 python 多线程写爬虫时可从来没有这种问题啊——用 4 个线程下载 4 个页面的时间与单线程下载一个页面的时间相差无几。</p><p>这里就要谈到 GIL 的第二种释放时机了。除了调用 <code>Py_BEGIN_ALLOW_THREADS</code>，解释器还会在<strong>发生阻塞 IO</strong>（如网络、文件）时释放 GIL。发生阻塞 IO 时，调用方线程会被挂起，无法进行任何操作，直至内核返回；IO 函数一般是原子性的，这确保了调用的线程安全性。因此在大多数阻塞 IO 发生时，解释器没有理由加锁。</p><p>以爬虫为例：当 Thread1 发起对 Page1 的请求后，Thread1 会被挂起，<strong>此时 GIL 释放</strong>。当控制流切换至 Thread2 时，由于没有 GIL，不必干等，而是可以直接请求 Page2……如此一来，四个请求可以认为是几乎同时发起的。时间开销便与单线程请求一次一样。</p><p>有人反对使用阻塞 IO，因为若想更好利用阻塞时的时间，必须使用多线程或进程，这样会有很大的上下文切换开销，而非阻塞 IO + 协程显然是更经济的方式。但当若干任务之间没有偏序关系时，一个任务阻塞是可以接受的（毕竟不会影响到其他任务的执行），同时也会简化程序的设计。而在一些通信模型（如 Publisher-Subscriber）中，“阻塞”是必要的语义。</p><p>多个阻塞 IO 需要多条非抢占式的控制流来承载，这些工作交给线程再合适不过了。</p><h2 id="小结-2">小结</h2><ol><li>由于 GIL 的存在，大多数情况下 Python 多线程无法利用多核优势。</li><li>C 扩展中可以接触到 GIL 的开关，从而规避 GIL，重新获得多核优势。</li><li>IO 阻塞时，GIL 会被释放。</li></ol><h2 id="相关链接">相关链接</h2><ol><li><a target="_blank" rel="noopener" href="https://wiki.python.org/moin/GlobalInterpreterLock">GlobalInterpreterLock - Python Wiki</a></li><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Blocking_%28computing%29">Blocking(computing) - Wikipedia</a></li><li><a target="_blank" rel="noopener" href="https://docs.python.org/3/extending/extending.html">Extending Python with C or C++</a></li><li><a target="_blank" rel="noopener" href="https://pypy.org/">PyPy</a></li><li><a target="_blank" rel="noopener" href="http://www.jython.org/">Jython</a></li></ol><br><blockquote><p class="cc">作者：hsfzxjy<br>链接：<span class="cc-link"></span><br>许可：<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>.<br>著作权归作者所有。本文<b>不允许</b>被用作商业用途，非商业转载请注明出处。</p></blockquote><script>!function(){var n=document.querySelector("span.cc-link");n&&(n.innerHTML='<a href="'+location.href+'">'+location.href+"</a>")}()</script></div><div class="post__tags"><a href="/tags/Python/">Python</a><a href="/tags/Multi-Threading/">Multi-Threading</a><a href="/tags/GIL/">GIL</a></div><div class="post-nav"><a href="/download-in-ubuntu-with-aria/" class="pre">«使用 Aria2 在 Ubuntu 中下载百度云资源</a><a href="/caveats-for-signal-handler-in-python/" class="next">一个 Reentrant Error 引发的对 Python 信号机制的探索和思考»</a></div><div id="disqus_thread"><div id="no-comment"><h2>OOPS!</h2><span>A comment box should be right here...</span><span>But it was gone due to network issues :-(</span><span>If you want to leave comments, make sure you have access to&nbsp;<a target="_blank" rel="noopener" href="https://disqus.com">disqus.com</a>.</span></div><script>var disqus_shortname="hsfzxjy",disqus_identifier="python-gil-and-threads/",disqus_title="从伪并行的 Python 多线程说起",disqus_url="https://i.hsfzxjy.site/python-gil-and-threads/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.defer=!0,e.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(e),e.onerror=function(){document.getElementById("no-comment").classList.add("show")}}()</script><script id="dsq-count-scr" src="//hsfzxjy.disqus.com/count.js" async defer></script></div></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"><div id="toc" lang="zh" class="font__body"><div class="toc-toggler"></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2-6"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%EF%BC%9F%E4%BC%AA%E5%B9%B6%E8%A1%8C%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">并行？伪并行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gil"><span class="toc-number">3.</span> <span class="toc-text">GIL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gil-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">GIL 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">3.2.</span> <span class="toc-text">验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">如何解决？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">使用多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-c-%E6%89%A9%E5%B1%95"><span class="toc-number">4.2.</span> <span class="toc-text">使用 C 扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E7%BA%BF%E7%A8%8B%E5%81%9A%E8%AF%A5%E5%81%9A%E7%9A%84%E4%BA%8B"><span class="toc-number">4.3.</span> <span class="toc-text">让线程做该做的事</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5"><span class="toc-number">6.</span> <span class="toc-text">相关链接</span></a></li></ol></div></div></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>