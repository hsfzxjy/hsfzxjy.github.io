<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script>(()=>{let e="/cnfonts.js?rDuukLHQ",t=document,n=navigator.serviceWorker,r=!1;var a;(r=n&&(n.register(e,{scope:"/"}).then(e=>e.update()),a=n.controller)&&a.scriptURL.endsWith(e)&&"activated"===a.state?!0:r)?((a=t.createElement("link")).rel="stylesheet",a.href="/fontchan/rDuukLHQ.css",a.blocking="render",t.head.appendChild(a)):((a=t.createElement("script")).src=e,a.onload=()=>$fontchan.injectCss(),t.head.appendChild(a))})()</script><title>Rc, RefCell and Interior Mutability</title><meta itemprop="title" content="Rc, RefCell and Interior Mutability - hsfzxjy 的博客"><meta itemprop="og:title" content="Rc, RefCell and Interior Mutability - hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="description" content="Say we need a type Cursor&amp;lt;T&amp;gt; , which holds a mutabl..."><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div lang="en" class="post post-page"><h1 lang="en" class="post__title">Rc, RefCell and Interior Mutability</h1><div class="post__meta font__ui">2019-06-23 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div class="post__content font__body noindent"><p>Say we need a type <code>Cursor&lt;T&gt;</code> , which holds a mutable reference to <code>T</code>. A method <code>.dup()</code> duplicates the internal reference, wraps it in a new instance of <code>Cursor&lt;T&gt;</code> and returns. Such pattern exists commonly in database driver library. Users could hold multiple cursors simultaneously, with each owning a (mutable) reference to the same connection object.</p><p>One might implements with a primitive mutable reference:</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cursor</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; {</span><br><span class="line">    obj: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; Cursor&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; {</span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T) <span class="hljs-punctuation">-&gt;</span> Cursor&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; {</span><br><span class="line">        Cursor { obj: t }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dup</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Cursor&lt;T&gt; {</span><br><span class="line">        Cursor { obj: <span class="hljs-keyword">self</span>.obj }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cursor_a</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> i);</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">_cursor_b</span> = cursor_a.<span class="hljs-title function_ invoke__">dup</span>();</span><br><span class="line">}</span><br></pre></div></div><p>Perfect and neat, and luckily Rust compiler did not complain. Fresh Rustanceans would have to work hard for shutting up the compiler, especially when fighting with references.</p><p>The invocation of <code>::new()</code> and <code>.dup()</code> are on separate lines. Now what about to chain up the constructor and <code>.dup()</code>? This time the compiler fails:</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> i).<span class="hljs-title function_ invoke__">dup</span>();</span><br><span class="line">    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, a.obj);</span><br><span class="line">}</span><br></pre></div></div><div class="gk-code hljs" data-gk-id="BLOCK3"><div class="gk-code-display"><pre><span class="line">   |</span><br><span class="line">21 |     let a = Cursor::new(&amp;mut i).dup();</span><br><span class="line">   |             ^^^^^^^^^^^^^^^^^^^      - temporary value is freed at the end of this statement</span><br><span class="line">   |             |</span><br><span class="line">   |             creates a temporary which is freed while still in use</span><br><span class="line">22 |     println!(&quot;{:?}&quot;, a.obj);</span><br><span class="line">   |                      ----- borrow later used here</span><br><span class="line">   |</span><br><span class="line">   = note: consider using a `let` binding to create a longer lived value</span><br></pre></div></div><p class="par">Wierd. Chaining invocations or not should make no difference, at least in most languages – but not in Rust.</p><p>To figure out the problem, let’s expand the signature of <code>.dup()</code> into a more verbose one:</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dup</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Cursor&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; {</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">}</span><br></pre></div></div><p class="par">Rust compiler allows us to elide the lifetime specifier <code>&#39;a</code> . The signature implies <code>self</code> should live at least as long as the returned value. However, by chaining the invocations, the code is in fact equivalent to:</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = {</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">__a</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> i);</span><br><span class="line">    __a.<span class="hljs-title function_ invoke__">dup</span>()</span><br><span class="line">};</span><br></pre></div></div><p class="par">The temporary variable <code>__a</code> lives only within the block, and will be dropped at the end of it. But the return value of <code>__a.dup()</code> is passed out of the block, and therefore has a longer lifetime than <code>__a</code> , which violates the constraints. To fix it, we might instead implement a self-consuming version of <code>.dup()</code> , say <code>.into_dup()</code> :</p><div class="gk-code hljs" data-gk-id="BLOCK6"><div class="gk-code-display"><pre><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">into_dup</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Cursor&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; {</span><br><span class="line">        Cursor { obj: <span class="hljs-keyword">self</span>.obj }</span><br><span class="line">    }</span><br></pre></div></div><p class="par"><code>.into_dup()</code> moves all content of <code>self</code> into the new object, and makes no implication on the lifetime. Now we can write code like <code>Cursor::new(&amp;mut i).into_dup()</code> .</p><h2 id="rc">Rc</h2><p>The solution above is not satisfactory enough. Apparently we won’t make a self-consuming version for each method, just to please the compiler. A smart pointer with reference counting might be more suitable for the job. Let’s try to rewrite the code with <code>std::rc::Rc</code> :</p><div class="gk-code hljs" data-gk-id="BLOCK7"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cursor</span>&lt;T&gt; {</span><br><span class="line">    obj: Rc&lt;T&gt;,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">impl</span>&lt;T&gt; Cursor&lt;T&gt; {</span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(t: &amp;Rc&lt;T&gt;) <span class="hljs-punctuation">-&gt;</span> Cursor&lt;T&gt; {</span><br><span class="line">        Cursor { obj: t.<span class="hljs-title function_ invoke__">clone</span>() }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dup</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Cursor&lt;T&gt; {</span><br><span class="line">        Cursor {</span><br><span class="line">            obj: <span class="hljs-keyword">self</span>.obj.<span class="hljs-title function_ invoke__">clone</span>(),</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></div></div><p class="par">An <code>Rc</code> instance wraps a pointer (or reference) internally, and cloning the instance implicitly duplicates the pointer. But from the perspective of compiler, there’s no borrowing involved, and no more need for explicit lifetime declaration in <code>struct</code> and <code>impl</code> . We can now chain the invocations as expected:</p><div class="gk-code hljs" data-gk-id="BLOCK8"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(&amp;i).<span class="hljs-title function_ invoke__">dup</span>();</span><br><span class="line">    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i: {:?} a.obj: {:?}&quot;</span>, a.obj, i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Output</span></span><br><span class="line"><span class="hljs-comment">// i: 1 a.obj: 1</span></span><br></pre></div></div><p class="par">Great! Looks like that <code>Rc</code> could help to relax the constraints of references, and allow us to share references more flexibly.</p><p>Now let’s move forward to another task – we attempt to mutate the target value through the reference:</p><div class="gk-code hljs" data-gk-id="BLOCK9"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(&amp;i).<span class="hljs-title function_ invoke__">dup</span>();</span><br><span class="line">    <span class="hljs-comment">// hl:begin</span></span><br><span class="line">    *Rc::<span class="hljs-title function_ invoke__">get_mut</span>(&amp;<span class="hljs-keyword">mut</span> i).<span class="hljs-title function_ invoke__">unwrap</span>() = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-comment">// hl:end</span></span><br><span class="line">    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i: {:?} a.obj: {:?}&quot;</span>, a.obj, i);</span><br><span class="line">}</span><br></pre></div></div><p class="par">The <code class="_hl-label">highlighted</code> line is much more verbose than expected. <code>Rc</code> does not implements <code>DerefMut</code> trait, so we could not obtain a mutable reference by mutable de-referencing. Instead, it provides <code>Rc::get_mut()</code> for the obj, which returns a value of type <code>Optional&lt;&amp;mut T&gt;</code> . The <code>Optional</code> wrapper implies a possible failure during de-referencing. This could be confusing at the first sight – the object of type <code>T</code> is owned by the <code>Rc&lt;T&gt;</code> object, so how could the de-referencing be invalid?</p><p>We might defer the question in later paragraphs and go ahead. The code compiles smoothly, but this time we get a runtime panic:</p><div class="gk-code hljs" data-gk-id="BLOCK10"><div class="gk-code-display"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;called `Option::unwrap()` on a `None` value&#x27;, src/libcore/option.rs:347:21</span><br></pre></div></div><p class="par">Oops… So <code>Rc::get_mut</code> does return a <code>None</code> ! To explain this, we might go back to the docs for help:</p><p>The fact is that, <code>Rc::get_mut</code> help survive the compilation, but will perform a runtime check to ensure there’s no other <code>Rc</code> or <code>Weak</code> instances referencing the target, and it fails (returns <code>None</code> ) if so. This is claimed in the docs</p><blockquote><ul><li><code>Rc::get_mut</code> Returns a mutable reference to the inner value, if there are no other <code>Rc</code> or <code>Weak</code> pointers to the same value.</li><li><code>Rc::get_mut</code> Returns <code>None</code> otherwise, because it is not safe to mutate a shared value.</li></ul></blockquote><p class="par">In the code above, we actually have two <code>Rc</code> instances, <code>i</code> and <code>a.obj</code> , sharing a same value internally. <code>Rc::get_mut</code> therefore denies the dereferencing. From this perspective, <code>Rc</code> resembles another borrow checker at runtime.</p><p>Here’s a brief comparison between <code>Rc</code> s and primitive references:</p><p><code>Rc</code> :</p><ul><li>At any moment there may exist several <code>Rc&lt;T&gt;</code> instances holding reference to the same internal value. One can use <code>*</code> to directly deference one of them to immutably access the internal value.</li><li>An <code>Rc&lt;T&gt;</code> instance can be mutably dereferenced if and only if it is the only instance holding reference to the internal value.</li></ul><p>Primitive references:</p><ul><li>For a value <code>v</code> of type <code>T</code> , at any moment there may exist several immutable reference to <code>v</code> . Each of them can be derefenced to obtain the target value.</li><li>An <code>&amp;mut T</code> to <code>v</code> is legal, if and only if there is no other reference to <code>v</code> .</li></ul><p>Sure, Rust is safe… But is our design incorrect? Not really. We may just misuse the underlying structure for the pattern.</p><p>The problem is, existence of an <code>Rc&lt;T&gt;</code> instance implies an “immutable reference” to the internal value, and thus disallows mutable access to it in the future. The implication drives out data races, but could be too aggressive for our scenario. In some cases, accessing and mutating an object will never collide. It would be better weaken the notion of “holding reference” from the long living time of <code>Rc&lt;T&gt;</code> to a much shorter one, for example, we could defer the checking to the time inner value being accessed, instead of the time <code>Rc&lt;T&gt;</code> being duplicated.</p><h2 id="refcell-and-interior-mutability-pattern">RefCell and Interior Mutability Pattern</h2><p>But we would still need <code>Rc</code> , since it’s almost the only choice for reference sharing. The trick is to find some ways <strong>to mutate the inner value with only an immutable reference provided</strong>.</p><p>In Rust, the concept mutability is “infectious”. Even if we just attempt to partially mutate an object, a mutable reference to the whole object is still needed. It’s inconvenient for objects consisting of several independent parts <sup id="fnref:1"><a href="#fn:1">1</a></sup>. Such design does not play well with the borrow checker. From a more generic view, sometimes mutability of an object should be hidden, in order that it can be mutated with only immutable reference provided. This is what we called <strong>Interior Mutability Pattern</strong> in Rust.</p><p>The corresponding underlying structure is <code>RefCell</code> . A <code>RefCell</code> instance has <code>.borrow()</code> and <code>.borrow_mut()</code> method for immutable or mutable borrowing. Both of the two methods have <code>&amp;self</code> in signature, and thus no requirement for compile-time mutability. For most of the time, they can be used as expected without any disturbing, but at the time the borrowing violate the rules, they would still panic.</p><h2 id="rc--refcell">Rc + RefCell</h2><p>We could combine <code>Rc</code> and <code>RefCell</code> into <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> and rewrite our program into expected behavior:</p><div class="gk-code hljs" data-gk-id="BLOCK11"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="hljs-keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cursor</span>&lt;T&gt; {</span><br><span class="line">    obj: Rc&lt;RefCell&lt;T&gt;&gt;,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">impl</span>&lt;T&gt; Cursor&lt;T&gt; {</span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(t: &amp;Rc&lt;RefCell&lt;T&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> Cursor&lt;T&gt; {</span><br><span class="line">        Cursor { obj: t.<span class="hljs-title function_ invoke__">clone</span>() }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dup</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Cursor&lt;T&gt; {</span><br><span class="line">        Cursor {</span><br><span class="line">            obj: <span class="hljs-keyword">self</span>.obj.<span class="hljs-title function_ invoke__">clone</span>(),</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>));</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(&amp;i).<span class="hljs-title function_ invoke__">dup</span>();</span><br><span class="line">    *i.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i: {:?} a.obj: {:?}&quot;</span>, a.obj, i);</span><br><span class="line">}</span><br></pre></div></div><p>The declaration is getting a little more verbose, but it does work! We can now share the reference between objects, and mutate the interval value via an immutable borrowing. With automatic dereference in Rust, the <code>Rc</code> layer becomes transparent. We can write statement like <code>i.borrow_mut()</code> to reduces most of the verbosity.</p><p>Now let’s see what would happen if multiple borrowings exist:</p><div class="gk-code hljs" data-gk-id="BLOCK12"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>));</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(&amp;i).<span class="hljs-title function_ invoke__">dup</span>();</span><br><span class="line">    <span class="hljs-comment">// hl:begin</span></span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">_ref</span> = i.<span class="hljs-title function_ invoke__">borrow</span>();  <span class="hljs-comment">// Another borrow here</span></span><br><span class="line">    <span class="hljs-comment">// hl:end</span></span><br><span class="line">    *i.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i: {:?} a.obj: {:?}&quot;</span>, a.obj, i);</span><br><span class="line">}</span><br></pre></div></div><p class="par">The program still compiles, but panicks at runtime:</p><div class="gk-code hljs" data-gk-id="BLOCK13"><div class="gk-code-display"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;already borrowed: BorrowMutError&#x27;, src/libcore/result.rs:999:5</span><br></pre></div></div><p class="par">At the moment of <code>i.borrow_mut()</code> , another immutable borrowing <code>_ref</code> already exists and violates the rules. In a sense <code>RefCell</code> relaxes compile-time constraints and defers them to runtime. It makes a trade-off between compile-time safety and flexibility.</p><h2 id="references-3">References</h2><ul><li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.get_mut"><code>Rc::get_mut</code></a></li><li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html"><code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></li></ul><div class="footnotes"><ol><li class="footnote" id="fn:1">One might argue this as an anti-pattern, as one class (type) should only do a job. But IMO languages should constraint less on high-level design patterns. It’s okay to explore the feasibility in Rust.</li></ol></div><br><blockquote><p class="cc"><b>Author:</b> hsfzxjy.<br><b>Link:</b> <span class="cc-link"></span>.<br><b>License:</b> <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>.<br>All rights reserved by the author.<br>Commercial use of this post in any form is <b>NOT</b> permitted.<br>Non-commercial use of this post should be attributed with this block of text.</p></blockquote><script>!function(){var n=document.querySelector("span.cc-link");n&&(n.innerHTML='<a href="'+location.href+'">'+location.href+"</a>")}()</script></div><div class="post__tags"><a href="/tags/Rust/">Rust</a><a href="/tags/Lifetime/">Lifetime</a></div><div class="post-nav"><a href="/option-as_ref/" class="pre">«Option::as_ref</a><a href="/correlation-matrix/" class="next">Visualizing Correlation»</a></div><div id="disqus_thread"><div id="no-comment"><h2>OOPS!</h2><span>A comment box should be right here...</span><span>But it was gone due to network issues :-(</span><span>If you want to leave comments, make sure you have access to&nbsp;<a target="_blank" rel="noopener" href="https://disqus.com">disqus.com</a>.</span></div><script>var disqus_shortname="hsfzxjy",disqus_identifier="rc-refcell-pattern/",disqus_title="Rc, RefCell and Interior Mutability",disqus_url="https://i.hsfzxjy.site/rc-refcell-pattern/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.defer=!0,e.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(e),e.onerror=function(){document.getElementById("no-comment").classList.add("show")}}()</script><script id="dsq-count-scr" src="//hsfzxjy.disqus.com/count.js" async defer></script></div></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"><div id="toc" lang="en" class="font__body"><div class="toc-toggler"></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#rc"><span class="toc-number">1.</span> <span class="toc-text">Rc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#refcell-and-interior-mutability-pattern"><span class="toc-number">2.</span> <span class="toc-text">RefCell and Interior Mutability Pattern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rc--refcell"><span class="toc-number">3.</span> <span class="toc-text">Rc + RefCell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#references-3"><span class="toc-number">4.</span> <span class="toc-text">References</span></a></li></ol></div></div></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>