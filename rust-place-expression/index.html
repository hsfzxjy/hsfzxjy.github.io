<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script>(()=>{let r="/cnfonts.js",n=document,e=n.createElement("link");e.rel="stylesheet",e.href="/fontchan/jBKCaHQX.css",e.blocking="render",e.onerror=()=>{var e=n.createElement("script");e.src=r,e.onload=()=>$fontchan.injectCss(),n.head.appendChild(e)},n.head.appendChild(e),"serviceWorker"in navigator&&navigator.serviceWorker.register(r,{scope:"/"}).then(e=>e.update())})()</script><title>Rust 中的隐匿概念 —— Place（位置）</title><meta itemprop="title" content="Rust 中的隐匿概念 —— Place（位置） - hsfzxjy 的博客"><meta itemprop="og:title" content="Rust 中的隐匿概念 —— Place（位置） - hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="description" content="在本文开始前，我们先看一个奇怪的问题。以下两个函数，为什么 reborrow_good 能通过编译，而 deref..."><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div lang="zh" class="post post-page"><h1 lang="zh" class="post__title">Rust 中的隐匿概念 —— Place（位置）</h1><div class="post__meta font__ui">2024-11-10 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div class="post__content font__body"><p>在本文开始前，我们先看一个奇怪的问题。以下两个函数，为什么 <code>reborrow_good</code> 能通过编译，而 <code>deref_bad</code> 不能？</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">reborrow_good</span>(p: *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>) {</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">_p</span> = &amp;raw <span class="hljs-keyword">const</span> *p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref_bad</span>(p: *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>) {</span><br><span class="line">    <span class="hljs-keyword">let</span> <span class="hljs-variable">_v</span> = *p;</span><br><span class="line">}</span><br></pre></div></div><p class="par"></p><blockquote><p><small><code>&amp;raw const B</code> 是 Rust 1.82 中引入的新语法，作用是创建一个指向 <code>B</code> 的 raw 指针。<br>没有此语法前，为了获取指向 <code>x.y</code> 的 raw 指针，只能使用特殊宏 <code>addr_of!(x.y)</code>。而有了 <code>&amp;raw</code> 语法后便可写为 <code>&amp;raw const x.y</code>。</small></p></blockquote><p>使用 Edition 2024 的 Rust 编译器，<code>deref_bad</code> 会报如下错（<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=nightly&mode=debug&edition=2024&gist=28bad326389ea62631540a38741bb65c">Playground</a>），提示我们解引用 raw 指针需要在 unsafe block 中进行：</p><div class="gk-code hljs" data-gk-id="BLOCK2"><div class="gk-code-display"><pre><span class="line">error[E0133]: dereference of raw pointer is unsafe and requires unsafe block</span><br><span class="line"> --&gt; src/lib.rs:6:14</span><br><span class="line">  |</span><br><span class="line">6 |     let _v = *p;</span><br><span class="line">  |              ^^ dereference of raw pointer</span><br><span class="line">  |</span><br><span class="line">  = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior</span><br></pre></div></div><p>在 Rust 中，raw 指针相较引用，不受所有权规则的约束。它们可能传自其他语言，可能是空指针，可能没有对齐，可能有 alias 问题。因此，解引用 raw 指针需要在 unsafe 块中进行，而且要万分小心。</p><p>但这就奇怪了：明明 <code>reborrow_good</code> 的 <code>&amp;raw const *p</code> 中也有 <code>*p</code> 这一表达式，为什么它就能通过编译，而不需要 unsafe 呢？</p><h2 id="拆解表达式">拆解表达式</h2><p>为了解答以上问题，我们不妨从编译器视角出发，对两个例子作拆解分析，设想编译器是怎么生成对应的伪指令序列的。</p><h3 id="分析-reborrow_good">分析 reborrow_good</h3><p>首先来看 <code>_p = &amp;raw const *p</code> 这个表达式。</p><p><code>p</code> 作为一个变量，它“不是一个值”。Rust 中的变量是对外部位置的一种抽象。一个变量可能对应 CPU 寄存器，也可能对应内存中的某个位置。为了知道变量里面的内容，我们先要 <strong>“读取”它</strong>，得到一个整数值。这一步可以记为 <code>$val0 := load p</code>。注意，我用带 <code>$</code> 前缀的 <code>$val0</code> 表示值，从而与 <code>p</code> 等位置作区分。</p><p>有了 <code>$val0</code> 这个值，下一步是对其应用 <code>*</code> 解引用运算。解引用相当于拿着一个代表地址的整数，去<strong>寻找对应的内存位置</strong>。因此这一步的结果是一个位置，而不是一个值，可以记为 <code>place0 := deref $val0</code>。</p><p>下一步是 <code>&amp;raw const</code> 操作，即取地址操作。取地址相当于以<strong>一个位置</strong>作为输入，输出一个代表其地址的整数值。这步可记为 <code>$val1 := addrof place0</code>。</p><p>最后，我们将 <code>$val1</code> 赋给 <code>_p</code>。这步可记为 <code>store _p $val1</code>。整个表达式的伪指令序列如下：</p><div class="gk-code hljs" data-gk-id="reborrow_good"><div class="gk-code-display"><pre><span class="line">$val0  :=   load  p</span><br><span class="line">place0 :=  deref  $val0</span><br><span class="line">$val1  := addrof  place0</span><br><span class="line">           store  _p     $val1</span><br></pre></div></div><h3 id="分析-deref_bad">分析 deref_bad</h3><p>我们再来看 <code>deref_bad</code> 中的 <code>_v = *p</code> 表达式。这其中也有 <code>*p</code> 一项，因此前两条伪指令与上面一样，分别是 <code>$val0 := load p</code> 与 <code>place0 := deref $val0</code>。</p><p>接下来，我们需要对 <code>_v</code> 变量赋值，而这个值是从 <code>place0</code> 中读取的，因此在 <code>store</code> 指令前，还需要一条 <code>load place0</code> 指令。最终，整个表达式的伪指令序列如下：</p><div class="gk-code hljs" data-gk-id="deref_bad"><div class="gk-code-display"><pre><span class="line">$val0  :=   load  p</span><br><span class="line">place0 :=  deref  $val0</span><br><span class="line">$val1  :=   load  place0</span><br><span class="line">           store  _v     $val1</span><br></pre></div></div><h3 id="对比分析">对比分析</h3><div class="gk-unified-code row" data-gk-style="row"><div class="gk-code hljs" data-gk-id="reborrow_good_recap" data-gk-title="reborrow_good"><div class="gk-code-display"><pre><span class="gk-section gk-include" data-gk-sid="reborrow_good_recap.SEC1" data-gk-type="include" data-gk-referee="reborrow_good"><span class="line">$val0  :=   load  p</span><br><span class="line">place0 :=  deref  $val0</span><br><span class="line">$val1  := addrof  place0</span><br><span class="line">           store  _p     $val1</span><br></span></pre></div></div><div class="gk-code hljs" data-gk-id="BLOCK3" data-gk-title="deref_bad"><div class="gk-code-display"><pre><span class="gk-section gk-include" data-gk-sid="BLOCK3.SEC1" data-gk-type="include" data-gk-referee="deref_bad"><span class="line">$val0  :=   load  p</span><br><span class="line">place0 :=  deref  $val0</span><br><span class="line">$val1  :=   load  place0</span><br><span class="line">           store  _v     $val1</span><br></span></pre></div></div></div><p>不难发现，两段序列的 不同之处在第三行：对于 <code>place0</code>，<code>reborrow_good</code> 使用了 <code>addrof</code>，而 <code>deref_bad</code> 使用了 <code>load</code>。这意味着<strong>后者会产生对 <code>place0</code> 位置的访问，而前者没有。</strong>由于 <code>place0</code> 源自 <code>*p</code>，Rust 推断出 <code>load place0</code> 是不安全的，因此拒绝编译 <code>deref_bad</code> 的代码。</p><h2 id="place（位置）">Place（位置）</h2><p>经过以上分析，我们不难发现，Rust 中存在一种抽象概念，即<strong>Place（位置）</strong>。一个 Place 即代表了一块外部世界的存储空间。</p><p>Place 这一概念在语言标准中没有提及，各大教程中也没有介绍，但它确确实实存在于 Rust 的世界观中。事实上，它存在于 MIR（Mid-level IR）。MIR 是 Rust 编译器的一种中间表示。从 Rust 到 MIR 再到汇编，抽象程度逐渐降低，与物理世界的契合逐步增加。于是，MIR 需要一个概念，指涉物理世界广泛存在的“储存空间”——这便是 Place。</p><h2 id="rust-中隐匿的-place-概念">Rust 中隐匿的 Place 概念</h2><p>Place 这一抽象始于低层的 MIR，却或多或少外溢到了高层的 Rust 中。然而 Rust 有意隐匿了这一抽象，进而造就了诸如 <code>reborrow_good</code>/<code>deref_bad</code> 合法性的困惑。</p><p>“解引用”一词常被理解为“寻址+读取”。但从上文的分析我们不难看出，表达式 <code>*p</code> 实则只通过“寻址”产生了一个 Place，而是否“读取”要看后续的操作，如在 <code>deref_bad</code> 中需要对 Place 取值再重赋值，这便涉及到了对 Place 的读取。Place 本身不会造成安全问题，即便其可能非法。真正带来安全隐患的是对 Place 的事实访问。</p><p><code>*p</code> 产生一个 Place，因而也被称为 Place 表达式。除了 <code>*p</code>，还有其他一些常见的 Place 表达式，如单变量表达式 <code>x</code>，字段表达式 <code>x.y</code> 以及下标表达式 <code>x[y]</code> 等。对于 Place 表达式，我们可以进行“取址”、“读取”和“赋值”三种操作。“取址”和“赋值”分别对应 Rust 中的 <code>&amp;</code> 和 <code>=</code> 运算，但“读取”并没有类似的对应——Rust 会隐式地在合适的地方插入对 Place 的“读取”操作，淡化了这一步骤的重要性。</p><p>事实上，我们可以假想 Rust 中有个额外的 <code>load</code> 运算符。<code>load</code> 只能作用于 Place 之上，但编译器允许我们随意省略。在作类似分析时，为了看到问题的本质，我们可以显示加上省略的 <code>load</code>。还是以 <code>_p = &amp;raw const *p</code> 为例，加上 <code>load</code> 后变为：</p><div class="gk-code hljs" data-gk-id="BLOCK4"><div class="gk-code-display"><pre><span class="line">_p = &amp;raw <span class="hljs-keyword">const</span> *(load p)</span><br></pre></div></div><p>而 <code>_v = *p</code> 变为：</p><div class="gk-code hljs" data-gk-id="BLOCK5"><div class="gk-code-display"><pre><span class="line">_v = (load *(load p))</span><br></pre></div></div><p>如此一来，何处产生内存访问便一目了然。</p><hr><p>理解 Place，对于理解 Rust 中 Reborrow 等奇特概念，以及 unsafe 代码的编写，都有着重要的帮助。这些问题我会在后续博客中分析。</p><h2 id="参考">参考</h2><ul><li><a target="_blank" rel="noopener" href="https://www.ralfj.de/blog/2024/08/14/places.html">What is a place expression?</a></li></ul><br><blockquote><p class="cc">作者：hsfzxjy<br>链接：<span class="cc-link"></span><br>许可：<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>.<br>著作权归作者所有。本文<b>不允许</b>被用作商业用途，非商业转载请注明出处。</p></blockquote><script>!function(){var n=document.querySelector("span.cc-link");n&&(n.innerHTML='<a href="'+location.href+'">'+location.href+"</a>")}()</script></div><div class="post__tags"><a href="/tags/Rust/">Rust</a><a href="/tags/Compiler/">Compiler</a></div><div class="post-nav"><a href="/cohesive-digests-ints-and-floats/" class="pre">«Cohesive Digests for Ints and Floats</a><a href="/2024-10-03-art-museum/" class="next">美术馆»</a></div><div id="disqus_thread"><div id="no-comment"><h2>OOPS!</h2><span>A comment box should be right here...</span><span>But it was gone due to network issues :-(</span><span>If you want to leave comments, make sure you have access to&nbsp;<a target="_blank" rel="noopener" href="https://disqus.com">disqus.com</a>.</span></div><script>var disqus_shortname="hsfzxjy",disqus_identifier="rust-place-expression/",disqus_title="Rust 中的隐匿概念 —— Place（位置）",disqus_url="https://i.hsfzxjy.site/rust-place-expression/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.defer=!0,e.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(e),e.onerror=function(){document.getElementById("no-comment").classList.add("show")}}()</script><script id="dsq-count-scr" src="//hsfzxjy.disqus.com/count.js" async defer></script></div></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"><div id="toc" lang="zh" class="font__body"><div class="toc-toggler"></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%86%E8%A7%A3%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">拆解表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-reborrow_good"><span class="toc-number">1.1.</span> <span class="toc-text">分析 reborrow_good</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-deref_bad"><span class="toc-number">1.2.</span> <span class="toc-text">分析 deref_bad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">对比分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#place%EF%BC%88%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">Place（位置）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rust-%E4%B8%AD%E9%9A%90%E5%8C%BF%E7%9A%84-place-%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">Rust 中隐匿的 Place 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>