<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=5" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script>(()=>{let e="/cnfonts.js?rDuukLHQ",t=document,n=navigator.serviceWorker,r=!1;var a;(r=n&&(n.register(e,{scope:"/"}).then(e=>e.update()),a=n.controller)&&a.scriptURL.endsWith(e)&&"activated"===a.state?!0:r)?((a=t.createElement("link")).rel="stylesheet",a.href="/fontchan/rDuukLHQ.css",a.blocking="render",t.head.appendChild(a)):((a=t.createElement("script")).src=e,a.onload=()=>$fontchan.injectCss(),t.head.appendChild(a))})()</script><title>揭秘·变态的平方根倒数算法</title><meta itemprop="title" content="揭秘·变态的平方根倒数算法 - hsfzxjy 的博客"><meta itemprop="og:title" content="揭秘·变态的平方根倒数算法 - hsfzxjy 的博客"><meta itemprop="image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="og:image" content="https://i.hsfzxjy.site/avatar-for-hsfzxjy.jpg"><meta itemprop="description" content="
神的时代已离去
神的故事却化为传说
流落凡间
供凡人传颂、膜拜

这是什么
在上世纪 90 年代，出现过一款不可..."><meta itemprop="og:type" content="website"><link rel="stylesheet" href="/dist/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" href="/rss.xml"></head><body><nav class="nav"><span class="nav__toggler"><span class="nav__toggler-bar bar1"></span><span class="nav__toggler-bar bar2"></span><span class="nav__toggler-bar bar3"></span></span><span class="nav__core"><div class="nav__logo"><img src="/avatar.webp" loading="lazy"></div><a href="/" lang="zh" class="nav__brand">hsfzxjy</a></span><span class="nav__togglerClose"><span class="nav__togglerClose-circle"></span><span class="nav__togglerClose-bar bar1"></span><span class="nav__togglerClose-bar bar2"></span></span><div class="nav__pathIndicator"><a href="/categories/Tech/">Tech</a></div></nav><main class="mainContainer"><div lang="zh" class="post post-page"><h1 lang="zh" class="post__title">揭秘·变态的平方根倒数算法</h1><div class="post__meta font__ui">2016-08-03 | <span class="post__meta-categories"><a href="/categories/Tech/">Tech</a></span></div><div class="post__content font__body noindent"><blockquote><p>神的时代已离去 神的故事却化为传说 流落凡间 供凡人传颂、膜拜</p></blockquote><h2 id="这是什么">这是什么</h2><p>在上世纪 90 年代，出现过一款不可思议的游戏——雷神之锤（Quake series）。除了优秀的情节设定和精美的画面，最让人称道的莫过于它的运行效率——要知道在那个计算机配置低下的时代，一段小动画都是一个奇迹，但 Quake 却能流畅地运行于各种配置的电脑上。</p><p>直至 2005 年，当 Quake Engine 开源时，Quake 系列的秘密才被揭开。在代码库中，人们发现了许多堪称神来之笔的算法。它们以极其变态的高效率，压榨着计算机的性能，进而才支撑起了 90 年代 3D 游戏的传奇。其中的某些算法，甚至比系统原生的实现还要快！</p><p>我们今天的主角——快速平方根倒数算法（Fast Inverse Square Root）就是其中一个。</p><p>这是一个用于计算 $1 \over {\sqrt x}$ 的算法。这是一步重要的运算，因为在 3D 绘图中，计算机需要大量求解一个矢量的方向矢量，平方根倒数为其中的一步（$(v_x,v_y, v_z) \over {\sqrt{v_x^2+v_y^2+v_z^2}})$），而且为最麻烦的一步。如果能在此作优化，渲染效率无异会极大地提高。</p><p>然而，高效并不是它的唯一特点，吸引人们的更是其中的一个神秘的常数——$(5f3759df)_{16}$。</p><p>且看代码：</p><div class="gk-code hljs" data-gk-id="BLOCK1"><div class="gk-code-display"><pre><span class="line"><span class="hljs-type">float</span> <span class="hljs-title function_">Q_rsqrt</span><span class="hljs-params">( <span class="hljs-type">float</span> number )</span></span><br><span class="line">{</span><br><span class="line">    <span class="hljs-type">long</span> i;</span><br><span class="line">    <span class="hljs-type">float</span> x2, y;</span><br><span class="line">    <span class="hljs-type">const</span> <span class="hljs-type">float</span> threehalfs = <span class="hljs-number">1.5F</span>;</span><br><span class="line"></span><br><span class="line">    x2 = number * <span class="hljs-number">0.5F</span>;</span><br><span class="line">    y  = number;</span><br><span class="line">    i  = * ( <span class="hljs-type">long</span> * ) &amp;y;                       <span class="hljs-comment">// evil floating point bit level hacking</span></span><br><span class="line">    i  = <span class="hljs-number">0x5f3759df</span> - ( i &gt;&gt; <span class="hljs-number">1</span> );               <span class="hljs-comment">// what the fuck?</span></span><br><span class="line">    y  = * ( <span class="hljs-type">float</span> * ) &amp;i;</span><br><span class="line">    y  = y * ( threehalfs - ( x2 * y * y ) );   <span class="hljs-comment">// 1st iteration</span></span><br><span class="line"><span class="hljs-comment">//	y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> y;</span><br><span class="line">}</span><br></pre></div></div><p>翻译成数学语言就是：</p><ol><li>设输入数为 $number$，令 $ x_2=number/2, y=number $。</li><li>上式中，$y$ 是一个 32 位浮点数（可以理解为数学中的实数），现在我们将其“看作”一个整数，并赋给 $i$。</li><li>最神奇的一步出现了——用一个十六进制数 $5f3759df$ 减去 $i$ 自身右移一位的结果，并将结果赋给 $i$。</li><li>将整数 $i$ 重新“看作”是一个浮点数，并赋值给 $y$。</li><li>令 $y=y(1.5-x_2 \times y^2)$。</li><li>重复一遍操作 5（事实上这一步可以忽略）。</li></ol><p>在此需要向无计算机基础的朋友解释一下：</p><ul><li>右移（Right Shifting）指的是：将一个数表示成二进制之后整体向右移动一位，并抹去溢出的末位。如 $(4)_{10} &gt;&gt; 1=(100)_2 &gt;&gt; 1=(10)_2=(2)_{10}$。其效果等价为整除 2，但由于有 CPU 指令直接支持，速度比整除快若干个数量级。</li><li>无论是实数还是整数，在计算机中只不过是一串二进制序列。因此一串二进制序列，既可以被看作一个实数，也可以被看作一个整数。</li></ul><p>这个算法得到的只是一个近似值。对于 $[0.01, max\_float]$ 内的所有浮点数，最大误差为 $0.175%$（见 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fast_inverse_square_root">Accuracy</a>）。但它却比内置算法 <code>1.0/sqrt(x)</code> 快 4 倍，可谓瑕不掩瑜。</p><p>那么，它究竟是怎么实现的呢？</p><h2 id="牛顿法">牛顿法</h2><p>我们从后面开始分析。</p><p>从代码中可以看出：算法最后有两步相同的操作，像是在对一个数进行某种迭代。而其中的第二步被注释掉了，似乎是因为和性能损耗相比对结果的二次迭代意义不大，也说明 <strong>一次迭代的结果在误差允许范围内</strong>——这让人想到了牛顿法。</p><p>牛顿法是什么？</p><p>牛顿法是一种常用的求方程数值解的方法。其叙述如下：</p><blockquote><p>若在某个区间 $I$ 中，$f(x)$ 连续可导，且有唯一零点 $x_0$，则任取 $x_1 \in I$，定义数列 $x_{n+1}=x_n-{f(x_n) \over {f&#39;(x_n)}}$，则有 $lim_{n \to \infty}{x_n}=x_0$。</p></blockquote><p>用牛顿法进行迭代，可以完成对解任意精度的数值逼近。下面我们尝试写出 $x={1 \over {\sqrt {a}}}$的迭代式。</p><p>令 $f(x)={ {1 \over x^2}-a}$，则有</p><p>$$ x\_{n+1}=x_n-{f(x_n) \over {f&#39;(x_n)}} $$ $$ =x_n-{ { {1 \over x_n^2} -a} \over {-2 \over {x_n^3} } } $$ $$ ={3 \over 2}x_n - { {ax_n^3} \over 2} $$ $$ ={x_n}(1.5-{a \over 2}x_n^2)$$</p><p>如果我们将$x_{n+1}$、$x_n$替换成$y$，将$a \over 2$替换成$x2$，可以发现和算法的最后一步是吻合的。由此可知：<strong>算法的最后确实采用了牛顿法</strong>。</p><p>也许你注意到：能解出 $1 \over {\sqrt a}$ 的方程不止这一条，迭代式的形式有很多。事实上，作者有意选择了这条方程——因为只有从这条方程得出的迭代式是 <strong>不用除法的</strong>。除法的性能十分糟糕，应该尽量避免。</p><p>但是，牛顿法不是需要迭代多次的吗？怎么在这里只进行一次就足够精确了呢？</p><p>牛顿法的收敛过程依赖于初值$x_1$的选取。若想一步到位，除非初值本身已经足够精确了。</p><p>初值是什么？</p><p>就是那神奇的第 3 步得到的结果。</p><h2 id="神奇的-0x5f3759df">神奇的 0x5f3759df</h2><p>这是整个算法的奥妙所在。我们再来回顾一下：</p><ol start="2"><li>上式中，$y$ 是一个 32 位浮点数（可以理解为数学中的实数），现在我们将其“看作”一个整数，并赋给 $i$。</li><li>最神奇的一步出现了——用一个十六进制数 $5f3759df$ 减去 $i$ 自身右移一位的结果，并将结果赋给 $i$。</li><li>将整数 $i$ 重新“看作”是一个浮点数，并赋值给 $y$。</li></ol><p>有了上一节的分析，几乎可以肯定：这是为了得到 $1 \over {\sqrt {number} }$ 的一个粗略值，即应该有 $y \approx {1 \over {\sqrt {number} } }$。</p><p>为了进一步的论证，我们首先要了解一个知识点：</p><h3 id="ieee-754（浮点数储存标准）">IEEE 754（浮点数储存标准）</h3><p><a target="_blank" rel="noopener" href="http://grouper.ieee.org/groups/754/">IEEE 754: Standard for Binary Floating-Point Arithmetic</a></p><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE floating point - Wikipedia</a></p><p>这是计算机内实数的储存标准。</p><p>在本算法中，我们使用的是 32 位浮点数（即 用 32 个二进制位表示一个实数）。储存方式如下：</p><blockquote><p>对任意一个实数 $x$，总可以将其分解为如下形式： $$ x=2^E \times (1+M)\ (E \in Z,M \in [0, 1))$$ 则 32 个二进制位安排如下： $$ S,EEEEEEEE,MMMMMMMMMMMMMMMMMMMMMM $$</p><ul><li>首位为符号位，取 <code>0</code> 为正数，取 <code>1</code> 为负数</li><li>接下来 8 位为 <strong>带符号</strong> 指数。根据带符号数的储存方式，该数减去 127 才为真实的指数 $E$</li><li>接下来 23 位为底数。是 $M$ 左移 23 位再取整的结果</li></ul></blockquote><p>举个例子：将 $0.15625=(0.00101)_2$ 换算成浮点数：</p><p>$$ 0.15625=+2^{-3}\times(1+0.25) $$</p><p>则有：</p><ul><li>符号位为 $0$</li><li>$E=-3$，换算成带符号正数为 $-3+127=124=(01111100)_2$</li><li>$M=0.25=(0.01)_2$，左移 23 位后为 $(01000000000000000000000)_2$</li></ul><p>从而浮点表示为：$0,01111100,01000000000000000000000$</p><h3 id="回到原题">回到原题</h3><p>现在，让我们思考一下：</p><p>如何只用加、减、乘和位运算神出鬼没地快速逼近 $1 \over {\sqrt x}$？</p><p>若想回答这个问题，得看我们对 $x$ 了解多少。</p><p>从上一小节的浮点数标准可以看出：<strong>计算机看到的 x 和我们接触的 x 结构不同</strong>，早在程序的编译期，$x$ 就被拆成了指数和底数两部分，并被打包存好——这一步是不耗时间的，但却给我们提供了海量的信息。</p><p>等等！指数和底数！似乎在暗示着什么！</p><p>我们，是不是可以通过对数进行运算？</p><p>设想，如果我们能利用以上信息，轻易地转换 $x$ 和 $\log_2 x$，由 $\log_2 {1 \over {\sqrt x}}={-{1 \over 2}}{\log_2 x}$ 就可以求得 $1 \over {\sqrt x}$ 的值了。</p><p>那么，$\log_2 x$ 该如何表示呢？且看以下变换。</p><p>根据 IEEE 754，对于一个 $x=2^E \times (1+M)&gt;0$，如果我们将其 32 位浮点表示看作一个 32 位整数 $I$，则有</p><p>$$I=2^{23}\times (E+127)+2^{23}\times M$$ $$=2^{23}\times (E+127+M)$$</p><p>这个 $I$ 为已知量。通过已知量 $I$，我们可以得到已知量 $E+M$。</p><p>而另一方面，</p><p>$$ \log_2 x=\log_2 {2^E \times (1+M)} $$ $$ = E + \log_2(1+M) $$</p><p>记</p><p>$$ F(M) = M $$ $$ G(M) = \log_2(1+M) $$</p><p><strong>注意到：当 $M\in[0,1)$ 时，$G(M)\in[0,1)$。同时观察图像可以发现 $G(M)$ 在此区间接近线性。</strong></p><p><img loading="lazy" src="/assets/log2_1_x_and_x.png" alt=""></p><p>因此，我们可以通过上下移动 $F(M)$ 对 $G(M)$ 进行线性拟合。</p><p>注意一下这个例子中的误差衡量标准：<strong>我们在尽量减小误差的同时，也要保证误差分布尽量均匀，从而最大误差要尽量小</strong>。</p><p>综合以上考虑，问题最终化简为：</p><blockquote><p>找到一个$\sigma$，对$\Delta(M)=\log_2(1+M)-(M+\sigma)$，使$|\Delta(M)|$在 $[0,1)$ 上的最大值尽量小。</p></blockquote><p>易知：$|\Delta(0)|=|\Delta(1)|=\sigma$，另一个可能的极值点$M_0$满足$\Delta&#39;(M_0)=0$，解得$M_0={1\over \ln 2}$</p><p>当 $max\{|\Delta(M)|\}$ 最小时，必有：$\Delta(M_0)=\sigma$。解得 $\sigma=0.0430356660279671$。</p><p>从而我们有：$ \log_2 (1+M) \approx M+\sigma $。进而：</p><p>$$ I=2^{23}\times(E+M+127)$$ $$ = 2^{23}\times(127+E+M+\sigma-\sigma)$$ $$ \approx 2^{23}\times(127-\sigma+(E+\log_2(1+M)))$$ $$ = 2^{23}\times(127-\sigma+\log_2 x)$$</p><p>则有：</p><p>$$ {I \over 2^{23}} + \sigma - 127 \approx \log_2 x $$</p><p>记 $r={1 \over {\sqrt x} }$ 对应的 $I$ 值为 $I_r$。则：</p><p>$$ I*r \approx 2^{23}\times(127-\sigma+\log_2 m)$$ $$ = 2^{23}\times(127-\sigma-{1 \over 2}{\log_2 x})$$ $$ \approx 2^{23}\times(127-\sigma-{1 \over 2}({I \over 2^{23}} + \sigma - 127))$$ $$ = (127-\sigma)\times 2^{22} \times 3-{I \over 2}$$ $$ = (5f37bcb6)*{16}-{I \over 2}$$ $$ = (5f37bcb6)\_{16}-(I &gt;&gt; 1)$$</p><p>这便是步骤 3 的那个式子，神秘的常数终于出现了。</p><p>这里算得的常数和原算法有一些不同，主要是 $\sigma$ 取值差异造成的。如果我们取 $\sigma= 0.0450466$ 就会得到原算法的常数。作者选取了后者，应该是综合考虑了牛顿法迭代产生的误差。我没有深入研究——事实上，在允许范围内微调 $\sigma$ 不会对精度和速度产生显著影响。</p><h2 id="lomont-的另一种诠释">Lomont 的另一种诠释</h2><p>尽管 Quake Engine 的源码直到 2005 年才被公开，这个算法却在 2000 年左右即为人们所知。2003 年，数学家 Chris Lomont 曾写过一篇 <a target="_blank" rel="noopener" href="http://www.lomont.org/Math/Papers/2003/InvSqrt.pdf">论文</a>讨论过这一常数的由来。他采用了另一种不同的方法。</p><p>Lomont 也发现 <code>i = 0x5f3759df - ( i &gt;&gt; 1 )</code> 实为 $1 \over {\sqrt x}$ 的粗略逼近，但他没有深究这个式子背后的数学含义，而是将此常数泛化为一个变量 $R$，通过最小化其与 $1 \over {\sqrt x}$ 的误差，反解出常数 $R$，其中运用的一些技巧值得品味。</p><p>有趣的是，他在论文中提供了另一个他认为最佳的常数 <code>5f375a86</code>，并通过实测证实了他的想法。但此常数只是以毫厘之差险胜原算法（一次迭代 $0.175228$ vs $0.175124$，二次迭代 $4.66 \times 10^{-4}$ vs $4.65437 \times 10^{-4}$）。Lomont 在论文中表达了他的惊讶，这个实验同时也使那位不知名的作者（传闻说是 Quake 的作者 Carmack，然而他自己不承认）更加扑朔迷离。</p><h2 id="总结--推广">总结 &amp; 推广</h2><p>这个算法的核心其实很简单：先使用某种手段近似估计解，再用牛顿法迭代增加精确度。同时，它也启示我们： <strong>浮点数表示和对数之间存在某种联系</strong>，而对数恰是我们简化计算的利器。</p><p>按照这个思路，我们可以拓展出立方根倒数的对应算法，也可以将 32 位算法改写为 64 位（Lomont 在他的论文中提供了 64 位的常数 <code>0x5fe6ec85e7de30da</code>）。现如今，这些算法的加速效应已经不太明显了，但深入剖析上古神话背后的理论，也未尝不是件有趣的事。</p><blockquote><p>也许 他真的是神</p></blockquote><h2 id="参考文献">参考文献</h2><ul><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fast_inverse_square_root">Fast inverse square root - Wikipedia</a></li><li><a target="_blank" rel="noopener" href="http://www.lomont.org/Math/Papers/2003/InvSqrt.pdf">FAST INVERSE SQUARE ROOT - CHRIS LOMONT</a></li></ul><br><blockquote><p class="cc">作者：hsfzxjy<br>链接：<span class="cc-link"></span><br>许可：<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>.<br>著作权归作者所有。本文<b>不允许</b>被用作商业用途，非商业转载请注明出处。</p></blockquote><script>!function(){var n=document.querySelector("span.cc-link");n&&(n.innerHTML='<a href="'+location.href+'">'+location.href+"</a>")}()</script></div><div class="post__tags"><a href="/tags/Fast-Inverse-Square-Root-Algorithm/">Fast Inverse Square Root Algorithm</a></div><div class="post-nav"><a href="/leaving-guangzhou/" class="pre">«最后的雨夜·广州</a><a href="/recursively-calling-when-decorating-a-python-class/" class="next">神坑·Python 装饰类无限递归»</a></div><div id="disqus_thread"><div id="no-comment"><h2>OOPS!</h2><span>A comment box should be right here...</span><span>But it was gone due to network issues :-(</span><span>If you want to leave comments, make sure you have access to&nbsp;<a target="_blank" rel="noopener" href="https://disqus.com">disqus.com</a>.</span></div><script>var disqus_shortname="hsfzxjy",disqus_identifier="uncover-the-secret-of-fast-inverse-square-root-algorithm/",disqus_title="揭秘·变态的平方根倒数算法",disqus_url="https://i.hsfzxjy.site/uncover-the-secret-of-fast-inverse-square-root-algorithm/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.defer=!0,e.src="https://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(e),e.onerror=function(){document.getElementById("no-comment").classList.add("show")}}()</script><script id="dsq-count-scr" src="//hsfzxjy.disqus.com/count.js" async defer></script></div></div></main><section class="aside__group"><span class="aside__btn"><div lang="zh" class="github-btn"><a href="#" rel="noopener noreferrer" target="_blank" class="gh-btn"><span class="gh-ico"></span><span class="gh-text">FOLLOW ME</span></a><a href="#" rel="noopener noreferrer" target="_blank" class="gh-count"></a></div><script>window.GH_BUTTON={username:"hsfzxjy"}</script></span><aside class="aside__left"><div class="aside__menuList"><span class="aside__menuList-item__icon"><i class="icon-home"></i></span><a href="/" class="aside__menuList-item"><span lang="zh" class="font__ui">首页 / Home</span></a><span class="aside__menuList-item__icon current"><i class="icon-embed2"></i></span><a href="/categories/Tech/" class="aside__menuList-item current"><span lang="zh" class="font__ui">科技 / Tech</span></a><span class="aside__menuList-item__icon"><i class="icon-android"></i></span><a href="/categories/Soliloquy/" class="aside__menuList-item"><span lang="zh" class="font__ui">呓语 / Soliloquy</span></a><span class="aside__menuList-item__icon"><i class="icon-leaf"></i></span><a href="/categories/Life/" class="aside__menuList-item"><span lang="zh" class="font__ui">生活 / Life</span></a><span class="aside__menuList-item__icon"><i class="icon-bookmarks"></i></span><a href="/categories/Memo/" class="aside__menuList-item"><span lang="zh" class="font__ui">速记 / Memo</span></a><span class="aside__menuList-item__icon"><i class="icon-books"></i></span><a href="/categories/Series/" class="aside__menuList-item"><span lang="zh" class="font__ui">连载 / Series</span></a><span class="aside__menuList-item__icon"><i class="icon-sigma"></i></span><a href="/works/" class="aside__menuList-item"><span lang="zh" class="font__ui">项目 / Projects</span></a><span class="aside__menuList-item__icon"><i class="icon-earth"></i></span><a href="/links/" class="aside__menuList-item"><span lang="zh" class="font__ui">友链 / Links</span></a><span class="aside__menuList-item__icon"><i class="icon-wink"></i></span><a href="/about/" class="aside__menuList-item"><span lang="zh" class="font__ui">关于 / About</span></a><span class="aside__menuList-item__icon"><i class="icon-history"></i></span><a href="/aggr/" class="aside__menuList-item"><span lang="zh" class="font__ui">索引 / Index</span></a><span class="aside__menuList-item__icon"><i class="icon-rss2"></i></span><a href="/rss.xml" class="aside__menuList-item"><span lang="zh" class="font__ui">订阅 / RSS</span></a></div></aside><aside class="aside__right"><div id="toc" lang="zh" class="font__body"><div class="toc-toggler"></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">这是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%9B%E9%A1%BF%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">牛顿法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A5%9E%E5%A5%87%E7%9A%84-0x5f3759df"><span class="toc-number">3.</span> <span class="toc-text">神奇的 0x5f3759df</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ieee-754%EF%BC%88%E6%B5%AE%E7%82%B9%E6%95%B0%E5%82%A8%E5%AD%98%E6%A0%87%E5%87%86%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">IEEE 754（浮点数储存标准）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0%E5%8E%9F%E9%A2%98"><span class="toc-number">3.2.</span> <span class="toc-text">回到原题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lomont-%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E8%AF%A0%E9%87%8A"><span class="toc-number">4.</span> <span class="toc-text">Lomont 的另一种诠释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93--%E6%8E%A8%E5%B9%BF"><span class="toc-number">5.</span> <span class="toc-text">总结 &amp; 推广</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">6.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div></aside></section><div id="footer" style="text-align:center" lang="zh" class="font__ui">© <a href="/" rel="nofollow">hsfzxjy 的博客.</a>&nbsp;Powered by&nbsp;<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy/byak-hexo">Theme</a>&nbsp;by&nbsp;<a rel="nofollow" target="_blank" href="https://github.com/hsfzxjy">hsfzxjy</a>.<div style="margin-top:10px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011202001249" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="/img/beian.png" style="float:left" loading="lazy"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤公网安备44011202001249号</span></a><a target="_blank" style="display:inline-block;text-decoration:none;height:20px;line-height:20px" href="http://beian.miit.gov.cn/"><span style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">粤ICP备2020075702号-1</span></a></div></div></body><script src="/dist/js/main.js" async defer></script></html>